<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[m78snail]]></title>
  <link href="m78snail.com/atom.xml" rel="self"/>
  <link href="m78snail.com/"/>
  <updated>2017-02-14T17:02:36+08:00</updated>
  <id>m78snail.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Android 常见面试题（四）]]></title>
    <link href="m78snail.com/14870550376223.html"/>
    <updated>2017-02-14T14:50:37+08:00</updated>
    <id>m78snail.com/14870550376223.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">21. Android内存优化方法：ListView优化，及时关闭资源，图片缓存等等</h2>

<p>首先有一些与内存泄漏相关的点：<br/>
<strong>1.具有close方法的对象切记调用close方法释放资源</strong><br/>
常见的有Cursor和各种流等对象。博主就曾经因为Cursor对象忘记close，在进行了多次数据库查询后APP就因为OOM而崩溃了。</p>

<p><strong>2.动态注册的广播不使用后记得取消注册</strong><br/>
取消注册后可释放Context中持有的相关的广播过滤器资源。</p>

<p><strong>3.bitmap的recycle方法</strong><br/>
在Android3.0版本以前，bitmap对象的构造涉及到JVM的两块内存区域：一块是Bitmap对象所在的Java堆，一块是Bitmap对象持有的native层资源所在的Native堆。在Java堆上分配的资源由于JVM的GC机制的关系我们不需要去特别关心，但在Native堆上分配的资源就需要我们显式地调用bitmap的native方法recycle去回收了。然而在Android3.0版本后bitmap内存资源分配都在Java堆上，因此是否调用recycle方法对内存影响就不大了。</p>

<p><strong>4.listView的Adapter中注意convertView的使用</strong><br/>
在Adapter的getView方法中，有一个重要的参数就是convertView。convertView是一个View参数，它代表了一个回收的View（如果没有就为null）。Android的ListView虽然看起来有很多项，但其实真正的ItemView的数目只有屏幕上显示的哪几个，当一个ItemView从可见变为不可见时，他就会被回收掉，在下次调用getView方法时传入的convertView就是某个被回收的View。因此在getView方法中，当convertView不为null时，我们应该使用convertView而不是重新创建一个View。更高效的方式是把convertView结合一个自定义的ViewHolder一起使用，可以有效的减少findViewById的时间。</p>

<p><strong>5.handler</strong><br/>
Handler常见的应用场景是多线程的通信，此时要是Handler使用不当就相当容易造成内存泄露。在多线程通信的场景下，子线程通常都会持有Handler对象的引用，如果一个Handler对象在Activity中不是静态的，那么该Handler对象就会持有该Activity对象的引用，从而导致Activity组件无法正常的被GC回收，导致了内存泄露。因此一般而言我们应该把Handler对象置为Activity中的静态变量，通过软引用或者弱引用的方式来获取Activity及其内部域，避免持有Activity的强引用导致该组件无法回收。</p>

<p><strong>6.集合对象清理</strong><br/>
对于一些集合中不再使用的对象，我们应该把它们移除出我们的集合。避免由于集合持有那些对象的引用导致它们无法被JVM的GC所回收。</p>

<p>还有一些内存优化的方法，个人认为有以下几个方面：</p>

<ul>
<li>Java引用的灵活使用</li>
<li>图片缓存</li>
<li>Bitmap压缩加载</li>
</ul>

<p><strong>Java引用的灵活使用</strong><br/>
众所周知，在Java中有强软弱虚四种引用，合理的使用软引用和弱引用有利于GC工作的进行，回收不需要的内存。</p>

<p><strong>图片缓存</strong><br/>
使用图片缓存可以有效防止内存中同时载入过多的图片，也可以减少经常载入图片所耗费的时间。<br/>
一般而言，设计图片缓存的思路如下，可以把图片的缓存分为以下几个层级：</p>

<ul>
<li>强引用 HashMap （用于存储最常用的图片）</li>
<li>软引用 HashMap （用于存储比较常用的图片）</li>
<li>SD卡 （用于存储使用过的图片）</li>
<li>下载 （第一次使用）</li>
</ul>

<p>一般而言我们都是用LRU算法（最近最少使用），最近使用的图片一般缓存于强引用的HashMap中，随着使用次数的减少慢慢移动至软引用HashMap、SD卡中。<br/>
除了我们自己设计图片缓存外，我们还可以直接使用Google提供的LruCache（内部由LinkedHashMap实现缓存队列），以及DiskLruCache<br/>
<strong>Bitmap压缩加载</strong><br/>
对于某些原尺寸特别大的图片，我们可以选择压缩后再加载以节省我们的内存空间：</p>

<pre><code>// 创建解析参数  
Options options = new Options();  
// 只解析大小，并不生成实际图片  
options.inJustDecodeBounds = true;  
BitmapFactory.decodeFile(pathName, options);  
// 计算缩放大小  
int widthScale = options.outWidth/width_we_need;  
int heightScale = options.outHeight/height_we_need;  
// 选取小的为缩放尺寸  
options.inSampleSize = Math.min(widthScale, heightScale);  
// 生成Bitmap  
options.inJustDecodeBounds = false; // 记得关掉  
Bitmap bitmap = BitmapFactory.decodeFile(pathName, options); 
</code></pre>

<p>压缩到合适的尺寸后再加载就不必担心原来的bitmap太大而占用内存空间了。</p>

<h2 id="toc_1">22. Android中弱引用与软引用的应用场景</h2>

<p>软引用与弱引用一般用于：需要某个对象，但又不关心它的死活的时候（就是该对象存在就用，不存在就算了）。<br/>
在Android中的应用场景主要有：</p>

<ul>
<li>Handler获取Activity的引用：使用静态变量和软弱引用保证不干扰Activity的回收</li>
<li>缓存设计：使用软弱应用保证内存紧张时GC可以回收使用较少的缓存资源</li>
</ul>

<h2 id="toc_2">23. Bitmap的四中属性，与每种属性队形的大小。</h2>

<p>在 <strong>Android</strong> 中图片有四种属性，分别是：<br/>
<strong>ALPHA_8</strong>：每个像素占用 1byte 内存<br/>
<strong>ARGB_4444</strong>：每个像素占用 2byte 内存<br/>
<strong>ARGB_8888</strong>：每个像素占用 4byte 内存 （默认）<br/>
<strong>RGB_565</strong>：每个像素占用 2byte 内存(没有 alpha 属性)</p>

<h2 id="toc_3">24. View与View Group分类，自定义View过程：onMeasure()、onLayout()、onDraw()</h2>

<p>View是Android中基本的UI单元，占据屏幕的一块矩形区域，可用于绘制并能处理事件，而ViewGroup是View的子类，他能包含多个View，并让他们在其中按照一定的规则排列。VIew与ViewGroup的设计使用了组合模式。</p>

<p>自定义View我们一般需要重写一下三个方法：</p>

<ul>
<li>onMeasure：用于测量自定义View的大小，在方法中必须调用setMeasureDimension方法</li>
<li>onLayout：用于确定自定义View布局</li>
<li>onDraw：用于绘制自定义View本身</li>
</ul>

<h2 id="toc_4">25. Touch事件分发机制</h2>

<p><img src="media/14870550376223/14870559086978.jpg" alt=""/></p>

<h2 id="toc_5">26. Android长连接，怎么处理心跳机制</h2>

<p>　　所谓的心跳包就是客户端定时放送简单的信息给服务器端，告诉它我还在而已。代码就是每隔几分钟发送一个固定信息给服务器端，服务器端回复一个固定信息。如果服务器端几分钟后没有收到客户端信息则视客户端断开。比如有些通信软件长时间不适用，要想知道它的状态是在线还是离线，就需要心跳包，定时发包收包。<br/>
　　心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活在。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。<br/>
　　在TCP机制里面，本身是存在有心跳包机制的，也就是TCP选项:SO_KEEPALIVE. 系统默认是设置的2小时的心跳频率。<br/>
心跳包的机制，其实就是传统的长连接。或许有的人知道消息推送的机制，消息推送也是一种长连接 ，是将数据有服务器端推送到客户端这边从而改变传统的“拉”的请求方式。下面我来介绍一下安卓和客户端两个数据请求的方式<br/>
　　1、push  这个也就是有服务器推送到客户端这边  现在有第三方技术 比如极光推送。<br/>
　　2、pull   这种方式就是客户端向服务器发送请求数据（http请求）<br/>
<strong>1、首先服务器和客户端有一次“握手”</strong></p>

<pre><code>public void connect()  
      {  
        LogUtil.e(TAG, &quot;准备链接...&quot;);  
        InetAddress serverAddr;  
        try {  
            socket = new Socket(Config.Host, Config.SockectPort);  
            _connect = true;  
            mReceiveThread = new ReceiveThread();  
            receiveStop = false;  
            mReceiveThread.start();  
            LogUtil.e(TAG, &quot;链接成功.&quot;);  
  
        } catch (Exception e) {  
            LogUtil.e(TAG, &quot;链接出错.&quot; + e.getMessage().toString());  
            e.printStackTrace();  
        }  
    }  
</code></pre>

<p><strong>2、下面就要开启一个线程  去不断读取服务器那边传过来的数据  采用Thread去实现</strong></p>

<pre><code>private class ReceiveThread extends Thread {  
        private byte[] buf;  
        private String str = null;  
  
        @Override  
        public void run() {  
            while (true) {  
                try {  
                    // LogUtil.e(TAG, &quot;监听中...:&quot;+socket.isConnected());  
                    if (socket!=null &amp;&amp; socket.isConnected()) {  
  
                        if (!socket.isInputShutdown()) {  
                            BufferedReader inStream = new BufferedReader(  
                                    new InputStreamReader(  
                                            socket.getInputStream()));  
                            String content = inStream.readLine();                              
                            if (content == null)  
                                continue;  
                            LogUtil.e(TAG, &quot;收到信息:&quot; + content);  
                            LogUtil.e(TAG, &quot;信息长度:&quot;+content.length());  
                            if (!content.startsWith(&quot;CMD:&quot;))  
                                continue;  
                            int spacePos = content.indexOf(&quot; &quot;);  
                            if (spacePos == -1)  
                                continue;  
                            String cmd = content.substring(4, spacePos);  
                            String body = content.substring(spacePos).trim();  
                            LogUtil.e(TAG, &quot;收到信息(CMD):&quot; + cmd);  
                            LogUtil.e(TAG, &quot;收到信息(BODY):&quot; + body);  
                            if (cmd.equals(&quot;LOGIN&quot;))  
                           {  
                                // 登录  
                                ReceiveLogin(body);  
                                continue;  
                            }  
                              if (cmd.equals(&quot;KEEPLIVE&quot;)) {  
                                if (!body.equals(&quot;1&quot;)) {  
                                    Log.e(TAG, &quot;心跳时检测到异常，重新登录!&quot;);  
                                    socket = null;  
                                    KeepAlive();  
                                } else {  
                                    Date now = Calendar.getInstance().getTime();  
                                    lastKeepAliveOkTime = now;  
                                }  
                                continue;  
                            }  
                        }  
                    } else {  
                        if(socket!=null)  
                            LogUtil.e(TAG, &quot;链接状态:&quot; + socket.isConnected());  
                    }  
  
                } catch (Exception e) {  
                    LogUtil.e(TAG, &quot;监听出错:&quot; + e.toString());  
                    e.printStackTrace();  
                }  
            }  
        }  
</code></pre>

<p><strong>3 、 Socket 是否断开了  断开了 需要重新去连接</strong></p>

<pre><code>public void KeepAlive()  
        {  
        // 判断socket是否已断开,断开就重连  
        if (lastKeepAliveOkTime != null) {  
            LogUtil.e(  
                    TAG,  
                    &quot;上次心跳成功时间:&quot;  
                            + DateTimeUtil.dateFormat(lastKeepAliveOkTime,  
                                    &quot;yyyy-MM-dd HH:mm:ss&quot;));  
            Date now = Calendar.getInstance().getTime();  
            long between = (now.getTime() - lastKeepAliveOkTime.getTime());// 得到两者的毫秒数  
            if (between &gt; 60 * 1000) {  
                LogUtil.e(TAG, &quot;心跳异常超过1分钟,重新连接:&quot;);  
                lastKeepAliveOkTime = null;  
                socket = null;  
            }  
  
        } else {  
            lastKeepAliveOkTime = Calendar.getInstance().getTime();  
        }  
  
        if (!checkIsAlive()) {  
            LogUtil.e(TAG, &quot;链接已断开,重新连接.&quot;);  
            connect();  
            if (loginPara != null)  
                Login(loginPara);  
        }  
  
    //此方法是检测是否连接  
      boolean checkIsAlive() {  
        if (socket == null)  
            return false;  
            try {  
            socket.sendUrgentData(0xFF);  
        } catch (IOException e) {  
            return false;  
        }  
        return true;  
  
    }  
   //然后发送数据的方法  
    public void sendmessage(String msg) {  
        if (!checkIsAlive())  
            return;  
        LogUtil.e(TAG, &quot;准备发送消息:&quot; + msg);  
        try {  
            if (socket != null &amp;&amp; socket.isConnected()) {  
                if (!socket.isOutputShutdown()) {  
                    PrintWriter outStream = new PrintWriter(new BufferedWriter(  
                            new OutputStreamWriter(socket.getOutputStream())),  
                            true);  
  
                    outStream.print(msg + (char) 13 + (char) 10);  
                    outStream.flush();  
                }  
            }  
            LogUtil.e(TAG, &quot;发送成功!&quot;);  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  
</code></pre>

<hr/>

<p>实现轮询</p>

<p>原理 <br/>
其原理在于在android端的程序中，让一个SERVICE一直跑在后台，在规定时间之内调用服务器接口进行数据获取。</p>

<p>这里的原理很简单，当然实现起来也不难；</p>

<p>然后，这个类之中肯定要做网络了数据请求，所以我们在Service中建立一个线程（因为在android系统中网络请求属于长时间操作，不能放主线程，不然会导致异常），在线程中和服务器进行通信。</p>

<p>最后，这个逻辑写完后，我们需要考虑一个问题，如何进行在规定时间内调用该服务器，当然可以用Thread+Handler(这个不是那么稳定),也可以使用AlamManager+Thread（比较稳定），因为我们需要其在后台一直运行，所以可以依靠系统的Alammanager这个类来实现，Alammanager是属于系统的一个闹钟提醒类，通过它我们能实现在规定间隔时间调用，并且也比较稳定，这个service被杀后会自己自动启动服务。</p>

<h2 id="toc_6">27. Zygote的启动过程。</h2>

<p>　　1. 系统启动时init进程会创建Zygote进程，Zygote进程负责后续Android应用程序框架层的其它进程的创建和启动工作。<br/>
　　2. Zygote进程会首先创建一个SystemServer进程，SystemServer进程负责启动系统的关键服务，如包管理服务PackageManagerService和应用程序组件管理服务ActivityManagerService。<br/>
　　3. 当我们需要启动一个Android应用程序时，ActivityManagerService会通过Socket进程间通信机制，通知Zygote进程为这个应用程序创建一个新的进程。</p>

<h2 id="toc_7">28. Android IPC:Binder原理</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 常见面试题（三）]]></title>
    <link href="m78snail.com/14870545331290.html"/>
    <updated>2017-02-14T14:42:13+08:00</updated>
    <id>m78snail.com/14870545331290.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">16. 动画有哪几类，各有什么特点</h2>

<p>如今Android的动画主要有三种，分别是：逐帧（Frame）动画，补间（Tween）动画，属性（Property）动画</p>

<h2 id="toc_1">17. Handler、Looper消息队列模型，各部分的作用。</h2>

<p>简单提提Handler、Looper模型中各部分的作用，主要有以下三部分：</p>

<ul>
<li>MessageQueue：消息队列，存储待处理的消息</li>
<li>Looper：封装了消息队列与Handler，线程绑定，使用loop方法循环处理消息</li>
<li>Handler：消息处理的辅助类，里面封装了消息的投递、处理和获取等一系列操作</li>
</ul>

<h2 id="toc_2">18. 怎样退出终止App</h2>

<p>测试：<br/>
依次打开3个Activity（ActivityA，ActivityB，ActivityC），并在第3个Activity中终止App<br/>
System.exit（0）<br/>
重写Application方法：</p>

<pre><code>public class MyApplication extends Application {  
  
    public void exit() {  
        System.exit(0);  
    }  
      
}  
</code></pre>

<p>切记在AndroidManifest中修改使用的Application</p>

<p>在第三个Activity中调用该方法：</p>

<pre><code>public class ActivityC extends Activity {  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity);  
        Button button = (Button)findViewById(R.id.btn);  
        button.setText(&quot;Finish app&quot;);  
        button.setOnClickListener(new OnClickListener() {  
              
            @Override  
            public void onClick(View v) {  
                // 退出App  
                ((MyApplication)getApplication()).exit();  
            }  
        });  
    }  
}  
</code></pre>

<p>失败，应用进程被杀死，然而过会应用重启了……并且ActivityA和ActivityB都被“复活了”，只杀死了ActivityC。</p>

<p><strong>android.os.Process.killProcess(android.os.Process.myPid())</strong><br/>
失败，与System.exit（0）一样，虽然杀死了进程，但过会就被重启了，并且ActivityA和ActivityB都被“复活了”。</p>

<p><strong>ActivityManager am= (ActivityManager) this.getSystemService(Context.ACTIVITY_SERVICE);<br/>
am.killBackgroundProcesses(this.getPackageName());</strong><br/>
失败，毫无反应。</p>

<p><strong>自定义BaseActivity维护Activity列表</strong><br/>
自定义一个BaseActivity：</p>

<pre><code>public class BaseActivity extends Activity {  
  
    // 维护一个Activity软引用的列表  
    private static List&lt;SoftReference&lt;Activity&gt;&gt; list = new ArrayList&lt;SoftReference&lt;Activity&gt;&gt;();  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        list.add(new SoftReference&lt;Activity&gt;(this));  
    }  
  
    @Override  
    protected void onDestroy() {  
        super.onDestroy();  
        list.remove(new SoftReference&lt;Activity&gt;(this));  
    }  
  
    /** 
     * 关闭所有的Activity 
     */  
    public void finishAll() {  
        for (SoftReference&lt;Activity&gt; sr : list) {  
            if (sr.get() != null) {  
                sr.get().finish();  
            }  
        }  
    }  
  
}  
</code></pre>

<p>对于ActivityA、ActivityB和ActivityC继承BaseActivity而不是Activity，在ActivityC中调用finishAll方法即可关闭所有Activity进而退出App。</p>

<p><strong>finishAffinity</strong>()<br/>
直接关闭相同任务栈中的所用Activity，与上一个方法效果差不多，但是是Android自带的，方便多了。</p>

<p>综上所述，测试结果如下：<br/>
　　1. System.exit（0）：只能关闭当前Activity，关闭进程可能导致数据存储问题，不推荐<br/>
　　2. Android.os.Process.killProcess(android.os.Process.myPid())：同上<br/>
　　3. ActivityManager am= (ActivityManager) this.getSystemService(Context.ACTIVITY_SERVICE);<br/>
am.killBackgroundProcesses(this.getPackageName())：测试无效<br/>
　　4. 自定义BaseActivity维护Activity列表：可以关闭依次启动的所用Activity，进而退出整个App<br/>
　　5. finishAffinity()：可以关闭同一个任务栈中的所有Activity，Android自带方法，比较方便</p>

<h2 id="toc_3">19. Asset目录与res目录的区别</h2>

<p>Asset目录和res目录均为Android中用来存放资源的目录，其中：</p>

<ul>
<li>asset目录下存放的资源代表应用无法直接访问的原生资源，应用程序需要通过AssetManager以二进制流的形式来读取资源</li>
<li>res目录下的资源可通过R资源清单类访问，Android SDK会在编译时在R类中为他们创建对应的索引项</li>
</ul>

<h2 id="toc_4">20. Android怎么加速启动Activity</h2>

<p>个人认为，影响Activity启动时间的主要有两个地方：<br/>
　　1. onCreate、onStart、onResume等回调方法的执行时间<br/>
　　2. Activity对应的界面的inflate时间<br/>
对于第一点，我们应该尽量减少在这些回调方法中执行耗时操作（涉及数据库，图片等），如果一定要执行耗时操作，可以考虑新开子线程处理。<br/>
对于第二点，我们应该合理使用各种xml的优化标签，并界面上减少View的嵌套层数与绘制时间。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 常见面试题（二）]]></title>
    <link href="m78snail.com/14870442740078.html"/>
    <updated>2017-02-14T11:51:14+08:00</updated>
    <id>m78snail.com/14870442740078.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">9. Thread、AsycTask、IntentService的使用场景与特点</h2>

<p>Thread、AsyncTask和IntentService都与多线程有关，当我们在Android中涉及并发编程时（进行网络请求、加载较大的文件等操作）就需要使用。<br/>
<strong>Thread</strong><br/>
Java中的子线程，可以通过传入Runnable接口或继承Thread重写run方法新建。</p>

<p><strong>AsyncTask</strong><br/>
由Java线程池改造的异步任务工具</p>

<p><strong>IntentService</strong><br/>
Android四大组件之一的Service默认是在主线程中运行的，IntentService是Service的子类，有如下特点：<br/>
1. IntentService会创建单独的worker线程来处理所有的Intent请求<br/>
2. 当所有请求处理完成后，IntentService会自动停止<br/>
3. 为Service的onBind方法提供了默认实现，返回null<br/>
4. 为Service的onStartCommand方法提供了默认实现，把请求Intent添加到队列中<br/>
实现IntentService的例子如下：</p>

<pre><code>public class MyIntentService extends IntentService {  
      
    public MyIntentService(String name) {  
        super(name);  
    }  
  
    @Override  
    protected void onHandleIntent(Intent intent) {  
        // IntentService会创建单独的worker线程来处理此处的代码  
  
    }  
  
}  
</code></pre>

<p>我们只需重写onHandleIntent方法即可，该方法的代码会在一个子线程中运行。</p>

<h2 id="toc_1">10. 五种布局： FrameLayout 、 LinearLayout 、 AbsoluteLayout 、 RelativeLayout 、TableLayout 各自特点</h2>

<p><strong>FrameLayout</strong><br/>
FrameLayout即单帧布局，在该布局中的所有空间都会被置于布局的左上角。</p>

<p><strong>LinearLayout</strong><br/>
LinearLayout即线性布局，使用该布局必须为其指定orientation属性（排列方向属性，可以设置为水平或垂直的），其中的空间就会根据设置的属性呈水平或垂直排列。</p>

<p><strong>AbsoluteLayout</strong><br/>
AbsoluteLayout即绝对布局，对布局中的控件我们使用x，y坐标值进行定位。</p>

<p><strong>RelativeLayout</strong><br/>
RelativeLayout即相对布局，在其中的控件可以相对于父布局或布局中别的控件的位置进行定位布局。</p>

<p><strong>TableLayout</strong><br/>
TableLayout即表格布局，TableLayout中的每一行的控件由TableRow包含，最终的布局效果会呈现成表格状。</p>

<h2 id="toc_2">11. Android的数据存储形式</h2>

<p>在Android中的数据存储形式主要有以下几种：<br/>
<strong>SharedPreferrences</strong><br/>
SharedPreferrences主要用于存储一些少量的简单的应用程序配置信息。SharedPreferrences以明文键值对的形式把数据存储在一个xml文件上，该文件位于/data/data/<package name>/shared_prefs目录下。因此，SharedPreferrences只适合用于存储一些简单的数据，不适合存储复杂的或敏感的数据。</p>

<p><strong>File</strong><br/>
Android和Java一样，同样支持使用文件流来保存和访问文件。除了在手机内置存储空间上存储文件外，Android还支持读写SD卡上的文件：只要获取相应的权限后，调用Environment的getExternalStorageDirectory方法即可获取路径。</p>

<p><strong>SQLite数据库</strong><br/>
Android系统集成了一个轻量级的数据库：SQLite。SQLite是一个嵌入式数据库引擎，专门适用于资源有限的设备上适量数据的存取。在Android上我们一般使用SQLiteOpenHelper辅助类来操作SQLite数据库。</p>

<h2 id="toc_3">12. Sqlite的基本操作</h2>

<p>SQLite为熟悉SQL语句的程序员提供了相应的函数使用SQL语句，也为不了解SQL语法的程序员提供了简便的增删查改接口：</p>

<pre><code>String path = &quot;数据库路径&quot;;  
SQLiteDatabase database = SQLiteDatabase.openOrCreateDatabase(path, null);  
// 执行sql语句  
database.execSQL(sql);  
// 执行带占位符的sql语句  
database.execSQL(sql, bindArgs);  
// 执行查找的sql语句  
database.rawQuery(sql, selectionArgs);  
  
// 执行增删查改  
database.insert(table, nullColumnHack, values);  
database.delete(table, whereClause, whereArgs);  
database.query(table, columns, selection, selectionArgs, groupBy, having, orderBy);  
database.update(table, values, whereClause, whereArgs);  
  
// 开启事务  
database.beginTransaction();  
// 确认事务成功  
database.setTransactionSuccessful();  
// 结束事务  
database.endTransaction(); 
</code></pre>

<h2 id="toc_4">13. Android中的MVC模式</h2>

<p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。<br/>
MVC模式的示意图如下：<br/>
<img src="media/14870442740078/14870534341275.jpg" alt=""/></p>

<p>Android的设计也使用了MVC模式，其中：<br/>
1. View对应于Android的View控件和xml所编写的界面<br/>
2. Control对应于Android中的Activity，负责接收用户请求和改变模型状态<br/>
3. Model一般由我们自己实现来处理程序功能和逻辑</p>

<h2 id="toc_5">14. Merge、ViewStub的作用</h2>

<p>Merge和ViewStub均为Android中的xml优化标签，用于对Android的View布局进行优化。<br/>
Merge<br/>
merge标签应用于xml的顶层标签，主要应对于layout嵌套浪费的现象。在Android layout文件中需要一个顶级容器来容纳其他的组件，而不能直接放置多个组件，通过使用merge标签作为顶层容器，我们可以删减多余或者额外的层级，从而优化整个Android Layout的结构。</p>

<p>以下是一个例子：<br/>
activity_merge_test.xml：</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot; &gt;  
      
    &lt;TextView   
        android:id=&quot;@+id/text_view&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;match_parent&quot;  
        android:gravity=&quot;top|center_horizontal&quot;  
        android:text=&quot;text_view&quot;/&gt;  
  
    &lt;TextView   
        android:id=&quot;@+id/text_view_2&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;match_parent&quot;  
        android:gravity=&quot;bottom|center_horizontal&quot;  
        android:text=&quot;text_view_2&quot;/&gt;  
      
&lt;/FrameLayout&gt;  
</code></pre>

<p>MergeTestActivity：</p>

<pre><code>public class MergeTestActivity extends Activity {  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_merge_test);  
    }  
}  
</code></pre>

<p>效果图如下：</p>

<p><img src="media/14870442740078/14870535754556.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/><br/>
由hierarchyviewer分析可得（此处只分析与Activity界面相关的部分）：<br/>
<img src="media/14870442740078/14870536080097.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<p>由hierarchyviewer得到的View树状图我们可以发现，id为content的FrameLayout中只有LinearLayout一个元素，造成了layout的嵌套浪费（如红框圈出所示）。此处我们若使用merge标签，便可以减少一层layout标签的嵌套，使程序运行得更快更流畅。</p>

<p>xml代码改为如下：</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot; &gt;  
      
    &lt;TextView   
        android:id=&quot;@+id/text_view&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;match_parent&quot;  
        android:gravity=&quot;top|center_horizontal&quot;  
        android:text=&quot;text_view&quot;/&gt;  
  
    &lt;TextView   
        android:id=&quot;@+id/text_view_2&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;match_parent&quot;  
        android:gravity=&quot;bottom|center_horizontal&quot;  
        android:text=&quot;text_view_2&quot;/&gt;  
      
&lt;/merge&gt;  
</code></pre>

<p>效果图没有变化，使用hierarchyviewer分析可得：<br/>
<img src="media/14870442740078/14870536547753.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<p>此时已经减少了一层layout嵌套，我们通过使用merge标签，达到了优化的目的。</p>

<p><strong>ViewStub</strong><br/>
ViewStub即占位符，用于处理动态觉得显示某个View的情况。在开发应用程序的时候，我们经常会在运行时动态根据条件来决定显示哪个View或某个布局。那么最通常的想法就是把可能用到的View都写在上面，先把它们的可见性都设为View.GONE，然后在代码中动态的更改它的可见性。这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点就是，耗费资源。虽然把View的初始可见View.GONE但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。而使用ViewStub的话在inflate布局的时候不会被inflate，ViewStub的inflate操作被延迟到了直到我们调用其inflate方法。</p>

<p>ViewStub的xml文件设置如下：</p>

<pre><code>&lt;ViewStub  
    android:id=&quot;@+id/view_stub&quot;  
    android:inflatedId=&quot;@+id/my_view&quot;  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:layout=&quot;@layout/view_view_stub&quot; /&gt;  
</code></pre>

<p>其中，inflateId属性表示ViewStub被inflate后重新被赋予的id值，layout属性指定了调用inflate方法时inflate的具体布局。</p>

<p>找到ViewStub并调用inflate：</p>

<pre><code>ViewStub viewStub = (ViewStub)findViewById(R.id.view_stub);  
viewStub.inflate();  
</code></pre>

<p>值得注意的是：<br/>
　　1. ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不会够再通过ViewStub来控制它了。<br/>
　　2. ViewStub只能用来Inflate一个布局文件，而不是某个具体的View。</p>

<h2 id="toc_6">15. Json有什么优劣势</h2>

<p>JSON，即JavaScript Object Notation，是 一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。业内主流技术为其提供了完整的解决方案（有点类似于正则表达式 ，获得了当今大部分语言的支持），从而可以在不同平台间进行数据交换。JSON采用兼容性很高的文本格式，同时也具备类似于C语言体系的行为。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。</p>

<p>Json优点：<br/>
与传统的xml相比，Json有一下优点：</p>

<p>　　1. 在解码难度方面，XML的解析得考虑子节点父节点，而Json不需要，解析难度较低<br/>
　　2. Json数据的体积小<br/>
　　3. Json的传输速度快于XML<br/>
但Json也有它不足之处：<br/>
　　1. 没有XML格式这么推广的深入人心和使用广泛, 没有XML那么通用性<br/>
　　2. 命名空间允许不同上下文中的相同的信息段彼此混合，然而在Json中已经找不到了命名空间</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 常见面试题（一）]]></title>
    <link href="m78snail.com/14870412116317.html"/>
    <updated>2017-02-14T11:00:11+08:00</updated>
    <id>m78snail.com/14870412116317.html</id>
    <content type="html"><![CDATA[
<p>　　Android的话，多是一些项目中的实践，使用多了，自然就知道了，还有就是多逛逛一些名人的博客，书上能讲到的东西不多。另外android底层的东西，有时间的话可以多了解一下，加分项。推荐书籍：《疯狂android讲义》《深入理解android》其他综合性的书籍也需要阅读，推荐：《程序员面试笔试宝典》《程序员面试金典》。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">1. Activity与Fragment的生命周期</h2>

<h3 id="toc_1">（1）Activity的生命周期如下图所示：</h3>

<p><img src="media/14870412116317/14870420474230.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_2">（2）Fragment生命周期如下图所示：</h3>

<p><img src="media/14870412116317/14870420815631.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_3">2. Acitivty的四种启动模式与特点</h2>

<p>　　Android中的Activity由任务栈管理，当我们start一个新的Activity时，就往任务栈中新加入一个栈帧，而当我们finish一个Activity界面时，则往任务栈中移除一个栈帧。Activity具有四种启动模式，我们可以在配置文件中通过修改launchMode修改，启动模式分别是：standard、singleTop、singleTask和singleInstance<br/>
<strong>standard</strong><br/>
standard为默认Activity的启动模式。在standard启动模式下，无论何时start一个Activity，系统都会往任务栈中加入一个新的栈帧。</p>

<p><strong>singleTop</strong><br/>
在singleTop启动模式下，当我们start一个Activity时，系统会先去检测任务栈栈顶的Activity和要启动t的Activity是否相同。如果相同则不进行任何操作，否则往任务栈中加入一个新的栈帧。</p>

<p><strong>singleTask</strong><br/>
在singleTask启动模式下，当我们start一个Activity时，系统会先去检测任务栈中是否含有将要启动的Activity。如果含有，则把该Activity所在栈帧的顶部的栈帧移除，使该Activity所在的栈帧处在栈顶，如果没有，则新加入一个栈帧。</p>

<p><strong>singleInstance</strong><br/>
在singleInstance启动模式下，当我们start一个新的Activity时，该Activity会在一个新的任务栈中启动。</p>

<h2 id="toc_4">4. Service的生命周期，两种启动方法，有什么区别</h2>

<p>　　Android中的Service组件可以通过startService和bindService两种方法来启动，其生命周期示意图如下：<br/>
<img src="media/14870412116317/14870427132798.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<p>如果一个Service同时被调用了startService和bindService方法，那么它的生命周期就变成如下图所示：<br/>
<img src="media/14870412116317/14870427394623.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_5">5. 怎么保证service不被杀死</h2>

<p>　　要想使Service存活下来，我们就必须保证Service所在的进程不被杀掉，一般来说有以下方法：<br/>
1. 在onStartCommand回调方法中返回START_STICKY，那么该进程被杀掉后系统会试图重启它<br/>
2. 设置配置文件中application的persistent属性，把应用提升为系统级别应用，免疫low memory killer<br/>
3. 在Service的onDestroy方法中重启该Service，不过如果进程被直接杀掉这种方法就无效了<br/>
4. 通过监听特殊的系统广播（如屏幕变化、电量变化、网络变化等）去不断重启Service<br/>
5. 使用AlarmManager定时重复开启Service<br/>
6. 通过设置Service的process属性，把Service放在子进程中，避免与主进程一起被回收<br/>
7. 开启一个另外的进程与Service进程互相监视，双方要是有任意一方被杀掉则重启</p>

<h2 id="toc_6">6. 广播的两种注册方法，有什么区别</h2>

<p>Android四大组件之一的broadcast（广播）拥有两种不同的注册方法：静态注册与动态注册<br/>
<strong>静态注册</strong><br/>
广播静态注册指把广播相应的信息写在AndroidManifest.xml中，例子如下：</p>

<pre><code>&lt;receiver android:name=&quot;.StaticReceiver&quot;&gt;    
   &lt;intent-filter&gt;    
      &lt;action android:name=&quot;XXX&quot; /&gt;   
   &lt;/intent-filter&gt;    
&lt;/receiver&gt;  
</code></pre>

<p>静态广播的好处在于：不需程序启动即可接收，可用作自动启动程序<br/>
<strong>动态注册</strong><br/>
广播动态注册指在程序中调用registerReceiver方法来注册广播，例子如下：</p>

<pre><code>IntentFilter filter = new IntentFilter();  
filter.addAction(&quot;XXX&quot;);  
DynamicReceiver receiver = new DynamicReceiver();  
registerReceiver(receiver,  filter);  
// 不使用后记得取消注册  
unregisterReceiver(receiver);  
</code></pre>

<p>动态广播的好处在于：程序适应系统变化做操作，但在程序运行状态才能接收到</p>

<h2 id="toc_7">7. Intent的使用方法，可以传递哪些数据类型</h2>

<p>Intent即意图，是Android中连接四大组件的枢纽，Android中的Activity、Service和BroadcastReceiver都依靠Intent来启动。<br/>
Intent对象的属性大致包含七种，分别是Component、Action、Category、Data、Type、Extra、Flag。<br/>
<strong>Component</strong><br/>
Component用于明确指定需要启动的目标组件，使用方法如下：</p>

<pre><code>Intent intent = new Intent();  
// 方法一：传入上下文参数与class参数  
intent.setComponent(new ComponentName(context, XXX.class));  
// 方法二：传入包名与类名  
intent.setComponent(new ComponentName(pkg, cls));  
</code></pre>

<p>指定Component属性的Intent已经明确了它将要启动的组件，因此这种Intent也被称为显示Intent，没有指定Component属性的Intent被称为隐试Intent。<br/>
<strong>Action、Category</strong><br/>
Action代表Intent所要完成的一个抽象“动作”，而Category则用于为Action增加额外的附加类别信息，它们的使用方法如下:</p>

<pre><code>Intent intent = new Intent();  
// 设置一个字符串代表Action  
intent.setAction(action);  
// 添加一个字符串代表category  
intent.addCategory(category1);  
intent.addCategory(category2);  
</code></pre>

<p>值得注意的是Action属性是唯一的，但Category属性可以有多个。通常设置了Action和Category来启动组件的Intent就不指定Component属性了，因此这种Intent被称为隐试Intent。</p>

<p><strong>Data、Type</strong><br/>
Data属性接受一个Uri对象，Data属性通常用于向Action属性提供操作的数据。Type属性用于指定该Data属性所指定Uri对应的MIME类型。它们的使用方法如下：</p>

<pre><code>Intent intent = new Intent();  
// 设置Data属性  
intent.setData(new Uri());  
// 设置Type属性  
intent.setType(type);  
// 同时设置Data和Type属性  
intent.setDataAndType(data, type);  
</code></pre>

<p>值得注意的是Data属性和Type属性会互相覆盖，如果需要同时设置Data属性和Type属性需要使用setDataAndType。<br/>
<strong>Extra</strong><br/>
Intent的Extra属性用于进行数据交换，Intent的Extra属性值应该是一个Bundle对象（一个类似Map的对象，可以存入多个键值对，但存入的对象必须是基本类型或可序列化的），用法如下：</p>

<pre><code>Intent intent = new Intent();  
// 直接往Intent添加基本类型，在方法内也是把数据存入Bundle  
// 该方法有多种重载  
intent.putExtra(name, value);  
// 新建Bundle  
Bundle bundle = new Bundle();  
// 往Bundle添加数据，XXX为基本类型  
bundle.putXXX(key, value);  
bundle.putXXXArray(key, value);  
// 把Bundle添加进Intent  
intent.putExtras(bundle);  
</code></pre>

<p><strong>Flag</strong><br/>
Intent的Flag属性用于为该Intent添加一些额外的控制旗标，Intent可调用addFlags方法来添加控制旗标。</p>

<h2 id="toc_8">8.ContentProvider使用方法</h2>

<p>为了在应用程序之间交换数据，Android提供了ContentProvider。当一个应用程序需要把自己的数据暴露给其他程序使用时，该应用程序就可以通过ContentProvider来实现，而其他程序则使用ContentResolver来操作ContentProvider暴露的数据。<br/>
实现ContentProvider的Java代码如下：</p>

<pre><code>public class MyProvider extends ContentProvider {  
  
    @Override  
    public boolean onCreate() {  
        // 第一次创建时调用，如果创建成功则返回true  
        // 可以在这里打开数据库什么的  
        return true;  
    }  
  
    @Override  
    public String getType(Uri uri) {  
        // 返回ContentProvider所提供数据的MIME类型  
        return null;  
    }  
  
    @Override  
    public Cursor query(Uri uri, String[] projection, String selection,  
            String[] selectionArgs, String sortOrder) {  
        // 实现查询方法  
        return null;  
    }  
      
    @Override  
    public Uri insert(Uri uri, ContentValues values) {  
        // 实现插入方法，返回插入条数  
        return null;  
    }  
  
    @Override  
    public int delete(Uri uri, String selection, String[] selectionArgs) {  
        // 实现删除方法，返回删除条数  
        return 0;  
    }  
  
    @Override  
    public int update(Uri uri, ContentValues values, String selection,  
            String[] selectionArgs) {  
        // 实现更新方法，返回更新条数  
        return 0;  
    }  
  
}  
</code></pre>

<p>当我们实现了自己的ContentProvider后，还需要去AndroidManifest.xml中注册才行：</p>

<pre><code>&lt;provider   
    android:name=&quot;.MyProvider&quot;  
    android:authorities=&quot;com.example.test.provider&quot;  
    android:exported=&quot;true&quot; /&gt;  
</code></pre>

<p>配置ContentProvider时我们需要设置如下属性：</p>

<ul>
<li>name：类名</li>
<li>authorities：为ContentProvider指定一个对应的Uri，其他程序通过这个Uri来找到该ContentProvider</li>
<li>exported：允许ContentProvider被其他应用调用
当其他应用需要访问我们提供的ContentProvider的使用，只需使用ContentResolver并传入相应的Uri即可：</li>
</ul>

<pre><code>public class MyActivity extends Activity {  
  
    private static String TAG = &quot;MyActivity&quot;;  
      
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        ContentResolver resolver = getContentResolver();  
        // 传入对应的Uri进行增删查改操作  
        resolver.query(uri, projection, selection, selectionArgs, sortOrder);  
        resolver.insert(url, values);  
        resolver.delete(url, where, selectionArgs);  
        resolver.update(uri, values, where, selectionArgs);  
    }  
      
}  
</code></pre>

<p>除此之外，我们还可以使用ContentObserver来为ContentProvider添加观察者。我们在其他程序的ContentResolver中注册ContentObserver，当ContentProvider发生改变时，我们在数据改动的使用调用：</p>

<pre><code>getContext().getContentResolver().notifyChange(uri, null);  
</code></pre>

<p>那么此时ContentObserver中的onChange回调方法就会被调用，我们就可以简单地监听ContentProvider的数据改变了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP/IP 与 HTTP]]></title>
    <link href="m78snail.com/14869684713757.html"/>
    <updated>2017-02-13T14:47:51+08:00</updated>
    <id>m78snail.com/14869684713757.html</id>
    <content type="html"><![CDATA[
<p>　　网络其实大体分为两块，一个TCP协议，一个HTTP协议，只要把这两块以及相关协议搞清楚，一般问题不大。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">1、OSI与TCP/IP各层的结构与功能，都有哪些协议</h2>

<h3 id="toc_1">（1）OSI七层模型</h3>

<p>　　OSI中的层 功能 TCP/IP协议族 <br/>
应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet <br/>
　　表示层 数据格式化，代码转换，数据加密 没有协议 <br/>
　　会话层 解除或建立与别的接点的联系 没有协议 <br/>
　　传输层 提供端对端的接口 TCP，UDP <br/>
　　网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP <br/>
　　数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU <br/>
　　物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2</p>

<h3 id="toc_2">(2)TCP/IP五层模型的协议</h3>

<p>　　应用层 ,传输层 ,网络层 ,数据链路层 ,物理层</p>

<h2 id="toc_3">2、TCP与UDP的区别</h2>

<p>　　1.基于连接与无连接； <br/>
　　2.对系统资源的要求（TCP较多，UDP少）； <br/>
　　3.UDP程序结构较简单； <br/>
　　4.流模式与数据报模式 ； <br/>
　　5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。</p>

<h2 id="toc_4">3、TCP报文结构</h2>

<p>　　TCP的包头结构： <br/>
　　源端口 16位 <br/>
　　目标端口 16位 <br/>
　　序列号 32位 <br/>
　　回应序号 32位 <br/>
　　TCP头长度 4位 <br/>
　　reserved 6位 <br/>
　　控制代码 6位 <br/>
　　窗口大小 16位 <br/>
　　偏移量 16位 <br/>
　　校验和 16位 <br/>
　　选项 32位(可选) <br/>
　　这样我们得出了TCP<br/>
　　包头的最小长度，为20字节</p>

<h2 id="toc_5">4、TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用</h2>

<h3 id="toc_6">(1) TCP三次握手过程</h3>

<p>　　1. 主机A通过向主机B发送一个含有同步序列号的标志位的数据段给主机B,向主机B请求建立连接，通过这个数据段，主机A高速主机B两件事:我想要和你通信；你可以用那个序列号作为起始数据段来回应我。<br/>
　　2. 主机B收到主机A的请求后，用一个带有确认应答的(ACK)和同步序列(SYN)标志位的数据段响应主机A,也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我。<br/>
　　3. 主机A收到这个数据段后，再发送一个确认应答(ACK),确认已收到主机B的数据段：我已收到回复,我现在要开始传输实际数据了 这样3次握手就完成了,主机A和主机B 就可以传输数据了。  </p>

<h3 id="toc_7">(2) 3次握手的特点</h3>

<p>没有应用层的数据 <br/>
　　SYN这个标志位只有在TCP建产连接时才会被置1 <br/>
　　握手完成后SYN标志位被置0</p>

<h3 id="toc_8">(3) TCP建立连接要进行3次握手,而断开连接要进行4次</h3>

<p>　　1. 当主机A完成传输后，将控制位FIN置1，提出停止TCP连接的请求。<br/>
　　2. 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭，将ACK置1<br/>
　　3. 由B端再提出反方向的关闭请求，将FIN置1 <br/>
　　4. 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束。 <br/>
　　由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端 和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础。</p>

<h3 id="toc_9">(4) 名词解释</h3>

<p>　　ACK：TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段 都收到了.比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK=1时,确认号才有效,当ACK=0时,确认号无效,这时会要求重传数据,保证数据的完整性。 <br/>
　　SYN：同步序列号,TCP建立连接时将这个位置1。 <br/>
　　FIN：发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1。</p>

<p>　　客户端与服务器端建立TCP/IP连接后关闭SOCKET后，服务器端连接的端口 状态为TIME_WAIT</p>

<h3 id="toc_10">(5) 是不是所有执行主动关闭的socket都会进入TIME_WAIT状态呢？</h3>

<p>　　有没有什么情况使主动关闭的socket直接进入CLOSED状态呢？</p>

<p>　　主动关闭的一方在发送最后一个ack 后 <br/>
就会进入TIME_WAIT 状态 停留2MSL（max segment lifetime）时间</p>

<p>　　这个是TCP/IP必不可少的，也就是“解决”不了的。 <br/>
　　也就是TCP/IP设计者本来是这么设计的</p>

<p>　　主要有两个原因 <br/>
　　<1>.防止上一次连接中的包，迷路后重新出现，影响新连接 <br/>
（经过2MSL，上一次连接中所有的重复包都会消失）</p>

<p>　　<2>.可靠的关闭TCP连接<br/>
　　在主动关闭方发送的最后一个ACK(fin),有可能丢失,这时被动方会重新发fin,如果这时主动方处于CLOSED状态,就会响应rst而不是ACK。所以主动方要处于TIME_WAIT状态，而不能是CLOSED。TIME_WAIT并不会占用很大资源，除非受到攻击。还有，如果任何一方send或recv超时，就会直接进入CLOSED状态。<br/>
　　<br/>
　　<img src="media/14869684713757/14869705283677.jpg" alt=""/></p>

<h2 id="toc_11">5、TCP拥塞控制</h2>

<p>　　<1>.慢开始与拥塞避免<br/>
　　<2>.快重传和快恢复<br/>
　　<3>.随机早期检测RED</p>

<h3 id="toc_12">1.慢开始与拥塞避免</h3>

<p>　　发送报文段速率的确定，既要根据接收端的接收能力，又要从全局考虑不要使网络发生拥塞，这由接收窗口和拥塞窗口两个状态量确定。接收端窗口(Reciver Window)又称通知窗口(Advertised Window)，是接收端根据目前的接收缓存大小所许诺的最新窗口值，是来自接收端的流量控制。拥塞窗口(Congestion Window)是发送端根据自己估计的网络拥塞程度而设置的窗口值，是来自发送端的流量控制。</p>

<h4 id="toc_13">慢启动原理：</h4>

<p>　　<1>. 当主机开始发送数据时，如果立即将较大的发送窗口的全部数据字节都注入到网络中，那么由于不清楚网络的情况，有可能引起网络拥塞。<br/>
　　<2>. 比较好的方法是试探一下，即从小到大逐渐增大发送端的拥塞控制窗口数值。<br/>
　　<3>. 通常在刚刚开始发送报文段时可先将拥塞窗口cwnd设置为一个最大报文段的MSS的数值。在每收到一个对新报文段确认后，将拥塞窗口增加至多一个MSS的数值,当rwind足够大的时候，为了防止拥塞窗口cwind的增长引起网络拥塞，还需要另外一个变量-慢开始门限ssthresh。</p>

<h4 id="toc_14">拥塞控制具体过程为：</h4>

<p>　　<1>. TCP连接初始化，将拥塞窗口设置为1<br/>
　　<2>. 执行慢开始算法，cwind按指数规律增长，直到cwind==ssthress开始执行拥塞避免算法，cwnd按线性规律增长<br/>
　　<3>. 当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwnd重新设置为1，按照步骤<2>执行。</p>

<h3 id="toc_15">2. 快重传和快恢复</h3>

<p>　　一条TCP连接有时会因等待重传计时器的超时而空闲较长的时间，慢开始和拥塞避免无法很好的解决这类问题，因此提出了快重传和快恢复的拥塞控制方法。<br/>
　　快重传算法并非取消了重传机制，只是在某些情况下更早的重传丢失的报文段(如果当发送端接收到三个重复的确认ACK时，则断定分组丢失，立即重传丢失的报文段，而不必等待重传计时器超时)。慢开始算法只是在TCP建立时才使用。</p>

<h4 id="toc_16">快恢复算法有以下两个要点：</h4>

<p>　　<1>. 当发送方连续接收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半，这是为了预防网络发生拥塞。<br/>
　　<2>. 由于发送发现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是把cwnd值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法，使拥塞窗口的线性增大。　　</p>

<h2 id="toc_17">6、TCP滑动窗口与回退N针协议</h2>

<p>　　只有在接收窗口向前滑动时(与此同时也发送了确认)，发送窗口才有可能向前滑动。收发两端的窗口按照以上规律不断地向前滑动，因此这种协议又称为滑动窗口协议。<br/>
　　当发送窗口和接收窗口的大小都等于1时，就是停止等待协议。<br/>
　　当发送窗口大于1，接收窗口等于1时，就是回退N步协议。<br/>
　　当发送窗口和接收窗口的大小均大于1时，就是选择重发协议。<br/>
　　协议中规定，对于窗口内未经确认的分组需要重传。这种分组的数量最多可以等于发送窗口的大小，即滑动窗口的大小n减去1(因为发送窗口不可能大于(n-1),起码接收窗口要大于等于1)。</p>

<h2 id="toc_18">7、Http的报文结构</h2>

<p>　　HTTP请求报文由3部分组成(请求行+请求头+请求体)<br/>
　　<img src="media/14869684713757/14869767849546.jpg" alt=""/><br/>
<img src="media/14869684713757/14869768085539.jpg" alt=""/></p>

<h3 id="toc_19">请求例子</h3>

<p>POST　　/meme.php/login　　HTTP/1.1<br/>
HOST:114.215.86.90<br/>
Cache-Control:no-cache</p>

<p>tel=13637 &amp; password=123456</p>

<h3 id="toc_20">响应例子</h3>

<p>HTTP/1.1　　200　　OK<br/>
Date:Sat</p>

<p>{&quot;status&quot;:202}</p>

<h2 id="toc_21">8、Http的状态码含义</h2>

<p>　　响应码由三位十进制数字组成，它们出现在<br/>
　　响应码分为五种类型，由它们的第一位数字表示：<br/>
　　1.1xx:信息，请求收到，继续处理<br/>
　　2.2xx：成功，行为被成功地接受,理解和采纳<br/>
　　3.3xx：重定向，为了完成请求，必须进一步执行的动作<br/>
　　4.4xx：客户端错误，请求包含语法错误或者请求无法实现<br/>
　　5.5xx：服务器错误，服务器不能实现一种明显无效的请求</p>

<h2 id="toc_22">9、Http1.1和Http1.0的区别</h2>

<p>　　<1>. HTTP/1.0协议使用非持久连接，即在非持久连接下，一个TCP连接只传输一个Web对象；<br/>
　　<2>. HTTP/1.1默认使用持久连接(可以配置成非持久连接)。在持久连接下，不必为每个Web对象的传送建立一个新的连接，一个连接中可以传输多个对象！</p>

<h2 id="toc_23">10、电脑上访问一个网页，整个过程是怎么样的</h2>

<h3 id="toc_24"><1>连接</h3>

<p>　　当我们输入这样一个请求时，首先要建立一个socket连接，因为socket是通过ip和端口建立的，所以之前还有一个DNS解析过程，把<a href="http://www.mytest.com/%E5%8F%98%E6%88%90ip%EF%BC%8C%E5%A6%82%E6%9E%9Curl%E9%87%8C%E4%B8%8D%E5%8C%85%E5%90%AB%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%8C%E5%88%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E8%AF%A5%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7%E3%80%82">http://www.mytest.com/变成ip，如果url里不包含端口号，则会使用该协议的默认端口号。</a> DNS的过程是这样的：首先我们知道我们本地的机器上在配置网络时都会填写DNS，这样本机就会把这个url发给这个配置的DNS服务器，如果能够找到相应的url则返回其ip，否则该DNS将继续将该解析请求发送给上级DNS，整个DNS可以看做是一个树状结构，该请求将一直发送到根直到得到结果。现在已经拥有了目标ip和端口号，这样我们就可以打开socket连接了。</p>

<h3 id="toc_25"><2>请求</h3>

<p>　　连接成功建立后，开始向web服务器发送请求，这个请求一般是GET或POST命令（POST用于FORM参数的传递）。GET命令的格式为：　　GET 路径/文件名 HTTP/1.0 文件名指出所访问的文件，HTTP/1.0指出Web浏览器使用的HTTP版本。现在可以发送GET命令： <br/>
GET /mytest/index.html HTTP/1.0，µ</p>

<h3 id="toc_26"><3>应答</h3>

<p>　　Web服务器收到这个请求，进行处理。从它的文档空间中搜索子目录mytest的文件index.html。如果找到该文件，Web服务器把该文件内容传送给相应的Web浏览器。<br/>
　　为了告知浏览器，，Web服务器首先传送一些HTTP头信息，然后传送具体内容（即HTTP体信息），HTTP头信息和HTTP体信息之间用一个空行分开。<br/>
　　常用的HTTP头信息有：<br/>
　　　　① HTTP 1.0 200 OK 　这是Web服务器应答的第一行，列出服务器正在运行的HTTP版本号和应答代码。代码”200 OK”表示请求完成。<br/>
　　　　② MIME_Version:1.0　它指示MIME类型的版本。<br/>
　　　　③ content_type:类型　这个头信息非常重要，它指示HTTP体信息的MIME类型。如：content_type:text/html指示传送的数据是HTML文档。<br/>
　　　　④ content_length:长度值　它指示HTTP体信息的长度（字节）。</p>

<h3 id="toc_27"><4>关闭连接</h3>

<p>　　当应答结束后，Web浏览器与Web服务器必须断开，以保证其它Web浏览器能够与Web服务器建立连接。</p>

<h2 id="toc_28">11、Ping的整个过程。ICMP报文是什么</h2>

<p>　　在了解ping命令之前，我们首先需要了解一下ICMP协议，即：网络控制消息协议（Internet Control Message Protocol）。<br/>
　　ICMP是TCP/IP协议族的一个子协议，工作在网络互联层（网络层）。ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>

<h3 id="toc_29">ping某个域名的整个过程</h3>

<p>　　ICMP的一个重要应用就是分组网间探测PING（Packe InterNet Groper），用来测试主机之间的连通性。PING使用了ICMP回送请求与回送回答报文。PING是应用层直接使用网络层ICMP的一个例子，没有经过传输层的TCP或UDP。<br/>
<img src="media/14869684713757/14869789657922.jpg" alt=""/></p>

<h2 id="toc_30">12、IP地址分类</h2>

<p>　　最初设计互联网络时，为了便于寻址以及层次化构造网络，每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。IP地址根据网络ID的不同分为5种类型，A类地址、B类地址、C类地址、D类地址和E类地址。</p>

<h3 id="toc_31">1． A类IP地址</h3>

<p>　　一个A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”， 地址范围从1.0.0.0 到126.0.0.0。可用的A类网络有126个，每个网络能容纳1亿多个主机。</p>

<h3 id="toc_32">2． B类IP地址</h3>

<p>　　一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255。可用的B类网络有16382个，每个网络能容纳6万多个主机 。</p>

<h3 id="toc_33">3． C类IP地址</h3>

<p>　　一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围从192.0.0.0到223.255.255.255。C类网络可达209万余个，每个网络能容纳254个主机。</p>

<h3 id="toc_34">4． D类地址用于多点广播（Multicast）</h3>

<p>　　D类IP地址第一个字节以“lll0”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。</p>

<h3 id="toc_35">5． E类IP地址</h3>

<p>　　以“llll0”开始，为将来使用保留。</p>

<p>全零（“0．0．0．0”）地址对应于当前主机。全“1”的IP地址（“255．255．255．255”）是当前子网的广播地址。</p>

<p>在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下：</p>

<p>A类地址：10.0.0.0～10.255.255.255</p>

<p>B类地址：172.16.0.0～172.31.255.255</p>

<p>C类地址：192.168.0.0～192.168.255.255</p>

<p>A类地址的第一组数字为1～126。注意，数字0和 127不作为A类地址，数字127保留给内部回送函数，而数字0则表示该地址是本地宿主机，不能传送。</p>

<p>B类地址的第一组数字为128～191。</p>

<p>C类地址的第一组数字为192～223。</p>

<h2 id="toc_36">13、路由器和交换机的区别</h2>

<p>　　路由器和交换机，二者区别如下：<br/>
　　1，路由器工作于OSI模型的网络层，能够识别IP地址，并根据IP地址转发数据包，并维护着路由表，能够基于路由表进行最佳路线选择； <br/>
　　2，路由器上还能开启ACL访问控制列表、NAT地址转换等功能，扩展网络应用,； <br/>
　　3，传统交换机工作于OSI模型的数据链路层，能够识别MAC地址，根据MAC地址转发数据帧，并维护着一张桥表，根据桥表上MAC地址和端口的对应关系进行数据帧转发。 <br/>
　　4，交换机能够隔离冲突域，并划分VLAN。</p>

<h2 id="toc_37">14、为什么需要3次握手与4次握手</h2>

<p>　　在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。这两种不用的表述其实阐明的是同一个问题。</p>

<p>为什么需要“四次挥手” <br/>
　　那可能有人会有疑问，在tcp连接握手时为何ACK是和SYN一起发送，这里ACK却没有和FIN一起发送呢。原因是因为tcp是全双工模式，接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Https完全解析 与 okHttp的结合]]></title>
    <link href="m78snail.com/14829144540758.html"/>
    <updated>2016-12-28T16:40:54+08:00</updated>
    <id>m78snail.com/14829144540758.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">一、概述</h2>

<p>　　首先要了解的事，okhttp默认情况下是支持https协议的网站的，比如<br/>
<a href="https://www.baidu.com">https://www.baidu.com</a> <a href="https://github.com/hongyangAndroid/okhttp-utils">https://github.com/hongyangAndroid/okhttp-utils</a> 等， 你可以直接通过okhttp请求试试。不过要注意的是，支持的https的网站基本都是CA机构颁发的证书，默认情况下是可以信任的。</p>

<span id="more"></span><!-- more -->

<p>　　当然我们今天要说的是自签名的网站，什么叫自签名呢？就是自己通过keytool去生成一个证书，然后使用，并不是CA机构去颁发的。使用自签名证书的网站，大家在使用浏览器访问的时候，一般都是报风险警告，好在有个大名鼎鼎的网站就是这么干的，<a href="https://kyfw.12306.cn/otn/%EF%BC%8C">https://kyfw.12306.cn/otn/，</a> 点击进入12306的购票页面就能看到了。<br/>
　　如下界面：<br/>
　　<img src="media/14812722672589/14812727587733.jpg" alt=""/></p>

<p>　　大家可以尝试拿okhttp访问下:</p>

<pre><code>OkHttpClientManager.getAsyn
    (&quot;https://kyfw.12306.cn/otn/&quot;, callack);    
</code></pre>

<p>　　好了，本篇博文当然不是去说如何去访问12306，而是以12306为例子来说明如何去访问自签名证书的网站。因为部分开发者app与自己服务端交互的时候可能也会遇到自签名证书的。甚至在开发安全级别很高的app时，需要用到双向证书的验证。</p>

<p>那么本篇博文的基本内容包含：</p>

<ul>
<li>https一些相关的知识</li>
<li>okhttp访问自签名https网站</li>
<li>如何构建一个支持https的服务器（这里主要为了测试多个证书的时候，如何去加载）</li>
<li>如何进行双向证书验证</li>
</ul>

<h2 id="toc_1">二、Https相关知识</h2>

<p>　　关于特别理论的东西大家可以百度下自己去了解下，这里就简单说一下，HTTPS相当于HTTP的安全版本了，为什么安全呢？</p>

<p>　　因为它在HTTP的之下加入了SSL (Secure Socket Layer)，安全的基础就靠这个SSL了。SSL位于TCP/IP和HTTP协议之间，那么它到底能干嘛呢？<br/>
它能够：</p>

<ul>
<li> 认证用户和服务器，确保数据发送到正确的客户机和服务器；(验证证书)</li>
<li>加密数据以防止数据中途被窃取；（加密）</li>
<li>维护数据的完整性，确保数据在传输过程中不被改变。（摘要算法）</li>
</ul>

<p>　　下面我们简单描述下HTTPS的工作原理，大家就能对应的看到上面3条作用的身影了：<br/>
　　HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。握手过程的简单描述如下：<br/>
　　1. 浏览器将自己支持的一套加密算法、HASH算法发送给网站。<br/>
　　2.网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。<br/>
　　3. 浏览器获得网站证书之后，开始验证证书的合法性，如果证书信任，则生成一串随机数字作为通讯过程中对称加密的秘钥。然后取出证书中的公钥，将这串数字以及HASH的结果进行加密，然后发给网站。<br/>
　　4. 网站接收浏览器发来的数据之后，通过私钥进行解密，然后HASH校验，如果一致，则使用浏览器发来的数字串使加密一段握手消息发给浏览器。<br/>
　　5. 浏览器解密，并HASH校验，没有问题，则握手结束。接下来的传输过程将由之前浏览器生成的随机密码并利用对称加密算法进行加密。 <br/>
　　<br/>
　　握手过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私信息的传输。<br/>
　　根据上面的流程，我们可以看到服务器端会有一个证书，在交互过程中客户端需要去验证证书的合法性，对于权威机构颁发的证书当然我们会直接认为合法。对于自己造的证书，那么我们就需要去校验合法性了，也就是说我们只需要让OkhttpClient去信任这个证书就可以畅通的进行通信了。</p>

<p>　　当然，对于自签名的网站的访问，网上的部分的做法是直接设置信任所有的证书，对于这种做法肯定是有风险的，所以这里我们不去介绍了，有需要自己去查。</p>

<p>　　下面我们去考虑，如何让OkHttpClient去信任我们的证书，接下里的例子就是靠12306这个福利站点了。</p>

<p>　　首先导出12306的证书，这里12306提供了下载地址：<a href="https://kyfw.12306.cn/otn/">12306证书点击下载</a></p>

<p>　　下载完成，解压拿到里面的srca.cer，一会需要使用。ps:即使没有提供下载，也可以通过浏览器导出的，自行百度。</p>

<h2 id="toc_2">三、代码</h2>

<h3 id="toc_3">（一）、访问自签名的网站</h3>

<p>　　首先把我们下载的srca.cer放到assets文件夹下，其实你可以随便放哪，反正能读取到就行。</p>

<p>　　然后在我们的OkHttpClientManager里面添加如下的方法：</p>

<pre><code>
public void setCertificates(InputStream... certificates)
{
    try
    {
        CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);
        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
        keyStore.load(null);
        int index = 0;
        for (InputStream certificate : certificates)
        {
            String certificateAlias = Integer.toString(index++);
            keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate(certificate));

            try
            {
                if (certificate != null)
                    certificate.close();
            } catch (IOException e)
            {
            }
        }

        SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);

        TrustManagerFactory trustManagerFactory = 
            TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); 

        trustManagerFactory.init(keyStore);
        sslContext.init
            (   
                null, 
                trustManagerFactory.getTrustManagers(), 
                new SecureRandom()
            );
       mOkHttpClient.setSslSocketFactory(sslContext.getSocketFactory());


    } catch (Exception e)
    {
        e.printStackTrace();
    } 

}
</code></pre>

<p>　　为了代码可读性，我把异常捕获的部分简化了，可以看到我们提供了一个方法传入InputStream流，InputStream就对应于我们证书的输入流。<br/>
　　代码内部，我们：<br/>
　　　　</p>

<ul>
<li><p>构造CertificateFactory对象，通过它的generateCertificate(is)方法得到Certificate。</p></li>
<li><p>然后讲得到的Certificate放入到keyStore中。</p></li>
<li><p>接下来利用keyStore去初始化我们的TrustManagerFactory</p></li>
<li><p>由trustManagerFactory.getTrustManagers获得TrustManager[]初始化我们的SSLContext</p></li>
<li><p>最后，设置我们mOkHttpClient.setSslSocketFactory即可。</p></li>
</ul>

<p>　　这样就完成了我们代码的编写，其实挺短的，当客户端进行SSL连接时，就可以根据我们设置的证书去决定是否信任服务端的证书。</p>

<p>　　记得在Application中进行初始化：<br/>
　　</p>

<pre><code>
public class MyApplication extends Application
{
   @Override
    public void onCreate()
    {
        super.onCreate();

        try
        {
            OkHttpClientManager.getInstance()
                    .setCertificates(getAssets().open(&quot;srca.cer&quot;));
        } catch (IOException e)
        {
            e.printStackTrace();
        }


}
</code></pre>

<p>　　到这就可以看到使用Okhttp可以很方便的应对自签名的网站的访问，只需要拿到包含公钥的证书即可。</p>

<h3 id="toc_4">（二）、使用字符串替代证书</h3>

<pre><code>zhydeMacBook-Pro:temp zhy$ keytool -printcert -rfc -file srca.cer
-----BEGIN CERTIFICATE-----
MIICmjCCAgOgAwIBAgIIbyZr5/jKH6QwDQYJKoZIhvcNAQEFBQAwRzELMAkGA1UEBhMCQ04xKTAn
BgNVBAoTIFNpbm9yYWlsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MQ0wCwYDVQQDEwRTUkNBMB4X
DTA5MDUyNTA2NTYwMFoXDTI5MDUyMDA2NTYwMFowRzELMAkGA1UEBhMCQ04xKTAnBgNVBAoTIFNp
bm9yYWlsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MQ0wCwYDVQQDEwRTUkNBMIGfMA0GCSqGSIb3
DQEBAQUAA4GNADCBiQKBgQDMpbNeb34p0GvLkZ6t72/OOba4mX2K/eZRWFfnuk8e5jKDH+9BgCb2
9bSotqPqTbxXWPxIOz8EjyUO3bfR5pQ8ovNTOlks2rS5BdMhoi4sUjCKi5ELiqtyww/XgY5iFqv6
D4Pw9QvOUcdRVSbPWo1DwMmH75It6pk/rARIFHEjWwIDAQABo4GOMIGLMB8GA1UdIwQYMBaAFHle
tne34lKDQ+3HUYhMY4UsAENYMAwGA1UdEwQFMAMBAf8wLgYDVR0fBCcwJTAjoCGgH4YdaHR0cDov
LzE5Mi4xNjguOS4xNDkvY3JsMS5jcmwwCwYDVR0PBAQDAgH+MB0GA1UdDgQWBBR5XrZ3t+JSg0Pt
x1GITGOFLABDWDANBgkqhkiG9w0BAQUFAAOBgQDGrAm2U/of1LbOnG2bnnQtgcVaBXiVJF8LKPaV
23XQ96HU8xfgSZMJS6U00WHAI7zp0q208RSUft9wDq9ee///VOhzR6Tebg9QfyPSohkBrhXQenvQ
og555S+C3eJAAVeNCTeMS3N/M5hzBRJAoffn3qoYdAO1Q8bTguOi+2849A==
-----END CERTIFICATE-----
</code></pre>

<p>　　使用keytool命令，以rfc样式输出。keytool命令是JDK里面自带的。</p>

<p>　　有了这个字符串以后，我们就不需要srca.cer这个文件了，直接编写以下代码：</p>

<pre><code>public class MyApplication extends Application
{
    private String CER_12306 = &quot;-----BEGIN CERTIFICATE-----\n&quot; +
            &quot;MIICmjCCAgOgAwIBAgIIbyZr5/jKH6QwDQYJKoZIhvcNAQEFBQAwRzELMAkGA1UEBhMCQ04xKTAn\n&quot; +
            &quot;BgNVBAoTIFNpbm9yYWlsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MQ0wCwYDVQQDEwRTUkNBMB4X\n&quot; +
            &quot;DTA5MDUyNTA2NTYwMFoXDTI5MDUyMDA2NTYwMFowRzELMAkGA1UEBhMCQ04xKTAnBgNVBAoTIFNp\n&quot; +
            &quot;bm9yYWlsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MQ0wCwYDVQQDEwRTUkNBMIGfMA0GCSqGSIb3\n&quot; +
            &quot;DQEBAQUAA4GNADCBiQKBgQDMpbNeb34p0GvLkZ6t72/OOba4mX2K/eZRWFfnuk8e5jKDH+9BgCb2\n&quot; +
            &quot;9bSotqPqTbxXWPxIOz8EjyUO3bfR5pQ8ovNTOlks2rS5BdMhoi4sUjCKi5ELiqtyww/XgY5iFqv6\n&quot; +
            &quot;D4Pw9QvOUcdRVSbPWo1DwMmH75It6pk/rARIFHEjWwIDAQABo4GOMIGLMB8GA1UdIwQYMBaAFHle\n&quot; +
            &quot;tne34lKDQ+3HUYhMY4UsAENYMAwGA1UdEwQFMAMBAf8wLgYDVR0fBCcwJTAjoCGgH4YdaHR0cDov\n&quot; +
            &quot;LzE5Mi4xNjguOS4xNDkvY3JsMS5jcmwwCwYDVR0PBAQDAgH+MB0GA1UdDgQWBBR5XrZ3t+JSg0Pt\n&quot; +
            &quot;x1GITGOFLABDWDANBgkqhkiG9w0BAQUFAAOBgQDGrAm2U/of1LbOnG2bnnQtgcVaBXiVJF8LKPaV\n&quot; +
            &quot;23XQ96HU8xfgSZMJS6U00WHAI7zp0q208RSUft9wDq9ee///VOhzR6Tebg9QfyPSohkBrhXQenvQ\n&quot; +
            &quot;og555S+C3eJAAVeNCTeMS3N/M5hzBRJAoffn3qoYdAO1Q8bTguOi+2849A==\n&quot; +
            &quot;-----END CERTIFICATE-----&quot;;

    @Override
    public void onCreate()
    {
        super.onCreate();

        OkHttpClientManager.getInstance()
                .setCertificates(new Buffer()
                        .writeUtf8(CER_12306)
                        .inputStream());
}
</code></pre>

<h2 id="toc_5">四. tomcat下使用自签名证书部署服务</h2>

<h3 id="toc_6">（一）生成证书</h3>

<p>　　如何生成证书呢？使用keytool非常简单。</p>

<pre><code>zhydeMacBook-Pro:temp zhy$ keytool -genkey -alias zhy_server -keyalg RSA -keystore zhy_server.jks -validity 3600 -storepass 123456
您的名字与姓氏是什么?
  [Unknown]:  zhang
您的组织单位名称是什么?
  [Unknown]:  zhang
您的组织名称是什么?
  [Unknown]:  zhang
您所在的城市或区域名称是什么?
  [Unknown]:  xian
您所在的省/市/自治区名称是什么?
  [Unknown]:  shanxi
该单位的双字母国家/地区代码是什么?
  [Unknown]:  cn
CN=zhang, OU=zhang, O=zhang, L=xian, ST=shanxi, C=cn是否正确?
  [否]:  y

输入 &lt;zhy_server&gt; 的密钥口令
    (如果和密钥库口令相同, 按回车):   
</code></pre>

<p>　　使用以上命令即可生成一个证书请求文件zhy_server.jks，注意密钥库口令为：123456.</p>

<p>接下来利用zhy_server.jks来签发证书：</p>

<pre><code>zhydeMacBook-Pro:temp zhy$ keytool -export -alias zhy_server 
 -file zhy_server.cer 
 -keystore zhy_server.jks 
 -storepass 123456 
</code></pre>

<p>　　即可生成包含公钥的证书zhy_server.cer。</p>

<h3 id="toc_7">(二)、配置Tomcat</h3>

<p>　　找到tomcat/conf/sever.xml文件，并以文本形式打开。<br/>
在Service标签中，加入：</p>

<pre><code>&lt;Connector SSLEnabled=&quot;true&quot; acceptCount=&quot;100&quot; clientAuth=&quot;false&quot; 
    disableUploadTimeout=&quot;true&quot; enableLookups=&quot;true&quot; keystoreFile=&quot;&quot; keystorePass=&quot;123456&quot; maxSpareThreads=&quot;75&quot; 
    maxThreads=&quot;200&quot; minSpareThreads=&quot;5&quot; port=&quot;8443&quot; 
    protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; scheme=&quot;https&quot; 
    secure=&quot;true&quot; sslProtocol=&quot;TLS&quot;
    /&gt;
</code></pre>

<p>　　注意keystoreFile的值为我们刚才生成的jks文件的路径：/Users/zhy/ <br/>
temp/zhy_server.jks(填写你的路径).keystorePass值为密钥库密码:123456。</p>

<p>　　然后启动即可，对于命令行启动，依赖环境变量JAVA_HOME；如果在MyEclispe等IDE下启动就比较随意了。</p>

<p>　　启动成功以后，打开浏览器输入url:<a href="https://localhost:8443/%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E8%AF%81%E4%B9%A6%E4%B8%8D%E5%8F%AF%E4%BF%A1%E4%BB%BB%E7%9A%84%E8%AD%A6%E5%91%8A%E4%BA%86%E3%80%82%E9%80%89%E6%8B%A9%E6%89%93%E6%AD%BB%E4%B9%9F%E8%A6%81%E8%BF%9B%E5%85%A5%EF%BC%8C%E5%8D%B3%E5%8F%AF%E8%BF%9B%E5%85%A5tomcat%E9%BB%98%E8%AE%A4%E7%9A%84%E4%B8%BB%E9%A1%B5%EF%BC%9A">https://localhost:8443/即可看到证书不可信任的警告了。选择打死也要进入，即可进入tomcat默认的主页：</a><br/>
<img src="media/14829144540758/14829153068405.jpg" alt="" class="mw_img_center" style="width:200px;display: block; clear:both; margin: 0 auto;"/></p>

<p>　　如果你在此tomcat中部署了项目，即可按照如下url方式访问： <br/>
<a href="https://192.168.1.103:8443/%E9%A1%B9%E7%9B%AE%E5%90%8D/path%EF%BC%8C%E6%B2%A1%E6%9C%89%E9%83%A8%E7%BD%B2%E4%B9%9F%E6%B2%A1%E5%85%B3%E7%B3%BB%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%8B%BF%E9%BB%98%E8%AE%A4%E7%9A%84%E4%B8%BB%E9%A1%B5%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%BA%86%EF%BC%8C%E6%8B%BF%E5%AE%83%E7%9A%84html%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%82">https://192.168.1.103:8443/项目名/path，没有部署也没关系，直接拿默认的主页进行测试了，拿它的html字符串。</a></p>

<p>　　对于访问，还需要说么，我们刚才已经生成了zhy_server.cer证书。你可以选择copy到assets，或者通过命令拿到内部包含的字符串。我们这里选择copy。</p>

<p>　　依然选择在Application中设置信任证书：</p>

<pre><code>public class MyApplication extends Application
{
    private String CER_12306 = &quot;省略...&quot;;

    @Override
    public void onCreate()
    {
        super.onCreate();

        try
        {
            OkHttpClientManager.getInstance()
            .setCertificates(
                    new Buffer()
                    .writeUtf8(CER_12306).inputStream(),
                     getAssets().open(&quot;zhy_server.cer&quot;)
                    );
        } catch (IOException e)
        {
            e.printStackTrace();
        }

    }
}
</code></pre>

<p>　　ok，这样就能正常访问你部署的https项目中的服务了，没有部署项目的尝试拿https://服务端ip:8443/测试即可。</p>

<p>　　注意：不要使用localhost，真机测试保证手机和服务器在同一局域网段内。</p>

<p>　　ok，到此我们介绍完了如果搭建https服务和如何访问，基本上可以应付极大部分的需求了。当然还是极少数的应用需要双向证书验证，比如银行、金融类app，我们一起来了解下。</p>

<p>　　我们已经生成了zhy_server.kjs和zhy_server.cer文件。</p>

<p>　　接下来按照生成证书的方式，再生成一对这样的文件，我们命名为:zhy_client.kjs,zhy_client.cer.</p>

<h2 id="toc_8">五、双向证书验证</h2>

<p>　　首先对于双向证书验证，也就是说，客户端也会有个“kjs文件”，服务器那边会同时有个“cer文件”与之对应。</p>

<p>　　我们已经生成了zhy_server.kjs和zhy_server.cer文件。</p>

<p>　　接下来按照生成证书的方式，再生成一对这样的文件，我们命名为:zhy_client.kjs,zhy_client.cer.</p>

<h2 id="toc_9">（一）配置服务端</h2>

<p>　　首先我们配置服务端：<br/>
服务端的配置比较简单，依然是刚才的Connector标签，不过需要添加些属性。</p>

<pre><code>&lt;Connector  其他属性与前面一致  
    clientAuth=&quot;true&quot;
    truststoreFile=&quot;/Users/zhy/temp/zhy_client.cer&quot; 
      /&gt; 
</code></pre>

<p>　　将clientAuth设置为true，并且多添加一个属性truststoreFile，理论上值为我们的cer文件。这么加入以后，尝试启动服务器，会发生错误：Invalid keystore format。说keystore的格式不合法。</p>

<p>　　我们需要对zhy_client.cer执行以下步骤，将证书添加到kjs文件中。</p>

<pre><code>keytool -import -alias zhy_client 
    -file zhy_client.cer -keystore zhy_client_for_sever.jks
</code></pre>

<p>接下里修改server.xml为：</p>

<pre><code>&lt;Connector  其他属性与前面一致 
    clientAuth=&quot;true&quot;
    truststoreFile=&quot;/Users/zhy/temp/zhy_client_for_sever.jks&quot; 
      /&gt; 
</code></pre>

<p>此时启动即可。</p>

<p>此时再拿浏览器已经无法访问到我们的服务了，会显示基于证书的身份验证失败。</p>

<p>我们将目标来到客户端，即我们的Android端，我们的Android端，如何设置kjs文件呢。</p>

<h3 id="toc_10">（二）配置app端</h3>

<p>　　目前我们app端依靠的应该是zhy_client.kjs。</p>

<p>　　ok，大家还记得，我们在支持https的时候调用了这么俩行代码：</p>

<pre><code>sslContext.init(null, trustManagerFactory.getTrustManagers(), 
    new SecureRandom());
mOkHttpClient.setSslSocketFactory(sslContext.getSocketFactory());
</code></pre>

<p>　　注意sslContext.init的第一个参数我们传入的是null，第一个参数的类型实际上是KeyManager[] km,主要就用于管理我们客户端的key。</p>

<p>于是代码可以这么写：</p>

<pre><code>public void setCertificates(InputStream... certificates)
{
    try
    {
        CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);
        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
        keyStore.load(null);
        int index = 0;
        for (InputStream certificate : certificates)
        {
            String certificateAlias = Integer.toString(index++);
            keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate(certificate));

            try
            {
                if (certificate != null)
                    certificate.close();
            } catch (IOException e)
            {
            }
        }

        SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.
                getInstance(TrustManagerFactory.getDefaultAlgorithm());
        trustManagerFactory.init(keyStore);

        //初始化keystore
        KeyStore clientKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());
        clientKeyStore.load(mContext.getAssets().open(&quot;zhy_client.jks&quot;), &quot;123456&quot;.toCharArray());

        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        keyManagerFactory.init(clientKeyStore, &quot;123456&quot;.toCharArray());

        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom());
        mOkHttpClient.setSslSocketFactory(sslContext.getSocketFactory());


    } catch (Exception e)
    {
        e.printStackTrace();
    } 

}
</code></pre>

<p>核心代码其实就是：</p>

<pre><code>//初始化keystore
KeyStore clientKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());
clientKeyStore.load(mContext.getAssets().open(&quot;zhy_client.jks&quot;), &quot;123456&quot;.toCharArray());

KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
keyManagerFactory.init(clientKeyStore, &quot;123456&quot;.toCharArray());

sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom());
</code></pre>

<p>　　然而此时启动会报错：Java.io.IOException: Wrong version of key store.</p>

<p>为什么呢？</p>

<p>　　因为：Java平台默认识别jks格式的证书文件，但是android平台只识别bks格式的证书文件。</p>

<p>　　这么就纠结了，我们需要将我们的jks文件转化为bks文件，怎么转化呢？</p>

<p>　　这里的方式可能比较多，大家可以百度，我推荐一种方式：</p>

<p>–</p>

<p>　　去<a href="http://sourceforge.net/projects/portecle/files/">Portecle</a>下载<a href="http://sourceforge.net/projects/portecle/files/latest/download?source=files">Download portecle-1.9.zip (3.4 MB)</a>。</p>

<p>　　解压后，里面包含bcprov.jar文件，使用jave -jar bcprov.jar即可打开GUI界面。<br/>
<img src="media/14829144540758/14829160331258.jpg" alt="" class="mw_img_center" style="width:300px;display: block; clear:both; margin: 0 auto;"/><br/>
　　按照上图即可将zhy_client.jks转化为zhy_client.bks。</p>

<p>　　然后将zhy_client.bks拷贝到assets目录下，修改代码为：</p>

<pre><code>//初始化keystore
KeyStore clientKeyStore = KeyStore.getInstance(&quot;BKS&quot;);
clientKeyStore.load(mContext.getAssets().open(&quot;zhy_client.bks&quot;), &quot;123456&quot;.toCharArray());

KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
keyManagerFactory.init(clientKeyStore, &quot;123456&quot;.toCharArray());

sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom());
</code></pre>

<p>　　再次运行即可。然后就成功的做到了双向的验证，关于双向这块大家了解下即可。</p>

<p>源码都在<a href="https://github.com/hongyangAndroid/okhttp-utils">https://github.com/hongyangAndroid/okhttp-utils</a>之中。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用力的人跑不远]]></title>
    <link href="m78snail.com/14779864279806.html"/>
    <updated>2016-11-01T15:47:07+08:00</updated>
    <id>m78snail.com/14779864279806.html</id>
    <content type="html"><![CDATA[
<p>写在前面：有阶段的自己，会用蛮力去学习一些东西，就是这东西不管是否适合目前自己的知识体系， 觉得学了之后会更牛逼就去学，但是这样的东西往往学了记不住。 学习的过程越用力反而显得越吃力， 太吃力的事情，自然就无法有恒心， 这就是很多人会觉得自己做事总是无法持之以恒的原因。</p>

<span id="more"></span><!-- more -->

<p>努力不应该是某种需要被时常觉知的东西，意志力是短期内会用完的精神能量。</p>

<p>真正坚持到最后的人靠的不是激情，而是恰到好处的喜欢和投入。</p>

<p>太用力的人更容易产生期望落差，更不愿接受自己找错了方向的事实——没有什么比这样的“失落”更能让人心寒的了，太用力的人大多都因心累而倒在了半途中。</p>

<p>精神上的用力并不会让你跑得更快，但是精神上的疲惫却可以让你停下。</p>

<p>人越用力，就会越想要得到及时的良好刺激。越用力的人对于正刺激的需求就越高，越不能忍受暂时的负反馈。遗憾的是，人生常常是没有下文的考卷，这种刺激来得太慢、太不稳定。</p>

<p>真正的坚持归于平静，靠的是温和的发力，而不是时时刻刻的刺激。</p>

<p>太用力的人增加了执行的功耗。纠结，是太用力的一种表现，造成内部的运转处于空转的状态——意识与行动的主观脱节；从心所欲，就是把运转效率最大化后的结果——所想即所为。执行阶段最大的敌人，是纠结，是埋怨，是内心的冲突——太用力，就是心理额外动作太多。想好之后就只管去做。</p>

<p>我一直告诫自己不要用力过猛，以保持自己对困难的顿感和不顺的接受程度。<br/>
短期的过度用力极容易造成身体和心理上的挫伤。哪怕你在做的事情非常重要，也要保证基本的休息和放松。</p>

<p>不论是以后的工作还是将来的创业，都要保持一颗平常心。你需要更多的“寸劲”而不是“用力感”。在找到受力点“all in”之前，一切都要顺势而行，自然随和。</p>

<p>人在学习的过程会经历一系列的过程，先是笨拙期，再是熟练期——这两个过程他虽然能运用出技能，但是头脑中仍然能感受到使用时的提取感。这两个阶段都需要用力，但是用力的程度却大幅度减小。</p>

<p>技能掌握的最后阶段是运用自如期，就是张三丰把太极拳的形态全部都忘了的阶段。这个时候头脑中已经能下意识地去进行活动，达到了能耗最低的理想阶段。</p>

<p>从用力感，到毫无感觉，是一种技能掌握上的纯熟。年轻的时候太认真是件好事，或许只有用力过了，才能体会从心所欲、顺其自然的难得。</p>

<p>IT人员怎么用力<br/>
总有在校的学生问我现在 X,Y,Z... 技术很火热，应该学哪个？ 我看他列出的那些准备学习的选项中，其实前景和热门程度都差不多。 这让他陷入了选择焦虑症，不管做什么决定都怕「一失足成千古恨」。</p>

<p>对技术发展趋势关心是好事，就像之前那篇「不要总是选择困难模式」里面说的那样。 但是其实在「不要总是选择困难模式」里面忽略了很重要的一点，就是你个人的兴趣。 比如有的人对苹果的东西有天生的热爱，所以选择「iOS开发」对他来说就更容易做好。 尽可能选择会让自己 Enjoy 的技术方向，路还很长，不享受过程的话容易半途而废。</p>

<p>『太用力的人跑不远』</p>

<p>有阶段的自己，会用蛮力去学习一些东西，就是这东西不管是否适合目前自己的知识体系， 觉得学了之后会更牛逼就去学，但是这样的东西往往学了记不住。 学习的过程越用力反而显得越吃力， 太吃力的事情，自然就无法有恒心， 这就是很多人会觉得自己做事总是无法持之以恒的原因。</p>

<p>记得之前本科的时候喜欢和舍友一起打Dota，打Dota开局之前一般要等人齐， 等人的这段时间我有时候会切出来写写代码，叫舍友开局了告诉我一声。 然后别人看到我在打Dota间隙都在写代码，就觉得我有多努力多努力，给人了一种非常「刻苦」的印象。 以至于上次和一个本科同学吃饭他还说起这个事情，觉得我能做到这样非常「牛逼」。</p>

<p>但是其实这样的事情，如果对于真的对写代码有经历过热爱的人，是不会觉得有多么刻苦的事情。 这是自然而然的事情，甚至其实有些代码，那种满足好奇心的快感，是比打游戏有意思的多， 是件很Enjoy的事情，而不是所谓的「刻苦」。</p>

<p>就像跑步，「太用力的人跑不远」。</p>

<p>『不要用蛮力去学编程』</p>

<p>记得当年初学 C++ 的同学，听别人说 C++ 很基础也很重要的一个知识点就是STL， 然后听说要学好 STL 就应该去看看侯捷的「STL源码剖析」。 然后就买了书硬啃，然后没啃几天就放弃了，觉得太讳莫如深了没法理解。</p>

<p>但是如果换个学习的方式， 先假设现在没有STL这个标准库， 让你用已有的C++语法知识去自己写一个仿造STL标准库的功能， 哪怕是最最简单的 vector 。 你在编写的时候就会自然而然得体会到内存动态扩展的一些缺点和潜在的坑。 会知道为什么适当使用 reserve 和 swap 能非常明显的提高性能。</p>

<p>然后在自己思考的过程中会提出很多相关的疑惑， 带着疑惑再去翻看「STL源码剖析」， 就会让你对一个个数据结构恍然大悟知根知底。 自然而然你的看书体验会非常的 Enjoy， 而不是觉得苦涩难咽。</p>

<p>编程和求知本身是一件愉悦身心的事情， 如果只是为了高薪，而用蛮力去写代码，只会让自己疲惫不堪。</p>

<p>『最后』</p>

<p>希望对在学习编程的路上很挣扎的朋友有所帮助。 毕竟工作是生活的很大一部分， 如果工作不开心，生活怎么办。</p>

<p>寄语<br/>
生活可能像一根弹簧，最好的状态是张弛有度，太紧-压力太大，太松-没有活力，像那位矮大紧所说的，生活不只有眼前的苟且还有诗和远方。</p>

<pre><code>文章是我在csdn上看到的，我觉得写的特别好，所以转到自己的blog来。
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 常用方法]]></title>
    <link href="m78snail.com/14779861870049.html"/>
    <updated>2016-11-01T15:43:07+08:00</updated>
    <id>m78snail.com/14779861870049.html</id>
    <content type="html"><![CDATA[
<p>下面总结一下自己在学习Git时用到的一些语法<br/>
更多详细内容请浏览：<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程 - 廖雪峰的官方网站</a></p>

<h2 id="toc_0">一 . 修改文件</h2>

<pre><code>git init：创建git
git add readme.txt ：将readme.txt变化提交到库
git status ：获取修改的状态
git diff readme.txt：获取我们与库中哪里不同
git commit :将修改提交到库中
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_1">二 . 回溯版本</h2>

<pre><code>git log：显示从最近到最远的提交日志
git log --pretty=oneline ：简化日志
git reset --hard HEAD^ ：HEAD代表当前版本，一个代表上一版
git reflog：获取记录的commit id
git reset --hard (commit id) :回溯到指定id的版本
</code></pre>

<h2 id="toc_2">三 . 撤销修改</h2>

<pre><code>git checkout -- file :撤销回到最近一次git commit或git add时的状态
git reset HEAD file : 把暂存区的修改撤销掉
</code></pre>

<h2 id="toc_3">四 . 删除文件</h2>

<pre><code>rm test.txt :删除test.txt
git rm test.txt：将删除操作提交到暂存区，commit之后版本里的删除
git checkout -- test.txt :用版本库里的版本替换工作区的版本
</code></pre>

<h2 id="toc_4">五 . 远程库</h2>

<pre><code>git remote add origin git@github.com:username/name.git :添加远程库
git push -u origin master :第一次将本地库传送到远程库
git push origin master :将本地库传送到远程库 #### 2.从远程库克隆
git clone git@github.com:username/name.git :克隆一个本地库
</code></pre>

<h2 id="toc_5">六 . 分支管理</h2>

<h3 id="toc_6">1. 创建与合并分支</h3>

<pre><code>git checkout -b dev :git checkout 命令加上-b参数表示创建分支并切换
git branch : 查看当前分支,列出所有分支
git checkout master :切换回主分支
git merge dev ：合并指定分支dev到当前分支
git branch -d dev ：删除分支dev
</code></pre>

<h3 id="toc_7">2. 解决冲突</h3>

<pre><code>git log ：看到分支的合并情况
git merge --no-ff -m &quot;merge with no-ff&quot; dev :加上--no-ff参数就可以用普通模式合并，合并后的历史有分支
</code></pre>

<h3 id="toc_8">3. Bug分支</h3>

<pre><code>git stash :把当前工作现场“储藏”起来，以后恢复现场后继续工作
git stash list :查看stash
git stash apply :恢复工作，但是恢复后，stash内容并不删除
git stash drop :删除stash
git stash pop ：恢复的同时把stash内容也删了
</code></pre>

<h3 id="toc_9">4. Feature分支</h3>

<h4 id="toc_10">(1). 多人协作</h4>

<p>先用git pull把最新的提交从origin/dev抓下来,遇到错误的话<br/>
git branch --set-upstream dev origin/dev :指定本地dev分支与远程origin/dev分支的链接，再pull<br/>
合并冲突，需要手动解决<br/>
解决后，提交，再push : git push origin dev。<br/>
git clone只能clone远程库的master分支，无法clone所有分支，解决办法如下：</p>

<pre><code>1. 找一个干净目录，假设是git_work
2. cd git_work
3. git clone http://myrepo.xxx.com/project/.git ,这样在git_work目录下得到一个project子目录
4. cd project
5. git branch -a，列出所有分支名称如下： remotes/origin/dev remotes/origin/release
6. git checkout -b dev origin/dev，作用是checkout远程的dev分支，在本地起名为dev分支，并切换到本地的dev分支
7. git checkout -b release origin/release，作用参见上一步解释
8. git checkout dev，切换回dev分支，并开始开发。
</code></pre>

<h4 id="toc_11">(2). 多人协作的工作模式通常是这样：</h4>

<p>　　首先，可以试图用git push origin branch-name推送自己的修改；</p>

<p>　　如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p>

<p>　　如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。</p>

<p>　　这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>

<h2 id="toc_12">七. Github 的使用</h2>

<p>　　如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap">https://github.com/twbs/bootstrap</a><br/>
点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</p>

<p>git clone <a href="mailto:git@github.com">git@github.com</a>:michaelliao/bootstrap.git<br/>
　　一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<a href="mailto:git@github.com">git@github.com</a>:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。<br/>
　　如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。<br/>
　　如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xUtils框架中HttpUtils模块源码剖析]]></title>
    <link href="m78snail.com/14779864962440.html"/>
    <updated>2016-11-01T15:48:16+08:00</updated>
    <id>m78snail.com/14779864962440.html</id>
    <content type="html"><![CDATA[
<p>　　xUtils是github上的一个Android开源工具项目，xUtils包含了很多实用的android工具，其中HttpUtils模块是处理网络连接部分。在我上一个项目《数据铁笼》中经常用到，作为与服务器连接的工具，所以想要深入学习一下。<br/>
　　项目最近更新到了3.0，我项目中用到的还是2.6有些方面可能和最新的有出入，请以作者最新的代码为准。<br/>
　　<a href="https://github.com/wyouflf/xUtils3">https://github.com/wyouflf/xUtils3</a><br/>
　　惯例是例举出我在学习中借鉴的一些大神的博客，以此来表示对他们的尊重</p>

<blockquote>
<ol>
<li><a href="http://kb.cnblogs.com/page/130970/#threeconcept">HTTP 协议详解</a></li>
<li><a href="http://www.tuicool.com/articles/nMFb2q">Android开源项目xUtils HttpUtils模块分析</a></li>
<li><a href="http://uule.iteye.com/blog/1539084">Future和FutureTask</a></li>
<li><a href="http://blog.csdn.net/cjj198561/article/details/40475771">xUtils异步HTTP源码分析</a></li>
</ol>
</blockquote>

<p>　　上面这些文章讲的都特别好，大家如果有时间可以都看看。</p>

<span id="more"></span><!-- more -->

<p>　　</p>

<h2 id="toc_0">一 . 以前的HttpClient 方法</h2>

<p>　　首先我先说下以前如果使用Http协议的话，我会使用Apache的HttpClient，大体上分为六步：<br/>
　　<br/>
　　<br/>
　　<strong>以Post方法为例</strong></p>

<pre><code>//第一步创建DefaultHttpClient对象
HttpClient httpClient=new DefaultHttpClient();
//第二步创建HttpPost
HttpPost post=new HttpPost(&quot;http:192.168.3.1:8080/login.jsp&quot;);
//第三步对传递参数进行封装
List&lt;NameValuePairs&gt; params=new ArrayList&lt;NameValuePair&gt;()；
params.add(new BasicNameValuePair(&quot;name&quot;,name));
params.add(new BasicNameValuePair(&quot;pass&quot;,pass));
//第四步为post设置请求参数
post.setEntity(new UriEncodedFormEntity(params,HTTP.UTF_8));
//第五步发送post请求
HttpResponse respones=httpClient.execute(post);
//第六步解析
String msg=EntityUtils.toString(respones.getEntity());
</code></pre>

<p>　　为什么这么详细的介绍Apache 的HttpClient，因为2.6版本中，使用的就是HttpClient，但是在3.0版本中已经替换HttpClient为UrlConnection，这个回来还要再研究下。现在就当复习一遍Apache的HttpClient了吧。<br/>
　　</p>

<h2 id="toc_1">二 . 上Demo，看用法</h2>

<p>废话不多说，先看看怎么用</p>

<pre><code>//第一步设置请求参数的编码
RequestParams params = new RequestParams(); // 默认编码UTF-8
//第二步根据你服务器要求的参数，进行传参
params.setHeader(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;);
JSONObject object = new JSONObject();
object.put(&quot;policenum&quot;, uLogin.getPolicenum());
object.put(&quot;taskid&quot;, taskid);
String json = JSON.toJSONString(object);
StringEntity entity=null;
try {
        entity = new StringEntity(json, &quot;UTF-8&quot;);
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }
params.setBodyEntity(entity);
//第三步调用HttpUtiles的send方法,可重写这两个方法，作为回调
http.send(HttpRequest.HttpMethod.POST, url,params, 
     new RequestCallBack&lt;String&gt;() {
        @Override
        public void onFailure(HttpException exception, String msg) {}
        @Override
        public void onSuccess(ResponseInfo&lt;String&gt; Response) {});
        }
）
</code></pre>

<h2 id="toc_2">三 . 解析源码</h2>

<h3 id="toc_3">1 . 构造函数</h3>

<p>　　首先我们使用HttpUtils模块，一般都要使用new一个HttpUtils出来，默认的构造函数为</p>

<pre><code> public HttpUtils(int connTimeout, String userAgent) {
        HttpParams params = new BasicHttpParams();
        ConnManagerParams.setTimeout(params, connTimeout);
        HttpConnectionParams.setSoTimeout(params, connTimeout);
        HttpConnectionParams.setConnectionTimeout(params, connTimeout);

        if (TextUtils.isEmpty(userAgent)) {
            userAgent = OtherUtils.getUserAgent(null);
        }
        HttpProtocolParams.setUserAgent(params, userAgent);

        ConnManagerParams.setMaxConnectionsPerRoute(params, new ConnPerRouteBean(10));
        ConnManagerParams.setMaxTotalConnections(params, 10);

        HttpConnectionParams.setTcpNoDelay(params, true);
        HttpConnectionParams.setSocketBufferSize(params, 1024 * 8);
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
  }
</code></pre>

<p>　　这里就不全部截出来了，这里会设置Http协议的一些参数，这些参数往往对于不同的服务器都是固定的，比如采用Http1.1，设置超时时间等等，当然你也可以自己设置，不调用它默认的也可以，根据自己的公司业务要求自己设置。</p>

<h3 id="toc_4">2 . send()方法</h3>

<pre><code class="language-java">public &lt;T&gt; HttpHandler&lt;T&gt; send(HttpRequest.HttpMethod method, String url, RequestParams params, RequestCallBack&lt;T&gt; callBack) {
        if (url == null) 
        throw new IllegalArgumentException(&quot;url may not be null&quot;);
        HttpRequest request = new HttpRequest(method, url);
        return sendRequest(request, params, callBack);
}
</code></pre>

<p>解释下上述参数：<br/>
　　第一个参数 method:HttpRequest.HttpMethod 里面设定好的10种；<br/>
　　第二个参数 url：服务器地址或者接口地址；<br/>
　　第三个参数 params：传给服务器的参数；<br/>
　　第四个参数 callBack：看名字就知道，服务器返回消息后回调的接口，可以重写其中的方法；</p>

<p>　　HttpHandler实际上是一个异步AsyncTask，后面我们会详细解释</p>

<h3 id="toc_5">3 . 重点解析 HttpRequest</h3>

<p>　　全部代码就不截图了HttpRequest（HttpMethod method, String uri），作为参数</p>

<pre><code class="language-java">public HttpRequest(HttpMethod method, String uri) {
        super();
        this.method = method;
        setURI(uri);
}
</code></pre>

<h4 id="toc_6">(1). setRequestParams方法</h4>

<p>主要干了三件事:</p>

<h5 id="toc_7">①保存Header头部</h5>

<pre><code class="language-java">List&lt;RequestParams.HeaderItem&gt; headerItems = param.getHeaders();
</code></pre>

<h5 id="toc_8">②保存entity整体</h5>

<pre><code class="language-java">HttpEntity entity = param.getEntity();
this.setEntity(entity);
</code></pre>

<h5 id="toc_9">③保存回调函数</h5>

<pre><code>entity.setCallBackHandler(callBackHandler);
</code></pre>

<p>　　至此Http协议中的大部分信息都保存到了<strong>HttpRequest</strong>中，函数最后运行:<br/>
　　</p>

<pre><code>handler.executeOnExecutor(EXECUTOR, request);
</code></pre>

<h3 id="toc_10">4 . HttpHandler类：</h3>

<p>　　HttpHandler继承自PriorityAsyncTask，前面我们已经说了HttpHandler实际上是一个异步AsyncTask，让我们直接去HttpHandler继承自PriorityAsyncTask里面看executeOnExecutor方法：<br/>
　　</p>

<pre><code>//EXECUTOR：线程池
//params：参数也就是HttpRequest
public final PriorityAsyncTask&lt;Params,Progress,Result&gt;executeOnExecutor(Executor exec,Params... params) {
        if (mExecuteInvoked) {
            throw new IllegalStateException(&quot;Cannot execute task:&quot;
                    + &quot; the task is already executed.&quot;);
        }

        mExecuteInvoked = true;

        onPreExecute();

        mWorker.mParams = params;
        exec.execute(new PriorityRunnable(priority, mFuture));

       return this;
}
</code></pre>

<pre><code>解释下：

mWorker.mParams = params;
...
private static abstract class WorkerRunnable&lt;Params,Result&gt;implements Callable&lt;Result&gt; {
        Params[] mParams;
    }
</code></pre>

<p>　　mWorker是一个Callable，用于后面的调用这点很重要，因为最后其实就是调用的mWork；</p>

<pre><code class="language-java"> exec.execute(new PriorityRunnable(priority, mFuture));
</code></pre>

<p>　　调用PriorityObject的run方法，会去调用mFuture的run方法，mFuture是一个FutureTask，为什么前面说最后其实会去调用mWorker呢，注意mFuture定义的地方：<br/>
　　</p>

<pre><code>  mFuture = new FutureTask&lt;Result&gt;(mWorker) {
            @Override
            protected void done() {
               ...
            }
  };
</code></pre>

<p>　　我们去找FutureTask的run函数，翻开FutureTask的源码，找到run的源码</p>

<pre><code>public void run() {
       ....
        try {
            Callable&lt;V&gt; c = callable;
            if (c != null &amp;&amp; state == NEW) {
                V result;
                boolean ran;
                try {
        //////////////////////////////这里调用的mWorker的call方法
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex);
                }
                if (ran)
                    set(result);
            }
        } finally {
            ....
        }
}
</code></pre>

<p>　　也就是说最终会去调用mWork的call()方法，那就让我们看看call（）方法<br/>
　　</p>

<pre><code>mWorker = new WorkerRunnable&lt;Params, Result&gt;() {
            public Result call() throws Exception {
              ....
                return postResult(doInBackground(mParams));
            }
};
</code></pre>

<p>　　最终会去最后的BOSS级代码，HttpHandler的doInBackground，其实上面的一系列方法很好理解，就是为了创建异步AsyncTask，以前都只是直接拿AsyncTask来用，根本没想过自己实现一个，分析源码也算是对我自己的一个学习，好了不感概了看一下doInBackground（）：<br/>
首先肯定是要取出来之前保存在HttpRequest里面的各种参数.</p>

<pre><code>request = (HttpRequestBase) params[0];
requestUrl = request.getURI().toString();
</code></pre>

<p>　　接下来就是重头戏发送请求</p>

<pre><code>ResponseInfo&lt;T&gt; responseInfo = sendRequest(request);
</code></pre>

<p>　　看一下sendRequest（）方法：</p>

<pre><code>    ...
 ResponseInfo&lt;T&gt; responseInfo = null;
 if (!isCancelled()) {
    HttpResponse response = client.execute(request, context);
                    responseInfo = handleResponse(response);
                }
    return responseInfo;
    ...
</code></pre>

<p>　　最后调用</p>

<pre><code>this.publishProgress(UPDATE_SUCCESS, responseInfo);
....
case UPDATE_SUCCESS:
        if (values.length != 2) return;
        this.state = State.SUCCESS;
        //回调callback
        callback.onSuccess((ResponseInfo&lt;T&gt;) values[1]);
        break;
</code></pre>

<p>　　xUtils里面还有很多细节我没有说到，大家可以自己去研究下。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[otto 框架分析]]></title>
    <link href="m78snail.com/14779857522449.html"/>
    <updated>2016-11-01T15:35:52+08:00</updated>
    <id>m78snail.com/14779857522449.html</id>
    <content type="html"><![CDATA[
<p>　　最近项目上经常会用到otto框架，它跟EventBus很像，这里希望总结一下：<br/>
　　</p>

<blockquote>
<ul>
<li>运行时动态处理（注解）</li>
<li>IOC 控制反转</li>
<li>观察者模式 EventBus模式</li>
</ul>
</blockquote>

<p>　　大体上要学习otto框架就是上面三个方面，看着名词很高端？没事，让我一一解释一下。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">一 . 运行时动态处理（注解）</h2>

<p>　　我们最初学习安卓的时候最先接触的类恐怕就是Activity了吧，在里面onCreate()这些方法会要求我们重写，在上面会有一个注解@Override,难道仅仅起到注释的作用吗？其实注解分为两种<br/>
　　① 运行时动态处理：在运行时拿到类的Class对象，然后遍历其方法、变量，判断有无注解声明，然后做一些事情<br/>
　　② 编译时动态处理：这类注解会在编译的时候，根据注解标识，动态生成一些类或者生成一些xml都可以，在运行时期，这类注解是没有的~~会依靠动态生成的类做一些操作，因为没有反射，效率和直接调用方法没什么区别<br/>
　　今天我们只研究运行时动态处理。<br/>
　　有句话说得好，叫<strong>无反射没框架</strong>。<br/>
　　任何框架都离不开反射，反射以前只在书本上了解过就是运行时获取对象的类方法，变量吗.现在反射在速度上已经有了很大的提高，我们完全不必担心性能方面会变差很多。<br/>
　　说了半天，你只要记住注解，作为一种标志，可以帮你在你的类加载时替你记住那些你希望以后用来调用的方法和对象。<br/>
　　在otto中最重要的两个注解就是@Subscribe和@Produce，这两个是什么作用等下再说。</p>

<h2 id="toc_1">二 . IOC 控制反转</h2>

<p>　　什么事IOC控制反转？<br/>
　　当A类想使用B类的一个方法时，我们传统的做法是new一个B类实例出来，再去调用方法，但是这就使得A,B两个类纠缠在一起。当我们改变了B类时，所有调用了B类的文件我们都需要去改，这样是不是太麻烦，好的做法是写一个主线类，它会自动帮我们去注入（new）,当我们需要改动时，只要改这个主线类就可以了。这个主线类也就是我要提到的otto框架中的Bus类，这是otto最重要的类，它有什么作用？这玩意就是在类加载时调用register，扫描类中复合命名规范的方法，存到一个map，然后post的时候，查找到匹配的方法，反射调用。不理解？等下我们举个例子你就明白了，现在我们先解释完名词。</p>

<h2 id="toc_2">三 . 观察者模式 EventBus模式</h2>

<p>　　otto框架是基于EventBus框架，这是一个是一个发布 / 订阅的事件总线，大家可以看下鸿洋大神的这篇<a href="http://blog.csdn.net/lmj623565791/article/details/40794879">Android EventBus实战 没听过你就out了</a>讲的特别好</p>

<h2 id="toc_3">四 . 应用实战</h2>

<p>　　任何一个App都一定会提供软件更新功能，当我们在更新过程中突然不想更新了，点击了取消，让我们的代码去调用SplashActivity里面的DoCancelUpdate方法。由于我们的下载更新类是写在UpdateManager类里面，那我们怎么做呢，没学会otto框架之前我们可能会在新建UpdateManager时传进去一个Context，这会不会导致Context引发的内存泄漏，我们需要很小心的检查，现在我们使用otto框架就不需要担心这个问题，因为他们两人几乎没有交集，他们都是通过Bus类来沟通。废话不多说上代码：</p>

<h3 id="toc_4">1 . SplashActivity中让bus注册，并订阅事件</h3>

<pre><code class="language-python">   @Override
    protected void onCreate(Bundle arg0) {
        super.onCreate(arg0);
        BusProvider.getInstance().register(this);
        setContentView(getLayoutResource());
    }
    
    @Subscribe
    public void DoCancelUpdate(CancelUpdateEvent event){
        continueRun();
    } 
</code></pre>

<h3 id="toc_5">2 . BusProvider为一个单例模式类，Bus最好只有一个</h3>

<pre><code class="language-python">public class BusProvider {

    public static Bus bus;

    public static Bus getInstance() {
        if (bus == null) {
            bus = new Bus(ThreadEnforcer.ANY);
        }
        return bus;
    }

    private BusProvider() {
    
    }
}
</code></pre>

<h3 id="toc_6">3 . UpdateManager类中使用post发出事件，凡是订阅了的都会调用</h3>

<pre><code class="language-python">BusProvider.bus.post(new CancelUpdateEvent());
</code></pre>

<p>　　至此算是完成了otto框架的总结，分享一些自己在找资料时遇到的大神博客文章：<br/>
　　<a href="http://blog.csdn.net/lmj623565791/article/details/40794879">Android EventBus实战 没听过你就out了</a><br/>
　　<a href="http://blog.csdn.net/lmj623565791/article/details/39269193">Android 进阶 教你打造 Android 中的 IOC 框架</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dagger2 使用详解(4)--原理分析]]></title>
    <link href="m78snail.com/14839485571061.html"/>
    <updated>2017-01-09T15:55:57+08:00</updated>
    <id>m78snail.com/14839485571061.html</id>
    <content type="html"><![CDATA[
<p>　　前面啰里啰嗦的介绍了Dagger2的基本使用，接下来我们再分析分析实现原理。这里不会分析Dagger2根据注解生成各种代码的原理，关于Java注解以后有机会再写一篇文章来介绍。后面主要分析的是Dagger2生成的各种类如何帮我们实现依赖注入，为了便于理解我这里选了前面相对简单的案例B来做分析。</p>

<span id="more"></span><!-- more -->

<p>　　Dagger2编译期生成的代码位于build/generated/source/apt/debug/your package name/下面:<br/>
<img src="media/14839485571061/14839503268924.jpg" alt="" class="mw_img_center" style="width:300px;display: block; clear:both; margin: 0 auto;"/></p>

<p>　　首先我们看看Dagger2依据依赖提供方MarkCarModule生成的对应工厂类MarkCarModule_ProvideEngineFactory。为了方便大家理解对比，后面我一律会把自己写的类和Dagger2生成的类一并放出来。</p>

<pre><code>/**
* 我们自己的类
*/
@Module
public class MarkCarModule {

    public MarkCarModule(){ }

    @Provides Engine provideEngine(){
        return new Engine(&quot;gear&quot;);
    }
}
</code></pre>

<pre><code>/**
* Dagger2生成的工厂类
*/
public final class MarkCarModule_ProvideEngineFactory implements Factory&lt;Engine&gt; {
  private final MarkCarModule module;

  public MarkCarModule_ProvideEngineFactory(MarkCarModule module) {
    assert module != null;
    this.module = module;
  }

  @Override
  public Engine get() {
    return Preconditions.checkNotNull(
        module.provideEngine(), &quot;Cannot return null from a non-@Nullable @Provides method&quot;);
  }

  public static Factory&lt;Engine&gt; create(MarkCarModule module) {
    return new MarkCarModule_ProvideEngineFactory(module);
  }

  /** Proxies {@link MarkCarModule#provideEngine()}. */
  public static Engine proxyProvideEngine(MarkCarModule instance) {
    return instance.provideEngine();
  }
}
</code></pre>

<p>　　我们可以看到MarkCarModule_ProvideEngineFactory中的get()调用了MarkCarModule的provideEngine()方法来获取我们需要的依赖Engine，MarkCarModule_ProvideEngineFactory的实例化有crate()创建，并且MarkCarModule的实例也是通过create()方法传进来的。那么这个create()一定会在哪里调用的，我们接着往下看。</p>

<p>　　前面提到@Component是依赖提供方(MarkCarModule)和依赖需求方(Car)之前的桥梁，那我看看Dagger2是如何通过CarComponent将两者联系起来的。</p>

<pre><code>/**
* 我们自己的类
*/
@Component(modules = {MarkCarModule.class})
public interface CarComponent {

    void inject(Car car);
}
</code></pre>

<pre><code>/**
* Dagger2生成的CarComponent实现类
*/
public final class DaggerCarComponent implements CarComponent {
  private Provider&lt;Engine&gt; provideEngineProvider;

  private MembersInjector&lt;Car&gt; carMembersInjector;

  private DaggerCarComponent(Builder builder) {
    assert builder != null;
    initialize(builder);
  }

  public static Builder builder() {
    return new Builder();
  }

  public static CarComponent create() {
    return builder().build();
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  private void initialize(final Builder builder) {

    this.provideEngineProvider = MarkCarModule_ProvideEngineFactory.create(builder.markCarModule);

    this.carMembersInjector = Car_MembersInjector.create(provideEngineProvider);
  }

  @Override
  public void inject(Car car) {
    carMembersInjector.injectMembers(car);
  }

  public static final class Builder {
    private MarkCarModule markCarModule;

    private Builder() {}

    public CarComponent build() {
      if (markCarModule == null) {
        this.markCarModule = new MarkCarModule();
      }
      return new DaggerCarComponent(this);
    }

    public Builder markCarModule(MarkCarModule markCarModule) {
      this.markCarModule = Preconditions.checkNotNull(markCarModule);
      return this;
    }
  }
}
</code></pre>

<p>　　通过上面的代码我们看到Dagger2依据CarComponent接口生成了实现类DaggerCarComponent（没错这正是我们在Car的构造函数中使用DaggerCarComponent）。DaggerCarComponent在build的时候实例化了DaggerCarComponent对象，并首先调用MarkCarModule_ProvideEngineFactory.create(builder.markCarModule)始化了provideEngineProvider变量，接着调用Car_MembersInjector.create(provideEngineProvider)初始化了carMembersInjector变量。当我们手动在Car类的构造函数中调用inject(Car car)方法时会执行carMembersInjector.injectMembers(car)。所以接下来我们要看看Car_MembersInjector的实现。</p>

<pre><code>public final class Car_MembersInjector implements MembersInjector&lt;Car&gt; {
  private final Provider&lt;Engine&gt; engineProvider;

  public Car_MembersInjector(Provider&lt;Engine&gt; engineProvider) {
    assert engineProvider != null;
    this.engineProvider = engineProvider;
  }

  public static MembersInjector&lt;Car&gt; create(Provider&lt;Engine&gt; engineProvider) {
    return new Car_MembersInjector(engineProvider);
  }

  @Override
  public void injectMembers(Car instance) {
    if (instance == null) {
      throw new NullPointerException(&quot;Cannot inject members into a null reference&quot;);
    }
    instance.engine = engineProvider.get();
  }

  public static void injectEngine(Car instance, Provider&lt;Engine&gt; engineProvider) {
    instance.engine = engineProvider.get();
  }
}
</code></pre>

<p>Car_MembersInjector中的create()用于实例化自己，这个方法前面我们看到是在DaggerCarComponent中调用的。injectMembers(Car instance)将engineProvider.get()的返回值赋给了依赖需求方Car的engine变量，而engineProvider.get()正是本节一开始我们提到的MarkCarModule_ProvideEngineFactory中的get()方法。至此整个依赖注入的流程就完成了。更复杂的应用场景会生成更加复杂的代码，但原理都和前面分析的大同小异。</p>

<p>总结</p>

<p>这篇文章只是通过一些简单的例子介绍了Dagger2的相关概念及使用，实际项目中的应用远比这里的例子要复杂。关于Dagger2在实际项目中的应用可以参照这个开源项目 <br/>
<a href="https://github.com/BaronZ88/MinimalistWeather">BaronZ88/MinimalistWeather</a>（项目采用MVP架构，其中View层和Presenter层的解耦就是通过Dagger2来实现的）。</p>

<p>MinimalistWeather是一款开源天气App，开发此项目主要是为展示各种开源库的使用方式以及Android项目的架构方案，并作为团队开发规范的一部分。项目中每一个字母、每一个命名、每一行代码都是经过仔细考究的；但是由于时间精力有限，项目UI未做严格要求。本着精益求精、提供更好开源项目和更美天气应用的原则，因此期望有兴趣的开发和UED同学可以一起来完成这个项目。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dagger2 使用详解(3)--使用入门]]></title>
    <link href="m78snail.com/14839485560967.html"/>
    <updated>2017-01-09T15:55:56+08:00</updated>
    <id>m78snail.com/14839485560967.html</id>
    <content type="html"><![CDATA[
<p>　　前面长篇大论的基本都在介绍概念，下面我们看看Dagger2的基本应用。关于Dagger2的依赖配置就不在这里占用篇幅去描述了，大家可以到它的github主页下去查看官方教程<a href="https://github.com/google/dagger">https://github.com/google/dagger</a>。接下来我们还是拿前面的Car和Engine来举例。</p>

<span id="more"></span><!-- more -->

<p>　<br/>
<strong>1、案例A</strong></p>

<p>　　Car类是需求依赖方，依赖了Engine类；因此我们需要在类变量Engine上添加@Inject来告诉Dagger2来为自己提供依赖。</p>

<pre><code>public class Car {

    @Inject
    Engine engine;

    public Car() {
        DaggerCarComponent.builder().build().inject(this);
    }

    public Engine getEngine() {
        return this.engine;
    }
}
</code></pre>

<p>　　Engine类是依赖提供方，因此我们需要在它的构造函数上添加@Inject</p>

<pre><code>public class Engine {

    @Inject
    Engine(){}

    public void run(){
        System.out.println(&quot;引擎转起来了~~~&quot;);
    }
}
</code></pre>

<p>　　接下来我们需要创建一个用@Component标注的接口CarComponent，这个CarComponent其实就是一个注入器，这里用来将Engine注入到Car中。</p>

<pre><code>@Component
public interface CarComponent {
    void inject(Car car);
}
</code></pre>

<p>完成这些之后我们需要Build下项目，让Dagger2帮我们生成相关的Java类。接着我们就可以在Car的构造函数中调用Dagger2生成的DaggerCarComponent来实现注入（这其实在前面Car类的代码中已经有了体现）</p>

<pre><code>public Car() {
    DaggerCarComponent.builder().build().inject(this);
}
</code></pre>

<p><strong>2、案例B</strong></p>

<p>　　如果创建Engine的构造函数是带参数的呢？比如说制造一台引擎是需要齿轮(Gear)的。或者Eggine类是我们无法修改的呢？这时候就需要@Module和@Provide上场了。</p>

<p>　　同样我们需要在Car类的成员变量Engine上加上@Inject表示自己需要Dagger2为自己提供依赖；Engine类的构造函数上的@Inject也需要去掉，应为现在不需要通过构造函数上的@Inject来提供依赖了。</p>

<pre><code>public class Car {

    @Inject
    Engine engine;

    public Car() {
        DaggerCarComponent.builder().markCarModule(new MarkCarModule())
                .build().inject(this);
    }

    public Engine getEngine() {
        return this.engine;
    }
}
</code></pre>

<p>接着我们需要一个Module类来生成依赖对象。前面介绍的@Module就是用来标准这个类的，而@Provide则是用来标注具体提供依赖对象的方法（这里有个不成文的规定，被@Provide标注的方法命名我们一般以provide开头，这并不是强制的但有益于提升代码的可读性）。</p>

<pre><code>@Module
public class MarkCarModule {

    public MarkCarModule(){ }

    @Provides Engine provideEngine(){
        return new Engine(&quot;gear&quot;);
    }
}
</code></pre>

<p>　　接下来我们还需要对CarComponent进行一点点修改，之前的@Component注解是不带参数的，现在我们需要加上modules = {MarkCarModule.class}，用来告诉Dagger2提供依赖的是MarkCarModule这个类。</p>

<pre><code>@Component(modules = {MarkCarModule.class})
public interface CarComponent {
    void inject(Car car);
}
</code></pre>

<p>　　Car类的构造函数我们也需要修改，相比之前多了个markCarModule(new MarkCarModule())方法，这就相当于告诉了注入器DaggerCarComponent把MarkCarModule提供的依赖注入到了Car类中。</p>

<pre><code>public Car() {
   DaggerCarComponent.builder()
           .markCarModule(new MarkCarModule())
           .build().inject(this);
}
</code></pre>

<p>这样一个最最基本的依赖注入就完成了，接下来我们测试下我们的代码。</p>

<pre><code>public static void main(String[] args){
    Car car = new Car();
    car.getEngine().run();
}
</code></pre>

<p>输出</p>

<p>引擎转起来了~~~<br/>
<strong>3、案例C</strong></p>

<p>　　那么如果一台汽车有两个引擎（也就是说Car类中有两个Engine变量）怎么办呢？没关系，我们还有@Qulifier！首先我们需要使用Qulifier定义两个注解：</p>

<pre><code>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface QualifierA { }
@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface QualifierB { }
</code></pre>

<p>同时我们需要对依赖提供方做出修改</p>

<pre><code>@Module
public class MarkCarModule {

    public MarkCarModule(){ }

    @QualifierA
    @Provides
    Engine provideEngineA(){
        return new Engine(&quot;gearA&quot;);
    }

    @QualifierB
    @Provides
    Engine provideEngineB(){
        return new Engine(&quot;gearB&quot;);
    }
}
</code></pre>

<p>接下来依赖需求方Car类同样需要修改</p>

<p>public class Car {</p>

<pre><code>@QualifierA @Inject Engine engineA;
@QualifierB @Inject Engine engineB;

public Car() {
    DaggerCarComponent.builder().markCarModule(new MarkCarModule())
            .build().inject(this);
}

public Engine getEngineA() {
    return this.engineA;
}

public Engine getEngineB() {
    return this.engineB;
}
</code></pre>

<p>}<br/>
最后我们再对Engine类做些调整方便测试</p>

<pre><code>public class Engine {

    private String gear;

    public Engine(String gear){
        this.gear = gear;
    }

    public void printGearName(){
        System.out.println(&quot;GearName:&quot; + gear);
    }
}
</code></pre>

<p>测试代码</p>

<pre><code>public static void main(String[] args) {
    Car car = new Car();
    car.getEngineA().printGearName();
    car.getEngineB().printGearName();
}
</code></pre>

<p>执行结果：</p>

<p>GearName:gearA<br/>
GearName:gearB<br/>
<strong>4、案例D</strong></p>

<p>　　接下来我们看看@Scope是如何限定作用域，实现局部单例的。</p>

<p>　　首先我们需要通过@Scope定义一个CarScope注解：</p>

<pre><code>@Scope
@Retention(RetentionPolicy.RUNTIME)
public @interface CarScope {
}
</code></pre>

<p>　　接着我们需要用这个@CarScope去标记依赖提供方MarkCarModule。</p>

<pre><code>@Module
public class MarkCarModule {

    public MarkCarModule() {
    }

    @Provides
    @CarScope
    Engine provideEngine() {
        return new Engine(&quot;gear&quot;);
    }
}
</code></pre>

<p>同时还需要使用@Scope去标注注入器Compoent</p>

<pre><code>@CarScope
@Component(modules = {MarkCarModule.class})
public interface CarComponent {
    void inject(Car car);
}
</code></pre>

<p>为了便于测试我们对Car和Engine类做了一些改造：</p>

<pre><code>public class Car {

    @Inject Engine engineA;
    @Inject Engine engineB;

    public Car() {
        DaggerCarComponent.builder()
                .markCarModule(new MarkCarModule())
                .build().inject(this);
    }
}
public class Engine {

    private String gear;

    public Engine(String gear){
        System.out.println(&quot;Create Engine&quot;);
        this.gear = gear;
    }
}
</code></pre>

<p>如果我们不适用@Scope,上面的代码会实例化两次Engine类，因此会有两次&quot;Create Engine&quot;输出。现在我们在有@Scope的情况测试下劳动成果：</p>

<p>public static void main(String[] args) {<br/>
    Car car = new Car();</p>

<pre><code>System.out.println(car.engineA.hashCode());
System.out.println(car.engineB.hashCode());
</code></pre>

<p>}<br/>
输出</p>

<p>Create Engine<br/>
bingo！我们确实通过@Scope实现了局部的单例。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dagger2 使用详解(2)--注解]]></title>
    <link href="m78snail.com/14839485563999.html"/>
    <updated>2017-01-09T15:55:56+08:00</updated>
    <id>m78snail.com/14839485563999.html</id>
    <content type="html"><![CDATA[
<p>　　无论是构造函数注入还是接口注入，都避免不了要编写大量的模板代码。机智的猿猿们当然不开心做这些重复性的工作，于是各种依赖注入框架应用而生。但是这么多的依赖注入框架为什么我们却偏爱Dagger2呢？我们先从Spring中的控制反转（IOC）说起。</p>

<span id="more"></span><!-- more -->

<p>　　谈起依赖注入，做过J2EE开发的同学一定会想起Spring IOC，那通过迷之XML来配置依赖的方式真的很让人讨厌；而且XML与Java代码分离也导致代码链难以追踪。之后更加先进的Guice（Android端也有个RoboGuice）出现了，我们不再需要通过XML来配置依赖，但其运行时实现注入的方式让我们在追踪和定位错误的时候却又万分痛苦。开篇提到过Dagger就是受Guice的启发而开发出来的；Dagger继承了前辈的思想，在性能又碾压了它的前辈Guice，可谓是长江后浪推前浪，前浪死在沙滩上。</p>

<p>　　又如开篇我在简介中说到的，Dagger是一种半静态半运行时的DI框架，虽说依赖注入是完全静态的，但是生成有向无环图(DAG)还是基于反射来实现，这无论在大型的服务端应用还是在Android应用上都不是最优方案。升级版的Dagger2解决了这一问题，从半静态变为完全静态，从Map式的API变成申明式API（@Module），生成的代码更优雅高效；而且一旦出错我们在编译期间就能发现。所以Dagger2对开发者的更加友好了，当然Dagger2也因此丧失了一些灵活性，但总体来说利还是远远大于弊的。</p>

<p>　　前面提到这种A B C D E连续依赖的问题，一旦E的创建方式发生了改变就会引发连锁反应，可能会导致A B C D都需要做针对性的修改；但是骚年，你以为为这仅仅是工作量的问题吗？更可怕的是我们创建A时需要按顺序先创建E D C B四个对象，而且必须保证顺序上是正确的。Dagger2就很好的解决了这一问题（不只是Dagger2，在其他DI框架中开发者同样不需要关注这些问题）。</p>

<h2 id="toc_0">Dagger2注解</h2>

<p>　　开篇我们就提到Dagger2是基于Java注解来实现依赖注入的，那么在正式使用之前我们需要先了解下Dagger2中的注解。Dagger2使用过程中我们通常接触到的注解主要包括：@Inject, @Module, @Provides, @Component, @Qulifier, @Scope, @Singleten。</p>

<ul>
<li><p>@Inject：@Inject有两个作用，一是用来标记需要依赖的变量，以此告诉Dagger2为它提供依赖；二是用来标记构造函数，Dagger2通过@Inject注解可以在需要这个类实例的时候来找到这个构造函数并把相关实例构造出来，以此来为被@Inject标记了的变量提供依赖；</p></li>
<li><p>@Module：@Module用于标注提供依赖的类。你可能会有点困惑，上面不是提到用@Inject标记构造函数就可以提供依赖了么，为什么还需要@Module？很多时候我们需要提供依赖的构造函数是第三方库的，我们没法给它加上@Inject注解，又比如说提供以来的构造函数是带参数的，如果我们之所简单的使用@Inject标记它，那么他的参数又怎么来呢？@Module正是帮我们解决这些问题的。</p></li>
<li><p>@Provides：@Provides用于标注Module所标注的类中的方法，该方法在需要提供依赖时被调用，从而把预先提供好的对象当做依赖给标注了@Inject的变量赋值；</p></li>
<li><p>@Component：@Component用于标注接口，是依赖需求方和依赖提供方之间的桥梁。被Component标注的接口在编译时会生成该接口的实现类（如果@Component标注的接口为CarComponent，则编译期生成的实现类为DaggerCarComponent）,我们通过调用这个实现类的方法完成注入；</p></li>
<li><p>@Qulifier：@Qulifier用于自定义注解，也就是说@Qulifier就如同Java提供的几种基本元注解一样用来标记注解类。我们在使用@Module来标注提供依赖的方法时，方法名我们是可以随便定义的（虽然我们定义方法名一般以provide开头，但这并不是强制的，只是为了增加可读性而已）。那么Dagger2怎么知道这个方法是为谁提供依赖呢？答案就是返回值的类型，Dagger2根据返回值的类型来决定为哪个被@Inject标记了的变量赋值。但是问题来了，一旦有多个一样的返回类型Dagger2就懵逼了。@Qulifier的存在正式为了解决这个问题，我们使用@Qulifier来定义自己的注解，然后通过自定义的注解去标注提供依赖的方法和依赖需求方（也就是被@Inject标注的变量），这样Dagger2就知道为谁提供依赖了。----一个更为精简的定义：当类型不足以鉴别一个依赖的时候，我们就可以使用这个注解标示；</p></li>
<li><p>@Scope：@Scope同样用于自定义注解，我能可以通过@Scope自定义的注解来限定注解作用域，实现局部的单例；</p></li>
<li><p>@Singleton：@Singleton其实就是一个通过@Scope定义的注解，我们一般通过它来实现全局单例。但实际上它并不能提前全局单例，是否能提供全局单例还要取决于对应的Component是否为一个全局对象。</p></li>
</ul>

<p>　　我们提到@Inject和@Module都可以提供依赖，那如果我们即在构造函数上通过标记@Inject提供依赖，有通过@Module提供依赖Dagger2会如何选择呢？具体规则如下：</p>

<ul>
<li>步骤1：首先查找@Module标注的类中是否存在提供依赖的方法。</li>
<li>步骤2：若存在提供依赖的方法，查看该方法是否存在参数。
a：若存在参数，则按从步骤1开始依次初始化每个参数；
b：若不存在，则直接初始化该类实例，完成一次依赖注入。</li>
<li>步骤3：若不存在提供依赖的方法，则查找@Inject标注的构造函数，看构造函数是否存在参数。
a：若存在参数，则从步骤1开始依次初始化每一个参数
b：若不存在，则直接初始化该类实例，完成一次依赖注入。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dagger2 使用详解(1)--依赖注入]]></title>
    <link href="m78snail.com/14839485567053.html"/>
    <updated>2017-01-09T15:55:56+08:00</updated>
    <id>m78snail.com/14839485567053.html</id>
    <content type="html"><![CDATA[
<p>　　Dagger-匕首，鼎鼎大名的Square公司旗下又一把利刃（没错！还有一把黄油刀，唤作ButterKnife）；故此给本篇取名神兵利器Dagger2。</p>

<p>　　Dagger2起源于Dagger，是一款基于Java注解来实现的完全在编译阶段完成依赖注入的开源库，主要用于模块间解耦、提高代码的健壮性和可维护性。Dagger2在编译阶段通过apt利用Java注解自动生成Java代码，然后结合手写的代码来自动帮我们完成依赖注入的工作。</p>

<span id="more"></span><!-- more -->

<p>　　起初Square公司受到Guice的启发而开发了Dagger，但是Dagger这种半静态半运行时的框架还是有些性能问题（虽说依赖注入是完全静态的，但是其有向无环图(Directed Acyclic Graph)还是基于反射来生成的，这无论在大型的服务端应用还是在Android应用上都不是最优方案）。因此Google工程师Fork了Dagger项目，对它进行了改造。于是变演变出了今天我们要讨论的Dagger2，所以说Dagger2其实就是高配版的Dagger。</p>

<h2 id="toc_0">依赖注入（Dependency Injection）</h2>

<p>那么什么是依赖注入呢？在解释这个概念前我们先看一小段代码：</p>

<pre><code>public class Car{

    private Engine engine;

    public Car(){
        engine = new Engine();
    }
}
</code></pre>

<p>　　这段Java代码中Car类持有了对Engine实例的引用，我们称之为Car类对Engine类有一个依赖。而依赖注入则是指通过注入的方式实现类与类之间的依赖，下面是常见的三种依赖注入的方式：</p>

<p><strong>1、构造注入：通过构造函数传参给依赖的成员变量赋值，从而实现注入。</strong></p>

<pre><code>public class Car{

    private Engine engine;

    public Car(Engine engine){
        this.engine = engine;
    }
}
</code></pre>

<p><strong>2、接口注入：实现接口方法，同样以传参的方式实现注入。</strong></p>

<pre><code>public interface Injection&lt;T&gt;{

    void inject(T t);
}

public class Car implements Injection&lt;Engine&gt;{

    private Engine engine;

    public Car(){}

    public void inject(Engine engine){
        this.engine = engine;
    }
}
</code></pre>

<p><strong>3、注解注入：使用Java注解在编译阶段生成代码实现注入或者是在运行阶段通过反射实现注入。</strong></p>

<pre><code>public class Car{

    @Inject
    Engine engine;

    public Car(){}
}
</code></pre>

<p>　　前两种注入方式需要我们编写大量的模板代码，而机智的Dagger2则是通过Java注解在编译期来实现依赖注入的。</p>

<h2 id="toc_1">为什么需要依赖注入</h2>

<p>　　我们之所是要依赖注入，最重要的就是为了解耦，达到高内聚低耦合的目的，保证代码的健壮性、灵活性和可维护性。</p>

<p>下面我们看看同一个业务的两种实现方案：</p>

<p><strong>1、方案A</strong></p>

<pre><code>public class Car{

    private Engine engine;
    private List&lt;Wheel&gt; wheels;

    public Car(){
        engine = new Engine();
        wheels = new ArrayList&lt;&gt;();
        for(int i = 0; i &lt; 4; i++){
            wheels.add(new Wheel());
        }
    }

    public void start{
        System.out.println(&quot;启动汽车&quot;);
    }
}

public class CarTest{

    public static void main(String[] args){
        Car car = new Car();
        car.start();
    }
} 
</code></pre>

<p><strong>2、方案B</strong></p>

<pre><code>public class Car{

    private Engine engine;
    private List&lt;Wheel&gt; wheels;

    public Car(Engine engine, List&lt;Wheel&gt; wheels){
        this.engine = engine;
        this.wheels = wheels;
    }

    public void start{
        System.out.println(&quot;启动汽车&quot;);
    }
}

public class CarTest{

    public static void main(String[] args){

        Engine engine = new Engine();
        List&lt;Wheel&gt; wheels = new ArrayList&lt;&gt;();
        for(int i = 0; i &lt; 4; i++){
            wheels.add(new Wheel());
        }
        Car car = new Car(engine, wheels);
        car.start();
    }
}
</code></pre>

<p>　　方案A：由于没有依赖注入，因此需要我们自己是在Car的构造函数中创建Engine和Wheel对象。</p>

<p>　　方案B：我们手动以构造函数的方式注入依赖，将engine和wheels作为参数传入而不是在Car的构造函数中去显示的创建。</p>

<p>　　方案A明显丧失了灵活性，一切依赖都是在Car类的内部创建，Car与Engine和Wheel严重耦合。一旦Engine或者Wheel的创建方式发生了改变，我们就必须要去修改Car类的构造函数（比如说现在创建Wheel实例的构造函数改变了，需要传入Rubber（橡胶）了）；另外我们也没办法替换动态的替换依赖实例（比如我们想把Car的Wheel（轮胎）从邓禄普（轮胎品牌）换成米其林（轮胎品牌）的）。这类问题在大型的商业项目中则更加严重，往往A依赖B、B依赖C、C依赖D、D依赖E；一旦稍有改动便牵一发而动全身，想想都可怕！而依赖注入则很好的帮我们解决了这一问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxJava 你好！]]></title>
    <link href="m78snail.com/14829068226408.html"/>
    <updated>2016-12-28T14:33:42+08:00</updated>
    <id>m78snail.com/14829068226408.html</id>
    <content type="html"><![CDATA[
<p>　　前段时间为 gank.io（干货集中营）网站开发的一款App,采用最流行的Rx全家桶（RxJava+RxAndroid+Retroift）。从开始尝试Rx到现在写出第一个程序，我查阅了很多资料，也踩了很多坑，希望在此记录一下，如果能帮到别人就更好了。</p>

<span id="more"></span><!-- more -->

<p>　　<br/>
　　此篇文章中的代码，都来自于<a href="https://github.com/M78Snail/GoGank">https://github.com/M78Snail/GoGank</a>，这是为<a href="gank.io">gank.io</a>(干货集中营)开发的一款手机App,有兴趣的朋友可以到<a href="http://fir.im/fjke">http://fir.im/fjke</a>下载下来尝试一下。<br/>
　　<img src="media/14827189898326/14827238912458.gif" alt="" class="mw_img_center" style="width:300px;display: block; clear:both; margin: 0 auto;"/></p>

<p>　　本系列文章针对的是项目实战，就不在此啰嗦Rx介绍这些了，我希望谈以下几点：<br/>
　　　</p>

<blockquote>
<ol>
<li>Retroift2解析与okhttp的配合</li>
<li>Retroift2与RxJava的结合</li>
<li>RxJava的常用操作符</li>
</ol>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EasyAndroid (Android面试复习)]]></title>
    <link href="m78snail.com/14779863113216.html"/>
    <updated>2016-11-01T15:45:11+08:00</updated>
    <id>m78snail.com/14779863113216.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">一、项目简介</h2>

<p>　　<a href="https://github.com/M78Snail/EasyAndroid">项目源码：EasyAndroid</a><br/>
　　EasyAndroid是一款专门面向Android开发者的面试复习与关注业内动态的手机App，里面包含知识体系，业内动态，开发技术周报三大模块。<br/>
　　<br/>
<strong>特点：</strong></p>

<ul>
<li><p>知识点归类明细，每一个知识点采用的博文都是经过精心的挑选和改进，确保一个知识点只保留一篇博文。</p></li>
<li><p>博文采用了缓存机制，会根据不同网络环境调整缓存存活时间，给使用者一个良好的体验。</p></li>
<li><p>提供业内动态新闻查看功能，数据爬取自CSDN，提供新闻缓存，方便随时查看。</p></li>
<li><p>每周会提供安卓开发周报，提供给用户最新的开发技术。</p></li>
</ul>

<span id="more"></span><!-- more -->

<p><img src="media/14737385475257/14738207920248.jpg" alt="" class="mw_img_center" style="width:300px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_1">二、第三方引用</h2>

<p>1、<a href="https://github.com/daimajia/AndroidSwipeLayout">Swipelayout下拉刷新</a></p>

<p>2、<a href="http://www.bmob.cn/">Bmob移动云服务</a></p>

<p>3、<a href="https://github.com/orhanobut/logger">Logger调试日志插件</a></p>

<p>4、<a href="https://github.com/astuetz/PagerSlidingTabStrip">PagerSlidingTabStrip导航</a></p>

<h2 id="toc_2">三、运行截图</h2>

<p><img src="media/14738219571613/14738389372531.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android技术积累:开发规范]]></title>
    <link href="m78snail.com/14779857522261.html"/>
    <updated>2016-11-01T15:35:52+08:00</updated>
    <id>m78snail.com/14779857522261.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">一. 命名规范</h2>

<h3 id="toc_1">1. 包命名</h3>

<p>域名反写+项目名称+模块名称，全部单词用小写字母。<br/>
例如，我的KAndroid项目的Model模块包名如下：</p>

<pre><code>me.keeganlee.kandroid.model
</code></pre>

<h3 id="toc_2">2. 类和接口命名</h3>

<p>使用大驼峰规则，用名词或名词词组命名，每个单词的首字母大写。<br/>
以下为几种常用类的命名：</p>

<pre><code>activity类，命名以Activity为后缀，如：LoginActivity
fragment类，命名以Fragment为后缀，如：ShareDialogFragment
service类，命名以Service为后缀，如：DownloadService
adapter类，命名以Adapter为后缀，如：CouponListAdapter
工具类，命名以Util为后缀，如：EncryptUtil
模型类，命名以BO为后缀，如：CouponBO
接口实现类，命名以Impl为后缀，如：ApiImpl
</code></pre>

<span id="more"></span><!-- more -->

<h3 id="toc_3">3. 方法命名</h3>

<p>使用小驼峰规则，用动词命名，第一个单词的首字母小写，其他单词的首字母大写。<br/>
以下为几种常用方法的命名：</p>

<pre><code>初始化方法，命名以init开头，例：initView
按钮点击方法，命名以to开头，例：toLogin
设置方法，命名以set开头，例：setData
具有返回值的获取方法，命名以get开头，例：getData
通过异步加载数据的方法，命名以load开头，例：loadData
布尔型的判断方法，命名以is或has，或具有逻辑意义的单词如equals，例：isEmpty
</code></pre>

<h3 id="toc_4">4. 控件缩写</h3>

<table>
<thead>
<tr>
<th style="text-align: center">控件</th>
<th style="text-align: center">缩写</th>
<th style="text-align: center">控件</th>
<th style="text-align: center">缩写</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">TextView</td>
<td style="text-align: center">txt</td>
<td style="text-align: center">ImageButton</td>
<td style="text-align: center">ibtn</td>
</tr>
<tr>
<td style="text-align: center">EditText</td>
<td style="text-align: center">edt</td>
<td style="text-align: center">ListView</td>
<td style="text-align: center">list</td>
</tr>
<tr>
<td style="text-align: center">Button</td>
<td style="text-align: center">btn</td>
<td style="text-align: center">RadioButton</td>
<td style="text-align: center">rbtn</td>
</tr>
<tr>
<td style="text-align: center">ImageView</td>
<td style="text-align: center">img</td>
<td style="text-align: center">SeekBar</td>
<td style="text-align: center">seek</td>
</tr>
<tr>
<td style="text-align: center">RadioGroup</td>
<td style="text-align: center">group</td>
<td style="text-align: center">Spinner</td>
<td style="text-align: center">spinner</td>
</tr>
<tr>
<td style="text-align: center">ProgressBar</td>
<td style="text-align: center">progress</td>
<td style="text-align: center">TableRow</td>
<td style="text-align: center">row</td>
</tr>
<tr>
<td style="text-align: center">CheckBox</td>
<td style="text-align: center">chk</td>
<td style="text-align: center">RelativeLayout</td>
<td style="text-align: center">rlayout</td>
</tr>
<tr>
<td style="text-align: center">TableLayout</td>
<td style="text-align: center">table</td>
<td style="text-align: center">SearchView</td>
<td style="text-align: center">search</td>
</tr>
<tr>
<td style="text-align: center">LinearLayout</td>
<td style="text-align: center">llayout</td>
<td style="text-align: center">TabWidget</td>
<td style="text-align: center">widget</td>
</tr>
<tr>
<td style="text-align: center">ScrollView</td>
<td style="text-align: center">scroll</td>
<td style="text-align: center">TabHost</td>
<td style="text-align: center">host</td>
</tr>
</tbody>
</table>

<h3 id="toc_5">5. 常量命名</h3>

<p>全部为大写单词，单词之间用下划线分开。</p>

<pre><code>public final static int PAGE_SIZE = 20;
</code></pre>

<h3 id="toc_6">6. 变量命名</h3>

<p>{范围描述+}意义描述+类型描述的组合，用驼峰式，首字母小写。</p>

<pre><code>private TextView headerTitleTxt; // 标题栏的标题
private Button loginBtn; // 登录按钮
private CouponBO couponBO; // 券实例
</code></pre>

<h3 id="toc_7">7. 控件id命名</h3>

<p>控件缩写_{范围_}意义，范围可选，只在有明确定义的范围内才需要加上。</p>

<pre><code>&lt;!-- 这是标题栏的标题 --&gt;
    &lt;TextView
    android:id=&quot;@+id/txt_header_title&quot;
    ... /&gt;

&lt;!-- 这是登录按钮 --&gt;
    &lt;Button
    android:id=&quot;@+id/btn_login&quot;
    ... /&gt;
</code></pre>

<h3 id="toc_8">8. layout命名</h3>

<p>组件类型_{范围_}功能，范围可选，只在有明确定义的范围内才需要加上。<br/>
以下为几种常用的组件类型命名：</p>

<pre><code>activity_{范围_}功能，为Activity的命名格式
fragment_{范围_}功能，为Fragment的命名格式
dialog_{范围_}功能，为Dialog的命名格式
item_list_{范围_}功能，为ListView的item命名格式
item_grid_{范围_}功能，为GridView的item命名格式
header_list_{范围_}功能，为ListView的HeaderView命名格式
footer_list_{范围_}功能，为ListView的FooterView命名格式
</code></pre>

<h3 id="toc_9">9. strings的命名</h3>

<p>类型_{范围_}功能，范围可选。<br/>
以下为几种常用的命名：</p>

<pre><code>页面标题，命名格式为：title_页面
按钮文字，命名格式为：btn_按钮事件
标签文字，命名格式为：label_标签文字
选项卡文字，命名格式为：tab_选项卡文字
消息框文字，命名格式为：toast_消息
编辑框的提示文字，命名格式为：hint_提示信息
图片的描述文字，命名格式为：desc_图片文字
对话框的文字，命名格式为：dialog_文字
menu的item文字，命名格式为：action_文字
</code></pre>

<h3 id="toc_10">10. colors的命名</h3>

<p>前缀{_控件}{_范围}{_后缀}，控件、范围、后缀可选，但控件和范围至少要有一个。</p>

<pre><code>背景颜色，添加bg前缀
文本颜色，添加text前缀
分割线颜色，添加div前缀
区分状态时，默认状态的颜色，添加normal后缀
区分状态时，按下时的颜色，添加pressed后缀
区分状态时，选中时的颜色，添加selected后缀
区分状态时，不可用时的颜色，添加disable后缀
</code></pre>

<h3 id="toc_11">11. drawable的命名</h3>

<p>前缀{_控件}{_范围}{_后缀}，控件、范围、后缀可选，但控件和范围至少要有一个。</p>

<pre><code>图标类，添加ic前缀
背景类，添加bg前缀
分隔类，添加div前缀
默认类，添加def前缀
区分状态时，默认状态，添加normal后缀
区分状态时，按下时的状态，添加pressed后缀
区分状态时，选中时的状态，添加selected后缀
区分状态时，不可用时的状态，添加disable后缀
多种状态的，添加selector后缀（一般为ListView的selector或按钮的selector）
</code></pre>

<h3 id="toc_12">12. 动画文件命名</h3>

<p>动画类型_动画方向。</p>

<pre><code>fade_in，淡入
fade_out，淡出
push_down_in，从下方推入
push_down_out，从下方推出
slide_in_from_top，从头部滑动进入
zoom_enter，变形进入
shrink_to_middle，中间缩小
</code></pre>

<h2 id="toc_13">二. 注释规范</h2>

<h3 id="toc_14">1. 文件头注释</h3>

<pre><code>文件顶部统一添加版权声明，声明的格式如下：

/**
 * Copyright (c) 2015. Keegan小钢 Inc. All rights reserved.
 */
</code></pre>

<h3 id="toc_15">2. 类和接口注释</h3>

<p>类和接口统一添加javadoc注释，格式如下：</p>

<pre><code>/**
 * 类或接口的描述信息
 *
 * @author ${USER}
 * @date ${DATE}
 */
</code></pre>

<h3 id="toc_16">3. 方法注释</h3>

<p>下面几种方法，都必须添加javadoc注释，说明该方法的用途和参数说明，以及返回值的说明。</p>

<p>(1).接口中定义的所有方法<br/>
(2).抽象类中自定义的抽象方法<br/>
(3).抽象父类的自定义公用方法<br/>
(4).工具类的公用方法</p>

<pre><code>/**
  * 登录
  *
  * @param loginName 登录名
  * @param password  密码
  * @param listener  回调监听器
  */
public void login(String loginName, String password, ActionCallbackListener&lt;Void&gt; listener);
</code></pre>

<h3 id="toc_17">4. 变量和常量注释</h3>

<p>下面几种情况下的常量和变量，都要添加注释说明，优先采用右侧//来注释，若注释说明太长则在上方添加注释。</p>

<p>(1).接口中定义的所有常量<br/>
 (2).公有类的公有常量<br/>
 (3).枚举类定义的所有枚举常量<br/>
 (4).实体类的所有属性变量</p>

<pre><code>public static final int TYPE_CASH = 1; // 现金券
public static final int TYPE_DEBIT = 2; // 抵扣券
public static final int TYPE_DISCOUNT = 3; // 折扣券
private int id;// 券id
private String name;// 券名称
private String introduce;// 券简介
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[镇远旅行游记]]></title>
    <link href="m78snail.com/14779858228537.html"/>
    <updated>2016-11-01T15:37:02+08:00</updated>
    <id>m78snail.com/14779858228537.html</id>
    <content type="html"><![CDATA[
<p>2016.8.5镇远旅游小记。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">第一天 入住酒店 观夜景 吃烤鱼</h2>

<ul class="example-orbit" data-orbit style="height: 120px;">
  <li>
    <img src="media/14708809297450/14708821760631.jpg" alt="" />
    <div class="orbit-caption">山地水城驿站 1</div>
  </li>
  <li>
    <img src="media/14708809297450/14708822552032.jpg" alt="" />
    <div class="orbit-caption">江景房 2</div>
  </li>
  <li>
    <img src="media/14708809297450/14708844285072.jpg" alt="" />
    <div class="orbit-caption"> 江边烧烤街 3</div>
  </li>
</ul>

<h2 id="toc_1">第二天 游舞阳河</h2>

<div class="large-column">
<a data-orbit-link="headline-1" class="small button">
  舞阳河石碑
</a>
<a data-orbit-link="headline-2" class="small button">
  天眼石
</a>
<a data-orbit-link="headline-3" class="small button">
  舞阳河江景
</a>
<a data-orbit-link="headline-4" class="small button">
  凤凰石
</a>

<div class="orbt-container">
<ul class="example-orbit-content" data-orbit style="height: 58px;">
  <li data-orbit-slide="headline-1">
    <div>
      <img src="media/14708809297450/14708846320662.jpg" alt="" />
    </div>
  </li>
  <li data-orbit-slide="headline-2">
    <div>
      <img src="media/14708809297450/14708846853058.jpg" alt="" />
    </div>
  </li>
  <li data-orbit-slide="headline-3">
    <div>
      <img src="media/14708809297450/14708847291929.jpg" alt="" />
    </div>
  </li>
  <li data-orbit-slide="headline-4">
    <div>
      <img src="media/14708809297450/14708847758845.jpg" alt="" />
    </div>
  </li>
</ul>
</div>
</div>

<h2 id="toc_2">第三天 高过河漂流</h2>

<p><img src="media/14708809297450/14708852478635.jpg" alt=""/></p>

<p>由于怕手机进水，只照了一张出行前的照片。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实用笔记－WebView大讲堂（二）～性能优化]]></title>
    <link href="m78snail.com/14779857522080.html"/>
    <updated>2016-11-01T15:35:52+08:00</updated>
    <id>m78snail.com/14779857522080.html</id>
    <content type="html"><![CDATA[
<p>上一节我总结了下WebView的实用用法：<a href="http://m78star.com/14693271804281.html">实用笔记－WebView大讲堂</a>。这一节我想总结下针对WebView的优化。</p>

<pre><code>1. WebView缓存机制
2. 几种缓存方式的实现
3. 其他的缓存策略
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_0">一 . Android WebView缓存机制</h2>

<p>WebView中存在着两种缓存：网页数据缓存（网页数据，url等）、H5缓存（H5代码缓存数据）</p>

<p>不同的缓存数据会保存在不同的文件目录下.<br/>
当我们加载Html时候，会在我们data/应用package下生成database与cache两个文件夹: </p>

<p>我们请求的Url记录是保存在webviewCache.db里，而url的内容是保存在webviewCache文件夹下。 <br/>
<img src="media/14694992191842/14695000993706.jpg" alt=""/></p>

<p>我们需要首先确保这里设置了缓存可用，才可以继续设置使用何种缓存策略。</p>

<p>下面我们来看一下webview的五种缓存模式： </p>

<pre><code>LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据 
LOAD_DEFAULT: 根据cache-control决定是否从网络上取数据。 
LOAD_CACHE_NORMAL: API level 17中已经废弃, 从API level 11开始作用同LOAD_DEFAULT模式 
LOAD_NO_CACHE: 不使用缓存，只从网络获取数据. 
LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。
</code></pre>

<ul>
<li>几种缓存方式的实现</li>
</ul>

<p>（1）使用LOAD_CACHE_ELSE_NETWORK缓存模式，这样需要在APP退出的时候清除webview缓存，但是这样做有一个弊端就是如果当前App已经是打开状态，网页内容有更新的话不会看到；</p>

<p>（2）使用LOAD_DEFAULT这种缓存方式，数据从缓存中获取还是从网络中获取根据H5页面的参数判断，这样做的好处是可以动态的处理更新内容；</p>

<p>设置缓存</p>

<pre><code>mWebView.getSettings().setJavaScriptEnabled(true); 

mWebView.getSettings().setRenderPriority(RenderPriority.HIGH);

//设置 缓存模式 
mWebView.getSettings().setCacheMode(WebSettings.LOAD_DEFAULT);  

// 开启 DOM storage API 功能     
mWebView.getSettings().setDomStorageEnabled(true); 

//开启 database storage API 功能 
mWebView.getSettings().setDatabaseEnabled(true);  

String cacheDirPath = getFilesDir().getAbsolutePath()+APP_CACAHE_DIRNAME; 
//      String cacheDirPath = getCacheDir().getAbsolutePath()+Constant.APP_DB_DIRNAME; 

Log.i(TAG, &quot;cacheDirPath=&quot;+cacheDirPath); 

//设置数据库缓存路径 
mWebView.getSettings().setDatabasePath(cacheDirPath); 

//设置  Application Caches 缓存目录 
mWebView.getSettings().setAppCachePath(cacheDirPath); 

//开启Application Caches 功能 
mWebView.getSettings().setAppCacheEnabled(true);
</code></pre>

<ul>
<li>退出App时清除缓存</li>
</ul>

<pre><code>//清理Webview缓存数据库 
try { 
    deleteDatabase(&quot;webview.db&quot;);
    deleteDatabase(&quot;webviewCache.db&quot;); 
    } catch (Exception e) { 
            e.printStackTrace(); 
} 

//WebView 缓存文件 
File appCacheDir = new File(getFilesDir().getAbsolutePath()+APP_CACAHE_DIRNAME); 
Log.e(TAG, &quot;appCacheDir path=&quot;+appCacheDir.getAbsolutePath()); 

File webviewCacheDir = new File(getCacheDir().getAbsolutePath()+&quot;/webviewCache&quot;); 
Log.e(TAG, &quot;webviewCacheDir path=&quot;+webviewCacheDir.getAbsolutePath()); 

//删除webview 缓存目录 
if(webviewCacheDir.exists()){ 
     deleteFile(webviewCacheDir); 
} 
//删除webview 缓存 缓存目录 
if(appCacheDir.exists()){ 
     deleteFile(appCacheDir); 
}
</code></pre>

<h2 id="toc_1">二 .其他的缓存策略</h2>

<p>网页在加载的时候暂时不加载图片，当所有的HTML标签加载完成时在加载图片具体的做法如下初始化webview的时候设置不加载图片</p>

<pre><code>webSettings.setBlockNetworkImage(true);
</code></pre>

<p>然后在html标签加载完成之后在加载图片内容:</p>

<pre><code>@Override
    public void onPageFinished(WebView view, String url) {
        super.onPageFinished(view, url);
        mWebView.getSettings().setBlockNetworkImage(false);   
    }
</code></pre>

<p>关于更多的WebView可以参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51820139">WebView问题集锦</a></p>

<p>欢迎大家留言，点赞。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实用笔记－WebView大讲堂（一）]]></title>
    <link href="m78snail.com/14779857521960.html"/>
    <updated>2016-11-01T15:35:52+08:00</updated>
    <id>m78snail.com/14779857521960.html</id>
    <content type="html"><![CDATA[
<p>最近手头的项目界面要改成HTML5的，以前自己对于WebView仅仅只是一知半解，这次想好好总结下，我的博客不喜欢讲太多没用的东西，我追求实用主义，所以我的技术博客，永远只有两个主题：怎么用和怎么优化。典型的拿来主义。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">怎么用？</h2>

<ul>
<li>WebView 基本操作</li>
<li>WebView 下载文件</li>
<li>WebView 注入cookie信息</li>
<li>Webview 中native与js交互</li>
</ul>

<p>暂时只讲解一下这四个方面，以后再添加。</p>

<h3 id="toc_1">一. WebView 基本操作</h3>

<pre><code>mWebView.setWebViewClient() // 帮助WebView处理各种通知、请求事件的

mWebView.setWebChromeClient();// 主要处理解析，渲染网页等浏览器做的事情器

</code></pre>

<p>上面两个方法是你加载一个网页肯定会实现的两个方法。</p>

<pre><code>mWebView.setWebChromeClient(new WebChromeClient(){
           @Override
            public void onReceivedTitle(WebView view, String title) {
                super.onReceivedTitle(view, title);
                txtTitle.setText(title);
            }
        });
 
mWebView.setWebViewClient(new WebViewClient(){
            @Override
            public boolean shouldOverrideUrlLoading(WebView view, String url) {
                view.loadUrl(url);
                return super.shouldOverrideUrlLoading(view, url);
            }
        });
</code></pre>

<p>例子：<br/>
加载百度主页，包含返回按钮，页面地址，刷新。如图：<br/>
<img src="media/14693271804281/14694114281052.jpg" alt="" class="mw_img_center" style="width:200px;display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_2">二. WebView 下载文件</h3>

<p>在WebView的网页里面我们可能要点击链接进行下载，这时候我们首先要新建一个DownloadListener，然后在onDownloadStart（）方法里面我们有两种方式进行下载：</p>

<pre><code>1. 直接调用系统浏览器进行下载
2. 自己编写或使用其他网络框架进行下载文件
</code></pre>

<h4 id="toc_3">(1)调用系统浏览器</h4>

<pre><code>class MyDownload implements DownloadListener {

        @Override
        public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long l) {
            Uri uri=Uri.parse(url);
            Intent intent=new Intent(Intent.ACTION_VIEW,uri);
            startActivity(intent);
        }
 }
    
mWebView.setDownloadListener(new MyDownload());

</code></pre>

<h4 id="toc_4">(2)自定义下载</h4>

<p>使用普通文件下载方式即可，此处不给出代码了。</p>

<h3 id="toc_5">三. WebView 注入cookie信息</h3>

<p>关于Cookie我就不说了，以登陆csdn作为示例直接说用法：<br/>
1. App在html页面登录<br/>
<img src="media/14693271804281/14694326778770.jpg" alt="" class="mw_img_center" style="width:200px;display: block; clear:both; margin: 0 auto;"/></p>

<pre><code>mWebView.setWebViewClient(new WebViewClient() {
            @Override
            public void onPageFinished(WebView view, String url) {
                super.onPageFinished(view, url);
                CookieManager cookieManager = CookieManager.getInstance();
                String cookie = cookieManager.getCookie(url);
                
            }
});
</code></pre>

<p>通过上面方法可以获取到登陆成功跳转页面以后服务器返回的Cookie,这辆我们可以通过SharedPreferences将Cookie信息保存起来</p>

<p>2.当你再一次进入该页面时，将Cookie通过下面的方法返回给服务器：</p>

<pre><code>private void syncCookie(Context context, String url, String oldcookie) {
        CookieSyncManager.createInstance(context);
        CookieManager cookieManager = CookieManager.getInstance();
        String cookie = cookieManager.getCookie(url);
        cookieManager.setAcceptCookie(true);
        cookieManager.setCookie(url,oldcookie);
        CookieSyncManager.getInstance().sync();
}
</code></pre>

<p>注意：syncCookie函数要在webview.load()之前调用</p>

<h3 id="toc_6">四. Webview 中native与js交互</h3>

<p>通过java代码与js代码直接相互调用的方式实现Android native与H5信息的相互，这里简单的介绍一下使用方式</p>

<h4 id="toc_7">native代码调用H5的js代码</h4>

<p>（1）在H5页面中添加一个js函数</p>

<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
function uu_click(clicked_id) {
    alert(clicked_id);
}
</code></pre>

<p>（2）在Native中通过java代码调用 <br/>
若这时候H5页面已经被加载到webview中,则可以通过java代码直接调用js函数：</p>

<pre><code>h5Fragment.mWebView.loadUrl(&quot;javascript:uu_click&quot; + &quot;(&#39;&quot; + clickId + &quot;&#39;)&quot;);
</code></pre>

<h4 id="toc_8">js代码调用java函数</h4>

<p>（1）首先在java端编写能够被js代码调用的java函数</p>

<ul>
<li>native方法的实现</li>
</ul>

<pre><code>/**
 * 自定义实现的native函数，可被js代码调用
 */
class JsInteration {
    ...
    @JavascriptInterface
        public void toastMessage(String message) {
            Toast.makeText(getActivity(), message, Toast.LENGTH_LONG).show();
        }
    ...
}
</code></pre>

<p>（2）在native中注入本地方法，供js调用；</p>

<pre><code>mWebView.addJavascriptInterface(new JsInteration(), &quot;control&quot;);
</code></pre>

<p>（3）在js代码中调用java代码：</p>

<pre><code>function reply_click(clicked_id {
    window.control.toastMessage(clicked_id)
}
</code></pre>

<p>关于WebView的四个基本用法就介绍到这里，再下一章会介绍WebView的优化。<br/>
欢迎留言讨论。<br/>
项目示例代码在：<a href="https://github.com/M78Snail/WebViewStudy">https://github.com/M78Snail/WebViewStudy</a></p>

]]></content>
  </entry>
  
</feed>
