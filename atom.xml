<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[m78snail]]></title>
  <link href="m78snail.com/atom.xml" rel="self"/>
  <link href="m78snail.com/"/>
  <updated>2017-03-21T21:38:03+08:00</updated>
  <id>m78snail.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法[三]·排序算法]]></title>
    <link href="m78snail.com/14901034610182.html"/>
    <updated>2017-03-21T21:37:41+08:00</updated>
    <id>m78snail.com/14901034610182.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">9. 二分查找，与变种二分查找。</h2>

<blockquote>
<p>二分搜索（binary search），也称折半搜索（half-interval search）、对数搜索（logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>

<p>　　除直接在一个数组中查找元素外，可用在插入排序中。</p>
</blockquote>

<p><strong>复杂度分析</strong></p>

<p><img src="media/14900925568521/14901005309904.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<ul>
<li><p>时间复杂度<br/>
　　折半搜索每次把搜索区域减少一半，时间复杂度为Ｏ(Log n) 。（n代表集合中元素的个数）</p></li>
<li><p>空间复杂度<br/>
　　  迭代：O(1)　　递归：O(log n)<br/>
　　<br/>
<strong>示例代码</strong></p></li>
</ul>

<pre><code>// 递归版本
int binary_search(const int arr[], int start, int end, int key) {
    if (start &gt; end)
        return -1;

    int mid = start + (end - start) / 2; //直接平均可能会溢位
    if (arr[mid] &gt; key)
        return binary_search(arr, start, mid - 1, key);
    if (arr[mid] &lt; key)
        return binary_search(arr, mid + 1, end, key);
    return mid; 
}
</code></pre>

<pre><code>// while循环
int binary_search(const int arr[], int start, int end, int key) {
    int mid;
    while (start &lt;= end) {
        mid = start + (end - start) / 2; //直接平均可能会溢位
        if (arr[mid] &lt; key)
            start = mid + 1;
        else if (arr[mid] &gt; key)
            end = mid - 1;
        else
            return mid; 
    }
    return -1;
}
</code></pre>

<p><strong>变种二分查找</strong><br/>
<strong>改变数组</strong></p>

<p>　　升序数组a经过循环右移后，二分查找给定元素x的位置。</p>

<p>如a={1,2,3,4,5,6,7}，循环移动后a={5,6,7,1,2,3,4}</p>

<p><strong>思路</strong><br/>
移动后的数组分为两部分，两部分内部都是升序排列的，中值mid必然属于这两部分之一。然后根据下标判断查找值是否属于这一部分，循环缩小mid值，直到arr[mid]等于查找值就返回。</p>

<p><strong>代码实现</strong></p>

<pre><code>public static void main(String[] args){
          int arr[]={5,6,7,1,2,3,4};
          int out = VariantBinaryFind(arr,arr.length-1,1);
          System.out.println(&quot;下标为： &quot;+ out);
      }
      /**
       * @param a  数组
       * @param len 数组长度
       * @param x 查找的元素
       * @return 返回查找值得下标，不存在返回 -1
       */
      public static int VariantBinaryFind(int arr[],int len,int x){
          int left = 0;
          int right = len;
          while(left&lt;=right){
              int mid = left + (right -left)/2;
              if(arr[mid]==x){
                  return mid;
              }
              if(arr[mid] &gt;= arr[left]) //mid在左边序列
                {  
                    if(arr[left] &gt; x || arr[mid] &lt; x)  
                        left = mid + 1;  //x在右边序列
                    else  
                        right = mid - 1;  //x在左边序列
                }  
                else //mid在右边序列
                {  
                    if(arr[right] &lt; x || arr[mid] &gt; x)  
                        right = mid - 1;  //x在左边序列
                    else  
                        left = mid + 1;  //x在右边序列
                }  
            }  
            return -1;  
      }
</code></pre>

<p>运行结果：<br/>
<img src="media/14900925568521/14901007638798.jpg" alt="" class="mw_img_center" style="width:100px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_1">10. 二叉树、B+树、AVL树、红黑树、哈夫曼树。</h2>

<h2 id="toc_2"><strong>二叉树</strong></h2>

<p>　　二叉树（Binary tree）是每个节点最多有两个子树的树结构。二叉树的子树有左右之分，次序不能颠倒。</p>

<p>　　二叉树的第i层至多有 这里写图片描述个结点； 　　深度为k的二叉树至多共有这里写图片描述个结点； 　　对任何一棵二叉树T，如果其终端结点数为这里写图片描述，度为2的节点数为 这里写图片描述，则 这里写图片描述。</p>

<p>　　与树不同，树的节点个数至少为1，而二叉树的节点个数可以为0；树中节点的最大度数没有限制，而二叉树节点的最大度数为2；树的节点无左、右之分，而二叉树的结点有左、右之分。</p>

<p><strong>B+树</strong></p>

<hr/>

<p>　　B+ 树是一种树数据结构，是一个<strong>n叉树</strong>，每个节点通常有多个孩子，一颗B+树包含<strong>根节点</strong>、<strong>内部节点</strong>和<strong>叶子节点</strong>。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。</p>

<p>　　B+ 树通常用于<strong>数据库</strong>和<strong>操作系统的文件系统</strong>中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为<strong>元数据索引</strong>。B+ 树的特点是能够保持<strong>数据稳定有序</strong>，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。<br/>
　　</p>

<p><strong>AVL树</strong></p>

<hr/>

<p>　　AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O（log n）。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>

<p>　　节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。<br/>
　　</p>

<p><strong>红黑树</strong></p>

<hr/>

<p>　　红黑树（Red Black Tree） 是一种自平衡二叉查找树，红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。</p>

<p>　　它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。<a href="https://github.com/Mr-YangCheng/ForAndroidInterview/blob/master/data%20structure/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D%20%E7%BA%A2%E9%BB%91%E6%A0%91.md">详情</a><br/>
　　<br/>
<strong>哈夫曼树</strong></p>

<hr/>

<p>　　哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的 路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。</p>

<p>　　树的带权路径长度记为WPL= (W1L1+W2L2+W3L3+...+WnLn)，N个权值Wi(i=1,2,...n)构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li(i=1,2,...n)。可以证明哈夫曼树的WPL是最小的。<br/>
　　<br/>
<strong>哈夫曼树的构造</strong></p>

<p>　　假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为： 　　 <br/>
①　将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；</p>

<p>②在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；</p>

<p>③从森林中删除选取的两棵树，并将新树加入森林；</p>

<p>④重复②、③步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</p>

<p><strong>哈夫曼编码</strong><br/>
　　哈夫曼编码是可变字长编码(VLC)的一种。该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码。</p>

<blockquote>
<p>　　有A,B,C,D,E五个字符，出现的频率（即权值）分别为5,4,3,2,1，对其进行哈夫曼编码。</p>
</blockquote>

<p>首先把A,B,C,D,E构造成一棵哈夫曼树（２.１有说明）；</p>

<p>通过从哈夫曼树根结点开始，对左子树分配代码“0”，右子树分配代码“1”，一直到达叶子结点为止，然后将从树根沿每条路径到达叶子结点的代码排列起来，便得到了哈夫曼编码。<br/>
<img src="media/14900925568521/14901015619752.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/><br/>
所以各字符对应的编码为：A-&gt;11,B-&gt;10,C-&gt;00,D-&gt;011,E-&gt;010</p>

<p>霍夫曼编码是一种无前缀编码。解码时不会混淆。其主要应用在数据压缩，加密解密等场合。</p>

<h2 id="toc_3">11. 二叉树的前中后续遍历：递归与非递归写法，层序遍历算法。</h2>

<p>　　遍历二叉树：L、D、R分别表示遍历左子树、访问根结点和遍历右子树，则先(根)序遍历二叉树的顺序是DLR，中(根)序遍历二叉树的顺序是LDR，后(根)序遍历二叉树的顺序是LRD。还有按层遍历二叉树。这些方法的时间复杂度都是O(n)，n为结点个数。<br/>
　　<img src="media/14900925568521/14901016474922.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/><br/>
用二叉树表示上述表达式：a+b*(c-d)-e/f</p>

<ul>
<li>先序遍历的序列是：-+a*b-cd/ef</li>
<li>中序遍历的序列是：a+b*c-d-e/f</li>
<li>后序遍历的序列是：abcd-*+ef/-
<strong>二叉树的存储</strong></li>
</ul>

<p><strong>1顺序存储</strong><br/>
　　二叉树可以用数组或线性表来存储，而且如果这是满二叉树，这种方法不会浪费空间。用这种紧凑排列，如果一个结点的索引为i，它的子结点能在索引2i+1和2i+2找到，并且它的父节点（如果有）能在索引floor((i-1)/2)找到（假设根节点的索引为0）。<br/>
　　<img src="media/14900925568521/14901017243395.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<p><strong>２二叉链表存储</strong><br/>
　　二叉树通常用树结点结构来存储。有时也包含指向唯一的父节点的指针。如果一个结点的子结点个数小于2，一些子结点指针可能为空值，或者为特殊的哨兵结点。 使用链表能避免顺序储存浪费空间的问题，算法和结构相对简单，但使用二叉链表，由于缺乏父链的指引，在找回父节点时需要重新扫描树得知父节点的节点地址。<br/>
<img src="media/14900925568521/14901018033160.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<p><strong>３三叉链表存储</strong><br/>
改进于二叉链表，增加父节点的指引，能更好地实现节点间的访问，不过算法相对复杂。 当二叉树用三叉链表表示时，有N个结点，就会有N+2个空指针。<br/>
<img src="media/14900925568521/14901018694156.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<p><strong>前中后续遍历（递归）</strong></p>

<pre><code>    /* 
     *前序遍历二叉树 
     * */  
    public void preOrder(Node node){  
        if(node != null){  
            System.out.print(node.data);  
            preOrder(node.leftChild);  
            preOrder(node.rightChild);  
        }  
    }  
    /* 
     *中序遍历二叉树 
     * */  
    public void inOrder(Node node){  
        if(node != null){  
            inOrder(node.leftChild);  
            System.out.print(node.data);  
            inOrder(node.rightChild);  
        }  
    }  
    /* 
     *后序遍历二叉树 
     * */  
    public void postOrder(Node node){  
        if(node != null){  
            postOrder(node.leftChild);  
            postOrder(node.rightChild);  
            System.out.print(node.data);              
    }  
</code></pre>

<p><strong>前中后续遍历（非递归）</strong></p>

<pre><code>   /** 
     *  
     * 【前序】
     * 利用栈实现循环先序遍历二叉树 
     * 这种实现类似于图的深度优先遍历（DFS） 
     * 维护一个栈，将根节点入栈，然后只要栈不为空，出栈并访问，接着依次将访问节点的右节点、左节点入栈。 
     * 这种方式应该是对先序遍历的一种特殊实现（看上去简单明了），但是不具备很好的扩展性，在中序和后序方式中不适用 
     */  
    public static void preOrderStack(Node root){  
        if(root==null)return;  
        Stack&lt;Node&gt; s=new Stack&lt;Node&gt;();  
        s.push(root);  
        while(!s.isEmpty()){  
            Node temp=s.pop();  
            System.out.println(temp.value);  
            if(temp.right!=null) s.push(temp.right);  
            if(temp.left!=null) s.push(temp.left);  
        }  
    } 
     /** 
     *  
     * 【中序】
     * 利用栈模拟递归过程实现循环中序遍历二叉树 
     * 访问的时间是在左子树都处理完直到null的时候出栈并访问。 
     */  
    public static void inOrderStack(Node root){  
        if(root==null)return;  
        Stack&lt;Node&gt; s=new Stack&lt;Node&gt;();  
        while(root!=null||!s.isEmpty()){  
            while(root!=null){  
                s.push(root);//先访问再入栈  
                root=root.left;  
            }  
            root=s.pop();  
            System.out.println(root.value);  
            root=root.right;//如果是null，出栈并处理右子树  
        }  
    }  
    /** 
     *  
     * 【后续】
     * 后序遍历不同于先序和中序，它是要先处理完左右子树，然后再处理根(回溯)，所以需要一个记录哪些节点已经被访问的结构(可以在树结构里面加一个标记)，这里可以用map实现 
     */  
    public static void postOrderStack(Node root){  
        if(root==null)return;  
        Stack&lt;Node&gt; s=new Stack&lt;Node&gt;();  
        Map&lt;Node,Boolean&gt; map=new HashMap&lt;Node,Boolean&gt;();   
        s.push(root);  
        while(!s.isEmpty()){  
            Node temp=s.peek();  
            if(temp.left!=null&amp;&amp;!map.containsKey(temp.left)){  
                temp=temp.left;  
                while(temp!=null){  
                    if(map.containsKey(temp))break;  
                    else s.push(temp);  
                    temp=temp.left;  
                }  
                continue;  
            }  
            if(temp.right!=null&amp;&amp;!map.containsKey(temp.right)){  
                s.push(temp.right);  
                continue;  
            }  
            Node t=s.pop();  
            map.put(t,true);  
            System.out.println(t.value);  
        }  
    }  
</code></pre>

<p><strong>广度优先遍历（层次遍历）</strong></p>

<pre><code>   /** 
     * @param root 树根节点 
     * 层序遍历二叉树，用队列实现，先将根节点入队列，只要队列不为空，然后出队列，并访问，接着讲访问节点的左右子树依次入队列 
     */  
    public static void levelTravel(Node root){  
        if(root==null)return;  
        Queue&lt;Node&gt; q=new LinkedList&lt;Node&gt;();  
        q.add(root);  
        while(!q.isEmpty()){  
            Node temp =  q.poll();  
            System.out.println(temp.value);  
            if(temp.left!=null)q.add(temp.left);  
            if(temp.right!=null)q.add(temp.right);  
        }  
    } 
</code></pre>

<h2 id="toc_4">12. 图的BFS与DFS算法，最小生成树prim算法与最短路径Dijkstra算法。</h2>

<p>图G是由顶点的有穷集合，以及顶点之间的关系组成，顶点的集合记为V，顶点之间的关系构成边的集合E，G=(V,E).</p>

<p>　　如果给图的每条边规定一个方向，那么得到的图称为有向图，其边也称为有向边。在有向图中，与一个节点相关联的边有出边和入边之分，而与一个有向边关联的两个点也有始点和终点之分。相反，边没有方向的图称为无向图。<br/>
<strong>图的遍历</strong></p>

<p>　　①　DFS（Depth First Search）深度优先搜索，为每个顶点设立一个“访问标志”。首先将图中每个顶点的访问标志设为 FALSE, 之后搜索图中每个顶点，如果未被访问，则以该顶点为起始点，进行遍历。</p>

<p>　　若当前访问的顶点的邻接顶点有未被访问的，则任选一个访问之。反之，退回到最近访问过的顶点；直到与起始顶点相通的全部顶点都访问完毕；</p>

<blockquote>
<p>　　遍历图的过程实质上是对每个顶点查找其邻接点的过程，所耗费的时间取决于所采用的存储结构。 对图中的每个顶点至多调用1次DFS算法，因为一旦某个顶点已访问过，则不再从它出发进行搜索。</p>
</blockquote>

<hr/>

<blockquote>
<p>邻接链表表示：查找每个顶点的邻接点所需时间为O(e)，e为边(弧)数，算法时间复杂度为O(n+e)</p>
</blockquote>

<hr/>

<blockquote>
<p>数组表示：查找每个顶点的邻接点所需时间为O(n2)，n为顶点数，算法时间复杂度为O(n2)</p>
</blockquote>

<p>②　BFS（Breadth First Search）广度优先遍历，从图的某一结点出发，首先依次访问该结点的所有邻接顶点 Vi1, Vi2, …, Vin 再按这些顶点被访问的先后次序依次访问与它们相邻接的所有未被访问的顶点，重复此过程，直至所有顶点均被访问为止。</p>

<p><strong>遍历代码（邻接矩阵）</strong></p>

<pre><code>// 邻接矩阵存储图
public class Graph {
    // 顶点数
    private int number = 9;
    // 记录顶点是否被访问
    private boolean[] flag;
    // 顶点
    private String[] vertexs = { &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot; };
    // 边
    private int[][] edges = { 
            { 0, 1, 0, 0, 0, 1, 1, 0, 0 }, 
            { 1, 0, 1, 0, 0, 0, 1, 0, 1 }, 
            { 0, 1, 0, 1, 0, 0, 0, 0, 1 },
            { 0, 0, 1, 0, 1, 0, 1, 1, 1 },
            { 0, 0, 0, 1, 0, 1, 0, 1, 0 }, 
            { 1, 0, 0, 0, 1, 0, 1, 0, 0 },
            { 0, 1, 0, 1, 0, 1, 0, 1, 0 },
            { 0, 0, 0, 1, 1, 0, 1, 0, 0 }, 
            { 0, 1, 1, 1, 0, 0, 0, 0, 0 } 
            };

    // 图的深度遍历操作(递归)
    void DFSTraverse() {
        flag = new boolean[number];
        for (int i = 0; i &lt; number; i++) {
            if (flag[i] == false) {// 当前顶点没有被访问
                DFS(i);
            }
        }
    }

    // 图的深度优先递归算法
    void DFS(int i) {
        flag[i] = true;// 第i个顶点被访问
        System.out.print(vertexs[i] + &quot; &quot;);
        for (int j = 0; j &lt; number; j++) {
            if (flag[j] == false &amp;&amp; edges[i][j] == 1) {
                DFS(j);
            }
        }
    }

    // 图的广度遍历操作
    void BFSTraverse() {
        flag = new boolean[number];
        Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();
        for (int i = 0; i &lt; number; i++) {
            if (flag[i] == false) {
                flag[i] = true;
                System.out.print(vertexs[i] + &quot; &quot;);
                queue.add(i);
                while (!queue.isEmpty()) {
                    int j = queue.poll();
                    for (int k = 0; k &lt; number; k++) {
                        if (edges[j][k] == 1 &amp;&amp; flag[k] == false) {
                            flag[k] = true;
                            System.out.print(vertexs[k] + &quot; &quot;);
                            queue.add(k);
                        }
                    }
                }
            }
        }
    }

    public static void main(String[] args) {
        Graph graph = new Graph();
        System.out.println(&quot;-----------DFS-----------------&quot;);
        graph.DFSTraverse();
        System.out.println();
        System.out.println(&quot;-----------BFS-----------------&quot;);
        graph.BFSTraverse();
    }
}
</code></pre>

<p>运行结果：<br/>
<img src="media/14900925568521/14901023008899.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/><br/>
**最小生成树prim算法<br/>
**<br/>
　　从单一顶点开始，普里姆算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。</p>

<ol>
<li><p>输入：一个加权连通图，其中顶点集合为V，边集合为E；</p></li>
<li><p>初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {}；</p></li>
<li><p>重复下列操作，直到Vnew = V：</p></li>
</ol>

<p>3.1 在集合E中选取权值最小的边（u, v），其中u为集合Vnew中的元素，而v则是V中没有加入Vnew的顶点（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）； 3.2 将v加入集合Vnew中，将（u, v）加入集合Enew中；<br/>
4. 输出：使用集合Vnew和Enew来描述所得到的最小生成树。</p>

<blockquote>
<p>此为原始的加权连通图。每条边一侧的数字代表其权值。</p>
</blockquote>

<p><img src="media/14900925568521/14901023734630.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<blockquote>
<p>顶点D被任意选为起始点。顶点A、B、E和F通过单条边与D相连。A是距离D最近的顶点，因此将A及对应边AD以高亮表示。<br/>
<img src="media/14900925568521/14901024582721.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<p>下一个顶点为距离D或A最近的顶点。B距D为9，距A为7，E为15，F为6。因此，F距D或A最近，因此将顶点F与相应边DF以高亮表示。<br/>
<img src="media/14900925568521/14901024899486.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<p>算法继续重复上面的步骤。距离A为7的顶点B被高亮表示。<br/>
<img src="media/14900925568521/14901025100075.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<p>在当前情况下，可以在C、E与G间进行选择。C距B为8，E距B为7，G距F为11。E最近，因此将顶点E与相应边BE高亮表示。<br/>
<img src="media/14900925568521/14901025319584.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/><br/>
这里，可供选择的顶点只有C和G。C距E为5，G距E为9，故选取C，并与边EC一同高亮表示。<br/>
<img src="media/14900925568521/14901025655571.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/><br/>
顶点G是唯一剩下的顶点，它距F为11，距E为9，E最近，故高亮表示G及相应边EG。<br/>
<img src="media/14900925568521/14901025837779.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/><br/>
现在，所有顶点均已被选取，图中绿色部分即为连通图的最小生成树。在此例中，最小生成树的权值之和为39。<br/>
<img src="media/14900925568521/14901025988208.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>
</blockquote>

<p><strong>Java代码实现</strong></p>

<pre><code>public class Prim {
    //结点集
    public static List&lt;Vertex&gt; vertexList = new ArrayList&lt;Vertex&gt;();
    //边集
    public static List&lt;Edge&gt; EdgeList = new ArrayList&lt;Edge&gt;();
    //已经访问过的结点集
    public static List&lt;Vertex&gt; containVertexList = new ArrayList&lt;Vertex&gt;();
    
    public static void main(String[] args) {
        primTree();
    }
    public static void primTree(){
        //初始化图
        buildGraph();
        //起始点
        Vertex start = vertexList.get(0);
        containVertexList.add(start);
        for(int n=0;n&lt;vertexList.size()-1;n++){
            //临时节点a
            Vertex temp = new Vertex(start.key);
            Edge tempedge = new Edge(start,start,1000);
            
            for(Vertex v : containVertexList){
                for(Edge e : EdgeList){
                    //找出相邻最小边
                    if(e.start==v &amp;&amp; !containVertex(e.end)){
                        if(e.Len&lt;tempedge.Len){
                            temp = e.end;
                            tempedge = e;
                        }
                    }
                }
            }
            //把该点加入
            containVertexList.add(temp);
        }
        
        //打印输出
        Iterator it = containVertexList.iterator();
        while(it.hasNext()){
            Vertex v =(Vertex) it.next();
            System.out.println(v.key);
        }
    }
    
    public static void buildGraph() {
        Vertex v1 = new Vertex(&quot;a&quot;);
        Prim.vertexList.add(v1);
        Vertex v2 = new Vertex(&quot;b&quot;);
        Prim.vertexList.add(v2);
        Vertex v3 = new Vertex(&quot;c&quot;);
        Prim.vertexList.add(v3);
        Vertex v4 = new Vertex(&quot;d&quot;);
        Prim.vertexList.add(v4);
        Vertex v5 = new Vertex(&quot;e&quot;);
        Prim.vertexList.add(v5);
        addEdge(v1, v2, 6);
        addEdge(v1, v3, 7);
        addEdge(v2, v3, 8);
        addEdge(v2, v5, 4);
        addEdge(v2, v4, 5);
        addEdge(v3, v4, 3);
        addEdge(v3, v5, 9);
        addEdge(v5, v4, 7);
        addEdge(v5, v1, 2);
        addEdge(v4, v2, 2);
    }
    public static void addEdge(Vertex a, Vertex b, int w) {
        Edge e = new Edge(a, b, w);
        Prim.EdgeList.add(e);
    }
    public static boolean containVertex(Vertex vte){
        for(Vertex v : containVertexList){
            if(v.key.equals(vte.key))
                return true;
        }
        return false;
    }
}
class Vertex {
    String key;
    Vertex(String key){
        this.key = key;
    }
}
class Edge{
    Vertex start;
    Vertex end;
    int Len;
    Edge(Vertex start,Vertex end,int key){
        this.start = start;
        this.end  = end;
        this.Len = key;
        
    }
}
</code></pre>

<p><strong>Dijkstra算法</strong></p>

<blockquote>
<p>　　使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树（一个节点到其他所有节点的最短路径）。该算法常用于路由算法或者作为其他图算法的一个子模块。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。<br/>
算法思想：</p>

<p>　　设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了）</p>

<p>　　第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。<br/>
　　</p>
</blockquote>

<p>算法步骤：</p>

<p>a.　初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则（u,v）正常有权值，若u不是v的出边邻接点，则（u,v）权值为∞。</p>

<p>b.　从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。</p>

<p>c.　以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。</p>

<p>d.　重复步骤b和c直到所有顶点都包含在S中。</p>

<p><img src="media/14900925568521/14901028040054.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<p><strong>Dijkstra算法（Java实现）</strong></p>

<pre><code>public class Dijkstra {
     private static int M = 10000; //此路不通
     public static void main(String[] args) {
    //邻接矩阵 
        int[][] weight = { 
            {0,10,M,30,100}, 
            {M,0,50,M,M}, 
            {M,M,0,M,10}, 
            {M,M,20,0,60}, 
            {M,M,M,M,0} 
        };
         
        int start=0; 
        int[] shortPath = dijkstra(weight,start); 
          
        for(int i = 0;i &lt; shortPath.length;i++) 
           System.out.println(&quot;从&quot;+start+&quot;出发到&quot;+i+&quot;的最短距离为：&quot;+shortPath[i]); 
     }
      
     public static int[] dijkstra(int[][] weight, int start) {
     //接受一个有向图的权重矩阵，和一个起点编号start（从0编号，顶点存在数组中） 
     //返回一个int[] 数组，表示从start到它的最短路径长度 
     int n = weight.length;      //顶点个数
     int[] shortPath = new int[n];  //保存start到其他各点的最短路径
     String[] path = new String[n];  //保存start到其他各点最短路径的字符串表示
     for(int i=0;i&lt;n;i++) 
           path[i]=new String(start+&quot;--&gt;&quot;+i); 
     int[] visited = new int[n];   //标记当前该顶点的最短路径是否已经求出,1表示已求出 
      
     //初始化，第一个顶点已经求出
     shortPath[start] = 0;
     visited[start] = 1;
      
     for(int count = 1; count &lt; n; count++) {   //要加入n-1个顶点
      int k = -1;        //选出一个距离初始顶点start最近的未标记顶点 
      int dmin = Integer.MAX_VALUE;
      for(int i = 0; i &lt; n; i++) {
      if(visited[i] == 0 &amp;&amp; weight[start][i] &lt; dmin) {
       dmin = weight[start][i];
       k = i;
      }
      }
       
      //将新选出的顶点标记为已求出最短路径，且到start的最短路径就是dmin 
      shortPath[k] = dmin;
      visited[k] = 1;
       
      //以k为中间点，修正从start到未访问各点的距离 
      for(int i = 0; i &lt; n; i++) {
      if(visited[i] == 0 &amp;&amp; weight[start][k] + weight[k][i] &lt; weight[start][i]) {
       weight[start][i] = weight[start][k] + weight[k][i];
       path[i] = path[k] + &quot;--&gt;&quot; + i; 
      }
      }
     }
     for(int i = 0; i &lt; n; i++) {
      System.out.println(&quot;从&quot;+start+&quot;出发到&quot;+i+&quot;的最短路径为：&quot;+path[i]);
     }
     System.out.println(&quot;=====================================&quot;); 
     return shortPath;
     }
    }
</code></pre>

<p>运行结果：</p>

<pre><code>从0出发到0的最短路径为：0--&gt;0
从0出发到1的最短路径为：0--&gt;1
从0出发到2的最短路径为：0--&gt;3--&gt;2
从0出发到3的最短路径为：0--&gt;3
从0出发到4的最短路径为：0--&gt;3--&gt;2--&gt;4
=====================================
从0出发到0的最短距离为：0
从0出发到1的最短距离为：10
从0出发到2的最短距离为：50
从0出发到3的最短距离为：30
从0出发到4的最短距离为：60
</code></pre>

<h2 id="toc_5">13. KMP算法。</h2>

<p>　　KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。</p>

<p>　　给定两个字符串T和W，长度分别为m和n，判断W是否在T中出现，如果出现则返回出现的位置。常规方法是遍历T的每一个位置，然后从该位置开始和W进行匹配，但是这种方法的复杂度是O(mn)。kmp算法通过一个O(n)的预处理，使匹配的复杂度降为O(m+n)。<br/>
　　</p>

<blockquote>
<p>　　我们要在 字符串<strong>Ｔ＝“ＡＢＣＤＡＢＣＤＡＢＤＥ”中查找 字符串Ｗ＝＂ＡＢＣＤＡＢＤ＂</strong>出现的位置。</p>
</blockquote>

<p><img src="media/14900925568521/14901029816301.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<p>　　很明显可以看出前６位都是匹配的，然而第７位不匹配，一般的做法就是从Ｔ[i]（i从1到9）开始和W开始循环比较。直到i=4，也就是图2，比较成功返回下标4。<br/>
　　<img src="media/14900925568521/14901030013399.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/><br/>
　　这样比较无异效率很低，然而我们发现在字符串&quot;ABCDAB&quot;之中有两个&quot;AB&quot;，第一次比较失败之后，又循环比较了四次，把W字符串从第一个&quot;AB&quot;的位置移动到了第二个&quot;AB&quot;处（显然这四次比较毫无意义）。于是Knuth、Morris、Pratt这三个人就想了个办法去掉了这些无意义的比较。</p>

<p>　　然而是怎么实现的呢？就要从Ｗ字符串的部分匹配值（相等的前缀和后缀）说起。</p>

<p><strong>部分匹配值</strong></p>

<pre><code>&quot;前缀&quot;指除了最后一个字符以外，一个字符串的全部头部组合；
&quot;后缀&quot;指除了第一个字符以外，一个字符串的全部尾部组合。
</code></pre>

<p>　　&quot;部分匹配值&quot;就是&quot;前缀&quot;和&quot;后缀&quot;的最长的共有元素的长度。以Ｗ字符串&quot;ABCDABD&quot;为例：<br/>
　　</p>

<blockquote>
<p>　　&quot;A&quot;的前缀和后缀都为空集，共有元素的长度为0；</p>
</blockquote>

<p>&quot;AB&quot;的前缀为[A]，后缀为[B]，共有元素的长度为0；　</p>

<blockquote>
<p>&quot;ABC&quot;的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；　</p>
</blockquote>

<p>&quot;ABCD&quot;的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</p>

<blockquote>
<p>&quot;ABCDA&quot;的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为&quot;A&quot;，长度为1；</p>
</blockquote>

<p>&quot;ABCDAB&quot;的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为&quot;AB&quot;，长度为2；</p>

<blockquote>
<p>&quot;ABCDABD&quot;的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</p>
</blockquote>

<p>从上面我们就得出了字符串Ｗ的部分匹配表：<br/>
<img src="media/14900925568521/14901031630439.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<p>我们把部分匹配表存放在一个next[]数组中，那部分匹配值究竟怎么用呢？ 我们可以根据部分匹配值计算出向后移动的位数，避免了一位位的比较：</p>

<blockquote>
<p>移动位数 = 已匹配的字符数 - 对应的部分匹配值</p>
</blockquote>

<p>以图１中为例：</p>

<p>　前６位已经匹配<strong>（已匹配的字符数 ＝６）</strong>； 　next[5] = 2 (对应的部分匹配值 = 2); 　 我们可以得出移动位数为 6-2=4位。</p>

<blockquote>
<p>　　 可以看出next数组的作用，就是在我们匹配失败的时候，确定我们子串需要往后移动的距离，而避免我们的主串指针进行回退。这样可以保证主串在只遍历一遍的情况下找到子串。因此KMP算法的重点就是如何快速的求出这个next数组。<br/>
<strong>2 求next数组</strong></p>
</blockquote>

<p>　　next数组是只与子串有关与主串无关的，它记录的是子串到每个字符处那个公共前缀（或后缀）的最大长度。<br/>
　　<img src="media/14900925568521/14901032526710.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/><br/>
　　 假设我们已经求出的next[i-1] = ｊ，即Ｗ从０到i-1处这段字符串中，最大的相等的前缀和后缀长度为ｊ。 　　 那如何求得next[i]呢？</p>

<p>这是后就要分为两种情况了：</p>

<p>①、如果Ｗ[i]==W[j]</p>

<p>　　显然前缀往后再加上一个字符之后依然会和后缀往后加上一个字符相等，此时</p>

<blockquote>
<p>next[i] = next[i-1] + 1，即next[i] = ｊ+1</p>
</blockquote>

<p>②、如果Ｗ[i]！=W[j]</p>

<p>　　那么 Ｗ[0-i]这段字符串 中，最大的相等的前缀和后缀的长度必然小于等于ｊ。 （以前是j，现在加了一个不同字符，所以不可能大于j）。</p>

<p>　　从上面的Ｗ字符串的前缀分析可以看出，短字符串的前缀必是长字符串前缀的子集。</p>

<p>　　既然长的匹配值不行了，我们只能回溯到短的匹配。把ｊ下标循环向前（下标０方向）移动，直到W[j]<mark>W[i]或者j</mark>0为止（回到第一种情况）。</p>

<p>　　那么ｊ怎么移动呢？当前Ｗ[i]！=W[j]，那么就求0到j-1的最长匹配值（next[j - 1]），再比较这个最长匹配串的末尾字符的下一位是否等于w[i]，不相等再循环。 　　 上代码：</p>

<pre><code>private static int[] getNextArray(String s){  
           char[] ch = s.toCharArray();
           int i,j;
           int[] next = new int[ch.length];  
           for(i = 1,j = 0; i &lt; ch.length; i++){  
               while(j &gt; 0 &amp;&amp; ch[i] != ch[j]){   
                   j = next[j - 1];      //j &lt;next[j - 1],所以向前移动
               }
               if(ch[i] == ch[j]){  
                   j++;  
               }  
               next[i] = j;  
           }  
           return next;  
       } 
</code></pre>

<p>Ｗ字符串&quot;ABCDABD&quot;为例，运行结果如下：<br/>
<img src="media/14900925568521/14901033346371.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/><br/>
<strong>KMP</strong><br/>
　　其实进行next数组求解的过程，类似于主串和子串进行匹配的过程，只不过是在next数组求解过程中，是子串和子串自己进行比较而已。　</p>

<p>因此整个KMP算法的代码过程如下：</p>

<pre><code>/**
      * @param str1 被匹配的字符串
      * @param str2  子串
      * @return 布尔值
      */
     public static boolean kmp(String str1,String str2){  
            char[] strA = str1.toCharArray();  
            char[] strB = str2.toCharArray();  
            int[] next = getNextArray(str2);  
            int i,j;  //这里i是从0开始的
            for(i = 0,j = 0; i &lt; strA.length; i++){  
                while(j &gt; 0 &amp;&amp; strA[i] != strB[j])  
                    j = next[j-1];  
                if(strA[i] == strB[j]){  
                    j++;  
                }  
               //匹配成功
                if(j == strB.length){  
                    return true;  
                }  
            }  
            return false;  
        } 
     private static int[] getNextArray(String s){  
           char[] ch = s.toCharArray();
           int i,j;
           //数组初始全部为0，所以next[0]=0
           int[] next = new int[ch.length];  
           for(i = 1,j = 0; i &lt; ch.length; i++){  
               while(j &gt; 0 &amp;&amp; ch[i] != ch[j]){   
                   //j &lt;next[j - 1],所以向前移动
                   j = next[j - 1];    
               }
               if(ch[i] == ch[j]){  
                   j++;  
               }  
               next[i] = j;  
           }  
           return next;  
       } 
     public static void main(String[] args) {
          String T =&quot;ＡＢＣＤＡＢＣＤＡＢＤＥ&quot;;
          String W = &quot;ＡＢＣＤＡＢＤ&quot;;
              System.out.println(kmp(T,W));
         }
</code></pre>

<p>运行结果：<br/>
<img src="media/14900925568521/14901033759445.jpg" alt=""/></p>

<h2 id="toc_6">14. 排列组合问题。</h2>

<h2 id="toc_7">15. 动态规划、贪心算法、分治算法。（一般不会问到）</h2>

<h2 id="toc_8">16. 大数据处理：类似10亿条数据找出最大的1000个数.........等等</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法[二]·排序算法]]></title>
    <link href="m78snail.com/14901034592021.html"/>
    <updated>2017-03-21T21:37:39+08:00</updated>
    <id>m78snail.com/14901034592021.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">6. 各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定。</h2>

<span id="more"></span><!-- more -->

<h3 id="toc_1">6.1 对比分析图</h3>

<p><img src="media/14900756453783/14900799660150.jpg" alt="" class="mw_img_center" style="width:800px;display: block; clear:both; margin: 0 auto;"/></p>

<ul>
<li><p>均按从小到大排列</p></li>
<li><p>k代表数值中的&quot;数位&quot;个数</p></li>
<li><p>n代表数据规模</p></li>
<li><p>m代表数据的最大值减最小值　</p>

<h3 id="toc_2">6.2 冒泡排序</h3></li>
</ul>

<blockquote>
<p>冒泡排序通过重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来，直到没有再需要交换的元素为止对n个项目需要 <strong>O( n<sup>2</sup> )</strong>的比较次数。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
</blockquote>

<p><strong>实现步骤</strong></p>

<ol>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。　</p></li>
<li><p>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p></li>
<li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li>
<li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li>
</ol>

<p><strong>Java实现</strong></p>

<pre><code>public static void main(String[] args) {
        int[] number = {95,45,15,78,84,51,24,12};
        bubble_sort(number);
        for(int i = 0; i &lt; number.length; i++) {
            System.out.print(number[i] + &quot; &quot;);
            }
    }
    public static void bubble_sort(int[] arr) {
            int  temp, len = arr.length;
            for (int i = 0; i &lt; len - 1; i++)
                for (int j = 0; j &lt; len - 1 - i; j++)
                    if (arr[j] &gt; arr[j + 1]) {
                        temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                }
        }
</code></pre>

<h3 id="toc_3">6.3 选择排序</h3>

<blockquote>
<p>常用的选择排序方法有简单选择排序和堆排序，这里只说简单选择排序，堆排序后面再说。</p>
</blockquote>

<p><strong>简单选择排序</strong></p>

<blockquote>
<p>设所排序序列的记录个数为n，i　取　1,2,…,n-1　。 　　从所有n-i+1个记录（Ri,Ri+1,…,Rn）中找出排序码最小（或最大）的记录，与第i个记录交换。执行n-1趟 后就完成了记录序列的排序。</p>
</blockquote>

<p>以排序数组｛3，2，1，4，6，5｝为例<br/>
<img src="media/14900815164786/14900829452388.jpg" alt="" class="mw_img_center" style="width:200px;display: block; clear:both; margin: 0 auto;"/><br/>
<img src="media/14900815164786/14900829644258.jpg" alt="" class="mw_img_center" style="width:200px;display: block; clear:both; margin: 0 auto;"/></p>

<p><strong>简单选择排序性能</strong></p>

<p>　　在简单选择排序过程中，所需移动记录的次数比较少。最好情况下，即待排序记录初始状态就已经是正序排列了，则不需要移动记录。　 　　最坏情况下，即待排序记录初始状态是按第一条记录最大，之后的记录从小到大顺序排列，则需要移动记录的次数最多为3（n-1）。</p>

<p>　　简单选择排序过程中需要进行的比较次数与初始状态下待排序的记录序列的排列情况无关。 　　当i=1时，需进行n-1次比较；当i=2时，需进行n-2次比较；依次类推，共需要进行的比较次数是(n-1)+(n-2)+…+2+1=n(n-1)/2，即进行比较操作的时间复杂度为O( n<sup>2</sup> )，进行移动操作的时间复杂度为O(n)。　</p>

<p>　　简单选择排序是不稳定排序<br/>
<strong>简单选择排序Java实现</strong></p>

<pre><code>public static void main(String[] args) {
        int[] number = {3,1,2,8,4,5,24,12};
        SimpleSort(number);
        for(int i = 0; i &lt; number.length; i++) {
            System.out.print(number[i] + &quot; &quot;);
            }
    }
public static void SimpleSort(int[] arr) {
            int length=arr.length;
            int temp;
            for(int i=0;i&lt;length-1;i++){
                int min=i;
                for(int j=i+1;j&lt;length;j++){ //寻找最小的数
                    if(arr[j]&lt;arr[min]){
                        min =j;
                    }
                }
                if(min!=i){
                     temp = arr[min];
                     arr[min]=arr[i];
                     arr[i]=temp;
                }
            }
        }   
</code></pre>

<h3 id="toc_4">6.4 希尔排序</h3>

<blockquote>
<p>希尔排序法(缩小增量法) 属于插入类排序，是将整个无序列分割成若干小的子序列分别进行插入排序的方法。</p>

<p>　　把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
</blockquote>

<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>

<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。
实现过程</li>
</ul>

<p>　　先取一个正整数d1小于n，把所有序号相隔d1的数组元素放一组，组内进行直接插入排序；然后取d2小于d1，重复上述分组和排序操作；直至di=1，即所有记录放进一个组中排序为止。</p>

<p>　　例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>

<p><strong>13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10</strong><br/>
然后我们对每列进行排序：</p>

<p><strong>10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45</strong><br/>
　　将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：</p>

<p><strong>10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45</strong><br/>
排序之后变为：</p>

<p><strong>10 14 13 25 23 33 27 25 59 39 65 73 45 94 82 94</strong><br/>
最后以1步长进行排序（此时就是简单的插入排序了）。<br/>
<strong>Java实现</strong></p>

<pre><code>public static void shellSort(int[] a) {
        int gap = 1, i, j, len = a.length;
        int temp;//插入排序交换值的暂存
        //确定初始步长
        while (gap &lt; len / 3){
            gap = gap * 3 + 1;
        }
        for (; gap &gt; 0; gap /= 3){//循环遍历步长，最后必为1
            for (i = gap; i &lt; len; i++) {//每一列依次向前做插入排序
                temp = a[i];
                //每一列中在a[i]上面且比a[i]大的元素依次向下移动
                for (j = i - gap; j &gt;= 0 &amp;&amp; a[j] &gt; temp; j -= gap){
                    a[j + gap] = a[j];
                }
                //a[i]填补空白，完成一列中的依次插入排序
                a[j + gap] = temp;
            }
        }   
    }
</code></pre>

<h3 id="toc_5">6.5 归并排序</h3>

<blockquote>
<p>归并排序，是创建在归并操作上的一种有效的排序算法该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>

<p>　　即先使每个子序列有序，再将两个已经排序的序列合并成一个序列的操作。若将两个有序表合并成一个有序表，称为二路归并。</p>
</blockquote>

<hr/>

<blockquote>
<p>设有数列{6，202，100，301，38，8，1} 初始状态：6,202,100,301,38,8，1 第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3； 第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4； 第三次归并后：{1,6,8,38,100,202,301},比较次数：4； 总的比较次数为：3+4+4=11,； 逆序数为14；</p>
</blockquote>

<p><strong>迭代实现的实现原理</strong></p>

<p>①申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p>

<p>②设定两个指针，最初位置分别为两个已经排序序列的起始位置</p>

<p>③比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p>

<p>④重复步骤③直到某一指针到达序列尾</p>

<p>⑤将另一序列剩下的所有元素直接复制到合并序列尾</p>

<p><strong>Java代码</strong></p>

<pre><code>public static void main(String[] args) {
        int [] arr ={6,5,3,1,8,7,2,4};
        merge_sort(arr);
        for(int i : arr){
            System.out.println(i);
        }
    }
public static void merge_sort(int[] arr) {
        int len = arr.length;
      //用于合并的临时数组
        int[] result = new int[len];
        int block, start;
        
      //两两合并后块大小变大两倍 (注意最后一次block等于len)
        for(block = 1; block &lt;=len ; block *= 2) {
            //把整个数组分成很多个块，每次合并处理两个块
            for(start = 0; start &lt;len; start += 2 * block) {
                int low = start;
                int mid = (start + block) &lt; len ? (start + block) : len;
                int high = (start + 2 * block) &lt; len ? (start + 2 * block) : len;
                //两个块的起始下标及结束下标
                int start1 = low, end1 = mid;
                int start2 = mid, end2 = high;
                //开始对两个block进行归并排序
                while (start1 &lt; end1 &amp;&amp; start2 &lt; end2) {
                result[low++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];
                }
                while(start1 &lt; end1) {
                result[low++] = arr[start1++];
                }
                while(start2 &lt; end2) {
                result[low++] = arr[start2++];
                }
            }
         //每次归并后把结果result存入arr中，以便进行下次归并
        int[] temp = arr;
        arr = result;
        result = temp;
        }
    }
</code></pre>

<p><strong>递归实现的实现原理</strong></p>

<p>假设序列共有n个元素</p>

<p>①将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素。</p>

<p>②将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素</p>

<p>③重复步骤②，直到所有元素排序完毕</p>

<p><strong>Java代码</strong></p>

<pre><code>public static void main(String[] args) {
        int [] arr ={6,5,3,1,8,7,2,4};
        int len = arr.length;
        int[] reg = new int[len];
        merge_sort_recursive(arr,reg,0,len-1);
        for(int i : arr){
            System.out.println(i);
        }
    }
static void merge_sort_recursive(int[] arr, int[] reg, int start, int end) {
        if (start &gt;= end)
            return;
        int len = end - start, mid = (len &gt;&gt; 1) + start;
        int start1 = start, end1 = mid;
        int start2 = mid + 1, end2 = end;
        //递归到子序列只有一个数的时候，开始逐个返回
        merge_sort_recursive(arr, reg, start1, end1);
        merge_sort_recursive(arr, reg, start2, end2);       
        //-------合并操作，必须在递归之后（子序列有序的基础上）----
        int k = start;
        while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)
reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];
        while (start1 &lt;= end1)
            reg[k++] = arr[start1++];
        while (start2 &lt;= end2)
            reg[k++] = arr[start2++];
        //借用reg数组做合并，然后把数据存回arr中
        for (k = start; k &lt;= end; k++)
            arr[k] = reg[k];
    }
</code></pre>

<h3 id="toc_6">6.6 快速排序</h3>

<blockquote>
<p>快速排序（Quicksort）是对冒泡排序的一种改进，又称划分交换排序（partition-exchange sort。</p>

<p>　　快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）</p>
</blockquote>

<p><strong>排序效率</strong></p>

<p>　　在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>

<p>最差时间复杂度 Ο(n<sup>2)　</sup></p>

<p>最优时间复杂度 Ο(n log n)　</p>

<p>平均时间复杂度Ο(n log n)　</p>

<p>最差空间复杂度 根据实现的方式不同而不同</p>

<pre><code>public static void main(String[] args) {
        int [] arr = {8,1,0,4,6,2,7,9,5,3};
        quickSort(arr,0,arr.length-1);
        for(int i :arr){
            System.out.println(i);
        }
    }
    public static void quickSort(int[]arr,int low,int high){
         if (low &lt; high) {     
             int middle = getMiddle(arr, low, high);     
              quickSort(arr, low, middle - 1);            
             quickSort(arr, middle + 1, high);            
          }  
    }
    public static int getMiddle(int[] list, int low, int high) {     
        int tmp = list[low];    
        while (low &lt; high) {     
            while (low &lt; high &amp;&amp; list[high] &gt;= tmp) {     
                high--;     
            }     
            list[low] = list[high];   
            while (low &lt; high &amp;&amp; list[low] &lt;= tmp) {     
                low++;     
            }     
            list[high] = list[low];   
        }     
       list[low] = tmp;           
       return low;                   
    } 
</code></pre>

<p><img src="media/14900815164786/14900866551731.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<p>取８为中值，红色箭头表示low，绿色箭头表示high<br/>
①从high开始向前扫描到第一个比８小的值与８交换。</p>

<p>②从low向后扫描第一比8大的值与8交换。</p>

<p>③重复①②过程只到，high=low完成一次快速排序，然后递归子序列。</p>

<h3 id="toc_7">6.7 堆排序</h3>

<blockquote>
<p>堆排序(Heapsort)是指利用堆这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值。</p>

<p>　　由于堆中每次都只能删除第0个数据，通过　取出第０个数据再执行堆的删除操作、重建堆（实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。），然后再取，如此重复实现排序。</p>
</blockquote>

<p><strong>堆的操作：</strong><br/>
<img src="media/14900815164786/14900869026460.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<p>在堆的数据结构中，堆中的最大值总是位于根节点。堆中定义以下几种操作：</p>

<ul>
<li><p>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</p></li>
<li><p>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</p></li>
<li><p>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算<br/>
<strong>堆的存储：</strong></p></li>
</ul>

<p><img src="media/14900815164786/14900870316370.jpg" alt="" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/><br/>
通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：</p>

<ul>
<li><p>父节点i的左子节点在位置(2*i+1);　</p></li>
<li><p>父节点i的右子节点在位置(2*i+2);</p></li>
<li><p>子节点i的父节点在位置floor((i-1)/2);　</p></li>
</ul>

<p><strong>Java代码实现</strong></p>

<pre><code>public class HeapSort {
    private static int[] sort = new int[]{1,0,10,20,3,5,6,4,9,8,12,17,34,11};
    public static void main(String[] args) {
        buildMaxHeapify(sort);
        heapSort(sort);
        print(sort);
    }

    private static void buildMaxHeapify(int[] data){
        //没有子节点的才需要创建最大堆，从最后一个的父节点开始
        int startIndex = getParentIndex(data.length - 1);
        //从尾端开始创建最大堆，每次都是正确的堆
        for (int i = startIndex; i &gt;= 0; i--) {
            maxHeapify(data, data.length, i);
        }
    }
    
    /**
     * 创建最大堆
     * @param data
     * @param heapSize需要创建最大堆的大小，一般在sort的时候用到，因为最多值放在末尾，末尾就不再归入最大堆了
     * @param index当前需要创建最大堆的位置
     */
    private static void maxHeapify(int[] data, int heapSize, int index){
        // 当前点与左右子节点比较
        int left = getChildLeftIndex(index);
        int right = getChildRightIndex(index);
        
        int largest = index;
        if (left &lt; heapSize &amp;&amp; data[index] &lt; data[left]) {
            largest = left;
        }
        if (right &lt; heapSize &amp;&amp; data[largest] &lt; data[right]) {
            largest = right;
        }
        //得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整
        if (largest != index) {
            int temp = data[index];
            data[index] = data[largest];
            data[largest] = temp;
            maxHeapify(data, heapSize, largest);
        }
    }
    
    /**
     * 排序，最大值放在末尾，data虽然是最大堆，在排序后就成了递增的
     * @param data
     */
    private static void heapSort(int[] data) {
        //末尾与头交换，交换后调整最大堆
        for (int i = data.length - 1; i &gt; 0; i--) {
            int temp = data[0];
            data[0] = data[i];
            data[i] = temp;
            maxHeapify(data, i, 0);
        }
    }
    
    /**
     * 父节点位置
     * @param current
     * @return
     */
    private static int getParentIndex(int current){
        return (current - 1) &gt;&gt; 1;
    }
    
    /**
     * 左子节点position注意括号，加法优先级更高
     * @param current
     * @return
     */
    private static int getChildLeftIndex(int current){
        return (current &lt;&lt; 1) + 1;
    }
    
    /**
     * 右子节点position
     * @param current
     * @return
     */
    private static int getChildRightIndex(int current){
        return (current &lt;&lt; 1) + 2;
    }
    
    private static void print(int[] data){
        for (int i = 0; i &lt; data.length; i++) {
            System.out.print(data[i] + &quot; |&quot;);
        }
    }
}

</code></pre>

<h3 id="toc_8">6.8 桶排序</h3>

<blockquote>
<p>桶排序（Bucket sort）或所谓的箱排序，是一个排序算法。</p>

<p>　　假设有一组长度为N的待排关键字序列K[1....n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]....B[M]中的全部内容即是一个有序序列。</p>
</blockquote>

<p>桶排序的步骤：</p>

<p>①设置一个定量的数组当作空桶子。</p>

<p>②寻访序列，并且把项目一个一个放到对应的桶子去。</p>

<p>③对每个不是空的桶子进行排序。</p>

<p>④从不是空的桶子里把项目再放回原来的序列中。<br/>
<strong>性能</strong><br/>
数据结构    数组　 最差时间复杂度 　 O(n<sup>2)</sup> 平均时间复杂度    　O(n+k) 最差空间复杂度　O(n*k)</p>

<p>　　平均情况下桶排序以线性时间运行，桶排序是稳定的，排序非常快,但是同时也非常耗空间,基本上是最耗空间的一种排序算法。</p>

<p>　　对N个关键字进行桶排序的时间复杂度分为两个部分：</p>

<p>①循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。</p>

<p>②利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。</p>

<p>　　很显然，第②部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：　</p>

<blockquote>
<p>① 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。　 　　 <br/>
②尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。 当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。</p>
</blockquote>

<p>Java实现 </p>

<pre><code>public class BucketSort  {
    /** 
     * 对arr进行桶排序，排序结果仍放在arr中 
     */  
    public static void bucketSort(double arr[]){  
  //-------------------------------------------------分桶-----------------------------------------------      
        int n = arr.length;  
        //存放桶的链表
        ArrayList bucketList[] = new ArrayList [n];  
        //每个桶是一个list，存放此桶的元素   
        for(int i =0;i&lt;n;i++){  
            //下取等
            int temp = (int) Math.floor(n*arr[i]);  
            //若不存在该桶，就新建一个桶并加入到桶链表中
            if(null==bucketList[temp])  
                bucketList[temp] = new ArrayList();  
            //把当前元素加入到对应桶中
            bucketList[temp].add(arr[i]);            
        }  
//-------------------------------------------------桶内排序-----------------------------------------------    
        //对每个桶中的数进行插入排序   
        for(int i = 0;i&lt;n;i++){  
            if(null!=bucketList[i])  
                insert(bucketList[i]);  
        }  
//-------------------------------------------------合并桶内数据-----------------------------------------------    
        //把各个桶的排序结果合并   
        int count = 0; 
        for(int i = 0;i&lt;n;i++){  
            if(null!=bucketList[i]){  
                Iterator iter = bucketList[i].iterator();  
                while(iter.hasNext()){  
                    Double d = (Double)iter.next();  
                    arr[count] = d;  
                    count++;  
                }  
            }  
        }  
    }  
    
    /** 
     * 用插入排序对每个桶进行排序 
     * 从小到大排序
     */  
    public static void insert(ArrayList list){  
        
        if(list.size()&gt;1){  
            for(int i =1;i&lt;list.size();i++){  
                if((Double)list.get(i)&lt;(Double)list.get(i-1)){  
                    double temp = (Double) list.get(i);  
                    int j = i-1;  
                    for(;j&gt;=0&amp;&amp;((Double)list.get(j)&gt;(Double)list.get(j+1));j--)  
                        list.set(j+1, list.get(j));  //后移
                    list.set(j+1, temp);  
                }  
            }  
        } 
    }
}
测试代码：

public static void main(String[] args) {
        double arr [] ={0.21,0.23,0.76,0.12,0.89};
        BucketSort.bucketSort(arr);
        for(double a:arr){
            System.out.println(a);
        }
    }
</code></pre>

<h3 id="toc_9">6.9 基数排序</h3>

<blockquote>
<p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>

<p>　　将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
</blockquote>

<p><strong>效率</strong></p>

<p>　　基数排序的时间复杂度是O(k·n)，其中n是排序元素个数，k是数字位数。注意这不是说这个时间复杂度一定优于O(n·log(n))，k的大小取决于数字位的选择和待排序数据所属数据类型的全集的大小；k决定了进行多少轮处理，而n是每轮处理的操作数目。</p>

<p>　　基数排序基本操作的代价较小，k一般不大于logn，所以基数排序一般要快过基于比较的排序，比如快速排序。</p>

<p>　　最差空间复杂度是O(k·n)</p>

<p>现在有数组：278，109，63,930,589,184,505,269,8,83　。根据各位数将数组划分为10个链表(当然其中的某些链表可能不含有元素) 　　 第一次分配：</p>

<p><strong>0:930 1: 2: 3:63,83 4:184 5:505 6： 7: 8:278,8 9:109,589,269</strong><br/>
第一次收集后的数组：</p>

<p><strong>930,63,83,184,505，278,8,109,589,269</strong><br/>
第二次分配：</p>

<p><strong>0:505,8,109 1: 2: 3:930 4: 5: 6：63,269 7:278 8:83,184，589 9:</strong><br/>
第二次收集后的数组：</p>

<p><strong>505,8,109，930，63,269，278，83,184，589</strong><br/>
第三次分配：</p>

<p><strong>0:8,63,83 1:109,184 2:278,269 3: 4: 5:505,589 6: 7: 8: 9:930</strong><br/>
最后得到序列：</p>

<p><strong>8,63,83,109,184，269,278,505,589,930</strong><br/>
基数排序其实是利用多关键字先达到局部有序，再调整达到全局有序。</p>

<p>代码实现：</p>

<pre><code>public class Test {
    public static void main(String[] args) {

        int[] array = {278,109,63,930,589,184,505,269,8,83};  
        radixSort(array);  
        for(double a : array){
            System.out.println(a);
        }
    }
public static void radixSort(int[] array){
        
        //------------------------------------------确定排序的趟数----------------------------------
        int max=array[0];
        for(int i=1;i&lt;array.length;i++){
            if(array[i]&gt;max){
                max=array[i];
            }
        }
        int time=0;
        while(max&gt;0){
            max/=10;
            time++;
        }
        //----------------------------------------初始化10个链表用户分配时暂存-------------------------------
        List&lt;List&lt;Integer&gt;&gt; list=new ArrayList&lt;List&lt;Integer&gt;&gt;();
        for(int i=0;i&lt;10;i++){
            List&lt;Integer&gt; item=new ArrayList&lt;Integer&gt;();
            list.add(item);
        }
        
        //-----------------------------------------进行time次分配和收集-------------------------------------
      for(int i=0;i&lt;time;i++){
            //分配元素;
            for(int j=0;j&lt;array.length;j++){
                int index = array[j]%(int)Math.pow(10, i+1)/(int)Math.pow(10, i);
                list.get(index).add(array[j]);
            }
            //收集元素;
            int count=0;
            for(int k=0;k&lt;10;k++){
                if(list.get(k).size()&gt;0){
                    for(int a : list.get(k)){
                        array[count]=a;
                        count++;
                    }
                    //清除数据，以便下次收集
                    list.get(k).clear();
                }
            }
        }
    }
}
</code></pre>

<h3 id="toc_10">6.10 插入排序</h3>

<blockquote>
<p>将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，是稳定的排序方法。</p>

<p>　　插入排序又分为　直接插入排序　和 折半插入排序。</p>
</blockquote>

<p><strong>直接插入排序</strong></p>

<p>　　把待排序的纪录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的纪录插入完为止，得到一个新的有序序列。</p>

<p><strong>Java实现</strong></p>

<pre><code>public static void insertSort(int a[]){  
        int j;       //当前要插入值的位置  
        int preJ;     //依次指向j前的位置  
        int key;       //后移时来暂存要插入的值
        
        //从数组的第二个位置开始遍历值  
        for(j=1;j&lt;a.length;j++){  
            key=a[j];  
            preJ=j-1;  
            //a[preJ]比当前值大时，a[preJ]后移一位  
            while(preJ&gt;=0 &amp;&amp; a[preJ]&gt;key){  
                a[preJ+1]=a[preJ]; //将a[preJ]值后移   
                
     //这里注意:  a[preJ+1]=a[j]=key,把插入值已经存在了 key中
    //等于说, 留出来一个空白位置来实现依次后移（不会造成数据丢失问题）
                
                preJ--;         //preJ前移  
            }
            //找到要插入的位置或已遍历完成（(preJ=0）
            a[preJ+1]=key;    //将当前值插入 空白位置
        }  
    } 
</code></pre>

<p><strong>效率分析</strong></p>

<p>　　空间复杂度O(1) 　 　　 　　平均时间复杂度O(n<sup>2)</sup></p>

<p>　　</p>

<blockquote>
<p>最差情况：反序，需要移动n*(n-1)/2个元素 ，运行时间为O(n<sup>2)。</sup> 　　 最好情况：正序，不需要移动元素，运行时间为O(n)．</p>
</blockquote>

<p><strong>折半插入排序</strong>　</p>

<blockquote>
<p>　　直接插入排序中要把插入元素与已有序序列元素依次进行比较，效率非常低。　 　　 　<br/>
　　折半插入排序,使用使用折半查找的方式寻找插入点的位置, 可以减少比较的次数,但移动的次数不变, 时间复杂度和空间复杂度和直接插入排序一样，在元素较多的情况下能提高查找性能。</p>
</blockquote>

<p><strong>Java实现</strong></p>

<pre><code>private static void binaryInsertSort(int[] a)  
    {  
        //从数组的第二个位置开始遍历值    
        for(int i = 1; i &lt; a.length; i++)  {  
            int key = a[i];           //暂存要插入的值    
            int pre = 0;              //有序序列开始和结尾下标申明
            int last = i - 1;       
        // 折半查找出插入位置 a[pre]
            while(pre &lt;= last)  {  
                int mid = (pre + last) / 2;                
                if(key &lt; a[mid])  {  
                    last = mid - 1;  
                } else {  
                    pre = mid + 1;  
                }  
            }  
     //a[i]已经取出来存放在key中，把下标从pre + 1到 i-1的元素依次后移
            for(int j = i; j &gt;= pre + 1; j--)  {  
                a[j] = a[j - 1];  
            }  
            //把值插入空白位置
            a[pre] = key;            
        }  
    } 
</code></pre>

<p>直接插入排序是，比较一个后移一个； 折半插入排序是，先找到位置，然后一起移动；</p>

<h2 id="toc_11">7. 快排的partition函数与归并的Merge函数。</h2>

<blockquote>
<p>快排的partition函数</p>

<p>　　作用：给定一个数组arr[]和数组中任意一个元素a，重排数组使得a左边都小于它，右边都不小于它。</p>
</blockquote>

<pre><code>// A[]为数组，start、end分别为数组第一个元素和最后一个元素的索引
 // povitIndex为数组中任意选中的数的索引
static int partition(int A[], int start, int end, int pivotIndex){
    int i = start, j = end, pivot = A[pivotIndex];
    swap&lt;int&gt;(A[end], A[pivotIndex]);
    while(i &lt; j){
        while(i &lt; j &amp;&amp; A[i] &lt;= pivot) ++i;
        while(i &lt; j &amp;&amp; A[j] &gt;= pivot) --j;
        if(i &lt; j) swap&lt;int&gt;(A[i], A[j]);
    }
    swap&lt;int&gt;(A[end], A[i]);
    return i;
}
</code></pre>

<blockquote>
<p>归并的Merge函数<br/>
思想：分治原则，合的时候进行排序，稳定排序。 <br/>
需要用到两个函数，merge函数负责将有序的两个数组进行进行合并，mergeSort函数负责递归实现分组处理，</p>
</blockquote>

<p><strong>Java代码如下</strong>：</p>

<pre><code>public class MergeSort {

    public static void main(String[] args) {
        int a[]={3,2,5,4,7,9};
        int tmp[]=new int[a.length];
        new MergeSort().mergeSort(a, 0, a.length-1, tmp);
        for (int i : a) {
            System.out.println(i);
        }
    }
    //将有序数组a[first..mid] a[mid+1,last]合并
    void merge(int a[],int first,int mid,int last,int tmp[]){
        int i=first;//前一个数组的开始下标
        int j=mid+1;//后一个数组的开始下标
        int m=mid;//前一个数组的最后下标
        int n=last;//后一个数组的最后下标
        int k=0;//存放临时数组到tmp
        while(i&lt;=m&amp;&amp;j&lt;=n){
            if(a[i]&lt;=a[j]){
                tmp[k++]=a[i];
                i++;
            }else {
                tmp[k++]=a[j];
                j++;
            }
        }
        while(i&lt;=m){
            tmp[k++]=a[i++];
        }
        while(j&lt;=n){
            tmp[k++]=a[j++];
        }
        //复制tmp到a数组
        for(i=0;i&lt;k;i++){
            a[first+i]=tmp[i];
        }

    }
    void mergeSort(int a[],int first,int last,int tmp[]){
        if(first&lt;last){
            int mid=(first+last)/2;
            mergeSort(a, first, mid, tmp);//左边有序
            mergeSort(a, mid+1, last, tmp);//右边有序
            merge(a, first, mid, last, tmp);//合并
        }
    }

}
</code></pre>

<h2 id="toc_12">8. 对冒泡与快排的改进。</h2>

<p><strong>冒泡排序的改进</strong><br/>
①、加一个标志位，当某一趟冒泡排序没有元素交换时，则冒泡结束，元素已经有序，可以有效的减少冒泡次数。</p>

<pre><code>/** 
     * 引入标志位，默认为true 
     * 如果前后数据进行了交换，则为true，否则为false。如果没有数据交换，则排序完成。 
     */  
    public static int[] bubbleSort(int[] arr){  
        boolean flag = true;  
        int n = arr.length;  
        while(flag){  
            flag = false;  
            for(int j=0;j&lt;n-1;j++){  
                if(arr[j] &gt;arr[j+1]){  
                    //数据交换  
                    int temp = arr[j];  
                    arr[j] = arr[j+1];  
                    arr[j+1] = temp;  
                    //设置标志位  
                    flag = true;  
                }  
            }  
            n--;  
        }  
        return arr;  
    }  
</code></pre>

<p>②、记录每一次元素交换的位置，当元素交换的位置在第0个元素时，则排序结束。</p>

<p><strong>快排优化</strong><br/>
① 快速排序在处理小规模数据时的表现不好，这个时候可以改用插入排序。</p>

<p>②对于一个每个元素都完全相同的一个序列来讲，快速排序也会退化到 O(n<sup>2</sup> )。要将这种情况避免到，可以这样做：</p>

<p>　　在分区的时候，将序列分为 3 堆，一堆小于中轴元素，一堆等于中轴元素，一堆大于中轴元素，下次递归调用快速排序的时候，只需对小于和大于中轴元素的两堆数据进行排序，中间等于中轴元素的一堆已经放好。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法[一]·数据结构]]></title>
    <link href="m78snail.com/14900756453783.html"/>
    <updated>2017-03-21T13:54:05+08:00</updated>
    <id>m78snail.com/14900756453783.html</id>
    <content type="html"><![CDATA[
<p>算法的话其实是个重点，因为最后都是要你写代码，所以算法还是需要花不少时间准备，这里有太多算法题，写不全，我的建议是没事多在OJ上刷刷题（牛客网、leetcode等），剑指offer上的算法要能理解并自己写出来，编程之美也推荐看一看。<br/>
推荐书籍：《大话数据结构》《剑指offer》《编程之美》</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">1. 链表与数组。</h2>

<h3 id="toc_1">1.1 概述</h3>

<p>　　<strong>数组</strong>　是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少插入和删除元素，就应该用数组。</p>

<p>　　<strong>链表</strong>　中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起，每个结点包括两个部分：一个是存储 数据元素 的　数据域，另一个是存储下一个结点地址的 指针。 　　如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表。</p>

<h3 id="toc_2">1.2 内存存储区别</h3>

<ul>
<li><p>数组从栈中分配空间, 对于程序员方便快速,但自由度小。</p></li>
<li><p>链表从堆中分配空间, 自由度大但申请管理比较麻烦.</p>

<h3 id="toc_3">1.3 逻辑结构区别</h3></li>
<li><p>数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费。　</p></li>
<li><p>链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项）</p>

<h3 id="toc_4">1.4 总结</h3></li>
</ul>

<p>1、存取方式上，数组可以顺序存取或者随机存取，而链表只能顺序存取；　</p>

<p>2、存储位置上，数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定；　</p>

<p>3、存储空间上，链表由于带有指针域，存储密度不如数组大；　</p>

<p>4、按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)；　</p>

<p>5、按值查找时，若数组无序，数组和链表时间复杂度均为O(1)，但是当数组有序时，可以采用折半查找将时间复杂度降为O(logn)；　</p>

<p>6、插入和删除时，数组平均需要移动n/2个元素，而链表只需修改指针即可；　</p>

<p>7、空间分配方面： 　　数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败； 　　链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；</p>

<h2 id="toc_5">2. 队列和栈，出栈与入栈。</h2>

<h3 id="toc_6">2.1 队列</h3>

<p>　　队列是一种操作受限制的线性表，它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。 　　队列中没有元素时，称为空队列。在队列这种数据结构中，最先插入的元素将是最先被删除的元素；反之最后插入的元素将是最后被删除的元素，因此队列又称为“先进先出”（FIFO—first in first out）的线性表。</p>

<p>队列空的条件：front=rear</p>

<p>队列满的条件： rear = MAXSIZE</p>

<h3 id="toc_7">2.2 顺序队列</h3>

<p>　　建立顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理。一个是队头指针front，它指向队头元素；另一个是队尾指针rear，它指向下一个入队元素的存储位置．<br/>
　　<img src="media/14900756453783/14900764195404.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/><br/>
顺序队列中的溢出现象：</p>

<ul>
<li><p>下溢：当队列为空时，做出队运算产生的溢出现象。“下溢”是正常现象，常用作程序控制转移的条件。　</p></li>
<li><p>真上溢：当队列满时，做进栈运算产生空间溢出的现象。“真上溢”是一种出错状态，应设法避免。　</p></li>
<li><p>假上溢：由于入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用。当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作。该现象称为&quot;假上溢&quot;现象。</p>

<h3 id="toc_8">2.3 Java中Queue</h3></li>
</ul>

<p>　　Queue继承于Collection，除了基本的 Collection 操作外，队列还提供其他的插入、提取和检查操作。每个方法都存在两种形式：一种抛出异常（操作失败时），另一种返回一个特殊值（null 或 false，具体取决于操作）。<br/>
　　<img src="media/14900756453783/14900764938927.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<ul>
<li><p>add()和offer()都是将指定的元素插入队列 　　　add() 在成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。 offer()当使用有容量限制的队列时,无法插入元素，而只是抛出一个异常。</p></li>
<li><p>element() 和 peek() 返回但不移除队列的头，如果队列为空，peek()返回 null，element()抛出异常。</p></li>
<li><p>remove() 和 poll() 方法可移除和返回队列的头，它们仅在队列为空时其行为有所不同：remove() 方法抛出一个异常，而 poll() 方法则返回 null。</p>

<h3 id="toc_9">2.4 栈和队列的区别：</h3>

<p>队列是FIFO的（先进先出），堆栈是FILO的（现今后出）</p></li>
</ul>

<p>　 栈是限定只能在表的一端进行插入和删除操作的线性表。 队列是限定只能在表的一端进行插入和在另一端进行删除操作的线性表</p>

<p>　 栈只能从头部取数据，也就最先放入的需要遍历整个栈最后才能取出来，而且在遍历数据的时候还得为数据开辟临时空间； 队列基于地址指针进行遍历，而且可以从头或尾部开始遍历，但不能同时遍历，无需开辟临时空间，因为在遍历的过程中不影像数据结构，速度要快的多。</p>

<h2 id="toc_10">3. 链表的删除、插入、反向。</h2>

<h2 id="toc_11">4. 字符串操作。</h2>

<blockquote>
<p>在JAVA语言中，字符串数据实际上由String类所实现的。Java字符串类分为两类：一类是在程序中不会被改变长度的不变字符串；二类是在程序中会被改变长度的可变字符串。Java环境为了存储和维护这两类字符串提供了 String和StringBuffer两个类。</p>
</blockquote>

<h3 id="toc_12">4.1String的一些常用操作</h3>

<h4 id="toc_13"><1>字符串创建</h4>

<pre><code>String　str=&quot;This is a String&quot;;
</code></pre>

<p>或者</p>

<pre><code>String　str=new String（&quot;This is a String&quot;);
</code></pre>

<h4 id="toc_14"><2>字符串长度</h4>

<pre><code>String str= &quot;This is a String&quot;;
int len =str.length();
</code></pre>

<h4 id="toc_15"><3>指定字符或子字符串的位置</h4>

<pre><code>String str=&quot;Thisis a String&quot;;
Int index1 =str.indexOf(&quot;i&quot;);   //2
Int index２＝str.lastIndexOf(&quot;i&quot;)； //12
</code></pre>

<h4 id="toc_16"><4>判断两个字符串是否相等</h4>

<pre><code>String str=&quot;This　is a String&quot;;
Boolean result=str.equals(&quot;This is another String&quot;);
</code></pre>

<h4 id="toc_17"><5>得到指定位置的字符</h4>

<pre><code>String str=&quot;This　is a String&quot;;
char chr=str.charAt(3);
</code></pre>

<h4 id="toc_18"><6>截取子字符串</h4>

<pre><code>str＝str.substring(int beginIndex);
</code></pre>

<p>截取掉str从首字母起长度为beginIndex的字符串，将剩余字符串赋值给str；</p>

<pre><code>str＝str.substring(int beginIndex，int endIndex);
</code></pre>

<h4 id="toc_19"><6>字符串合并</h4>

<pre><code>String str=&quot;This　is a String&quot;;
String str1=str.concat(&quot;Test&quot;); //str1=&quot;This　is a String Test&quot;
</code></pre>

<h2 id="toc_20">5. Hash表的hash函数，冲突解决方法有哪些。</h2>

<h3 id="toc_21">5.１Hash表</h3>

<p>　　哈希表（Hash table，也叫散列表），是根据key而直接进行访问的数据结构。也就是说，它通过把key映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>

<p>　　以数据中每个元素的关键字K为自变量，通过散列函数H（k）计算出函数值，以该函数值作为一块连续存储空间的的单元地址，将该元素存储到函数值对应的单元中。</p>

<p>　　哈希表存储的是键值对，其查找的时间复杂度与元素数量多少无关，哈希表在查找元素时是通过计算哈希码值来定位元素的位置从而直接访问元素的，因此，哈希表查找的时间复杂度为O（1）。</p>

<h3 id="toc_22">5.2 哈希表的构造方法</h3>

<h4 id="toc_23">5.2.1 直接定址法</h4>

<p>　　取关键字或者关键字的某个线性函数值作为哈希地址,即　 　　 　　H(Key)=Key或者H(Key)=a*Key+b(a,b为整数)　 　　 　　这种散列函数也叫做自身函数.如果H(Key)的哈希地址上已经有值了,那么就往下一个位置找,直到找到H(Key)的位置没有值了就把元素放进去.　 　　此法仅适合于：地址集合的大小 等于 关键字集合的大小</p>

<h4 id="toc_24">5.2.2 数字分析法</h4>

<p>　　分析一组数据,比如一组员工的出生年月,这时我们发现出生年月的前几位数字一般都相同,因此,出现冲突的概率就会很大,但是我们发现年月日的后几位表示月份和具体日期的数字差别很大,如果利用后面的几位数字来构造散列地址,则冲突的几率则会明显降低. 　　因此数字分析法就是找出数字的规律,尽可能利用这些数据来构造冲突几率较低的散列地址.　　 　　此法适于:能预先估计出全体关键字的每一位上各种数字出现的频度。</p>

<h4 id="toc_25">5.2.3 平方取中法　</h4>

<p>　　以关键字的平方值的中间几位作为存储地址（哈希地址）。求“关键字的平方值” 的目的是“扩大差别” ，同时平方值的中间各位又能受到整个关键字中各位的影响。　</p>

<p>　　此法适于:关键字中的每一位都有某些数字重复出现频度很高的现象。</p>

<h4 id="toc_26">5.2.4 折叠法　</h4>

<p>　　 将关键字分割成若干部分，然后取它们的叠加和为哈希地址。两种叠加处理的方法：移位叠加:将分 割后的几部分低位对齐相加；间界叠加:从一端沿分割界来回折叠，然后对齐相加。 　　 　　此法适于：关键字的数字位数特别多。</p>

<h4 id="toc_27">5.2.5 随机数法</h4>

<p>　　设定哈希函数为:H(key) = Random(key)其中，Random 为伪随机函数 此法适于：对长度不等的关键字构造哈希函数。</p>

<h4 id="toc_28">5.2.6 除留余数法</h4>

<p>　　取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址.即 　　哈希函数为:H(key) = key MOD p ( p≤m )，其中， m为表长，p 为不大于 m 的素数。</p>

<h3 id="toc_29">5.3 哈希表冲突解决方法</h3>

<p>　　哈希表处理冲突主要有<strong>开放寻址法</strong>、<strong>再散列法</strong>、<strong>链地址法（拉链法）</strong>和建立一个<strong>公共溢出区</strong>四种方法。 　　通过构造性能良好的哈希函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是哈希法的另一个关键问题。 　“处理冲突” 的实际含义是：为产生冲突的关键字寻找下一个哈希地址。 </p>

<h3 id="toc_30">5.3.1 开放定址法</h3>

<p>一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p>

<h4 id="toc_31"><1> 线性探测</h4>

<p>　　冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p>

<p>　　公式： </p>

<pre><code>　　fi(key) = (f(key)+di) MOD m (di=1,2,3,......,m-1)
</code></pre>

<h4 id="toc_32"><2> 二次探测法</h4>

<p>　　冲突发生时，在表的左右进行跳跃式探测，双向寻找到可能的空位置。</p>

<p>公式：</p>

<pre><code>fi(key) = (f(key)+di) MOD m (di = 12, -12, 22, -22,……, q2, -q2, q &lt;= m/2)

</code></pre>

<h4 id="toc_33"><3> 随机探测法</h4>

<p>在冲突时，对于位移量 di 采用随机函数计算得到，我们称之为随机探测法。</p>

<p>　公式： 　</p>

<pre><code>fi(key) = (f(key)+di) MOD m (di是一个随机数列)
</code></pre>

<p>线性探测再散列容易产生“二次聚集”，即在处理同义词的冲突时又导致非同义词的冲突。 　　线性探测再散列的优点是：只要哈希表不满，就一定能找到一个不冲突的哈希地址，而二次探测再散列和伪随机探测再散列则不一定。</p>

<h3 id="toc_34">5.3.2链地址法</h3>

<p>将所有哈希地址相同的记录都链接在同一链表中。各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况。 　　 处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</p>

<h3 id="toc_35">5.3.3 再哈希法</h3>

<p>这种方法是同时构造多个不同的哈希函数：</p>

<pre><code>Hi=RH1（key），i=1，2,3，…,n.

</code></pre>

<p>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>

<h3 id="toc_36">5.3.4 建立公共溢出区</h3>

<p>　　这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表.(注意：在这个方法里面是把元素分开两个表来存储)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[操作系统]]></title>
    <link href="m78snail.com/14872090613431.html"/>
    <updated>2017-02-16T09:37:41+08:00</updated>
    <id>m78snail.com/14872090613431.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1. 进程和线程的区别。</h2>

<p>线程和进程的主要区别是:他们是操作系统不同的管理系统资源的方式。进程拥有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他的进程造成任何的影响，而线程只是进程不同的执行路径而已。线程有自己的堆栈和局部变量，但是线程没有独立的地址空间。通常可以将线程看成是一个轻量级的进程。</p>

<span id="more"></span><!-- more -->

<p>在 <strong>cpu 的调度方面</strong>，线程是调度的基本单位。并且线程的调度是比较轻量级的，提高了系统的并发性能。同一进程中的线程调度不会引起进程的调度，但是不同进程之间的线程切换还是会引起进程的切换的。<br/>
在<strong>执行过程</strong>来看，进程拥有独立的内存单元，同一进程下的线程可以共享改内存区域，提高了运行效率。<br/>
从<strong>逻辑角度</strong>来看：（重要区别）多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但是，操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理及资源分配。</p>

<h2 id="toc_1">2. 死锁的必要条件，怎么处理死锁。</h2>

<p><strong>四个必要条件：</strong><br/>
　　1.互斥条件：一个资源每次只能被一个进程使用。<br/>
　　2.请求与保持条件：一个进程因请求资源而阻塞，对已获得的资源保持不放。<br/>
　　3.不剥夺条件：进程获得的资源，在未使用完之前，不可以强行剥夺。<br/>
　　4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系<br/>
<strong>处理死锁：</strong><br/>
1.死锁的预防：破坏四个死锁的条件，但是都没一定的局限性，相应系统的执行效率<br/>
2.死锁的避免：银行家算法。<br/>
3.死锁的解决：<br/>
　　(1) 最简单，最常用的方法就是进行系统的重新启动，不过这种方法代价很大，它意<br/>
味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程。<br/>
　　(2) 撤消进程，剥夺资源。终止参与死锁的进程，收回它们占有的资源，从而解除死锁。这时又分两种情况：一次性撤消参与死锁的全部进程，剥夺全部资源；或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源。一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程，比如按进程的优先级确定进程的代价；考虑进程运行时的代价和与此进程相关的外部作业的代价等因素。</p>

<h2 id="toc_2">3. Window 内存管理方式：段存储，页存储，段页存储。</h2>

<p><strong>分页存储管理基本思想：</strong><br/>
用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。<br/>
页式管理的优点是没有外碎片，每个内碎片不超过页的大小。缺点是,程序全部装入内存，要求有相应的硬件支持。<br/>
<strong>分段存储管理基本思想：</strong><br/>
将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。段式管理优点是可以分别编写和编译，可以针对不同类型的段采用不同的保护，可以按段为单位来进行共享，包括通过动态链接进行代码共享。缺点是会产生碎片。<br/>
<strong>段页式存储管理基本思想：</strong><br/>
分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，便于段的共享与保护，将分页与分段两种存储方式结合起来，就形成了段页式存储管理方式。<br/>
在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。段页式系统中，作业的地址结构包含三部分的内容：段号 页号 页内位移量程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。段页式管理是段式管理与页式管理方案结合而成的所以具有他们两者的优点。但反过来说，由于管理软件的增加，复杂性和开销也就随之增加了。</p>

<h2 id="toc_3">4. 进程的几种状态</h2>

<p>创建，就绪，运行，阻塞，退出。<br/>
1）就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；<br/>
2）执行——阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为<br/>
阻塞状态，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等；<br/>
3）阻塞——就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；<br/>
4）执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。</p>

<h2 id="toc_4">5. IPC 几种通信方式。</h2>

<p><img src="media/14872090613431/14872112791305.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/><br/>
<strong>信号量</strong>:<br/>
信号机制是 UNIX 为进程中断处理而设置的。它只是一组预定义的值，因此不能用于信息交换，仅用于进程中断控制。例如在发生浮点错、非法内存访问、执行无 效指令、某些按键（如 ctrl-c、del 等）等都会产生一个信号，操作系统就会调用有关的系统调用或用户定义的处理过程来处理。<br/>
<strong>管道</strong>:<br/>
无名管道实际上是内存中的一个临时存储区，它由系统安全控制，并且独立于创建它的进程的内存区。管道对数据采用先进先出方式管理，并严格按顺序操作，例如不能对管道进行搜索，管道中的信息只能读一次。无名管道只能用于两个相互协作的进程之间的通信，并且访问无名管道的进程必须有共同的祖先。有名管道的操作和无名管道类似，不同的地方在于使用有名管道的进程不需要具有共同的祖<br/>
先，其它进程，只要知道该管道的名字，就可以访问它。管道非常适合进程之间快速交换信<br/>
息。<br/>
<strong>共享储存段</strong>:<br/>
共享存储段是主存的一部分，它由一个或多个独立的进程共享。各进程的数据段与共享存储段相关联，对每个进程来说，共享存储段有不同的虚拟地址。<br/>
<strong>信号灯</strong>:<br/>
信号灯是一组进程共享的数据结构，当几个进程竞争同一资源时（文件、共享内存或消息队列等），它们的操作便由信号灯来同步，以防止互相干扰。<br/>
信号灯保证了某一时刻只有一个进程访问某一临界资源，所有请求该资源的其它进程都将被挂起，一旦该资源得到释放，系统才允许其它进程访问该资源。信号灯通常配对使用，以便实现资源的加锁和解锁。<br/>
<strong>进程间通信的实现技术的特点是</strong>：操作系统提供实现机制和编程接口，由用户在程序中实现，保证进程间可以进行快速的信息交换和大量数据的共享。但是,上述方式主要适合在同一台计算机系统内部的进程之间的通信。</p>

<h2 id="toc_5">6. 什么是存虚拟内。</h2>

<p>虚拟内存是计算机系统内存管理的一种技术。 它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>

<h2 id="toc_6">7. 虚拟地址、逻辑地址、线性地址、物理地址的区别。</h2>

<p><strong>逻辑地址</strong>（Logical Address） 是指由程序产生的与段相关的偏移地址部分。例如，你在进行C 语言指针编程中，可以读取指针变量本身值(&amp;操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址，不和绝对物理地址相干。只有在 Intel 实模式下，逻辑地址才和物理地址相等（因为实模式没有分段或分页机制,Cpu 不进行自动地址转换）；逻辑也就是在 Intel 保护模式下程序执行代码段限长内的偏移地址（假定代码段、数据段如果完全一样）。应用程序员仅需与逻辑地址打交道，而分段和分页机制对您来说是完全透明的，仅由系统编程人员涉及。应用程序员虽然自己可以直接操作内存，那也只能在操作系统给你分<br/>
配的内存段操作。<br/>
<strong>线性地址</strong>（Linear Address） 是逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址可以再经变换以产生一个物理地址。若没有启用分页机制，那么线性地址直接就是物理地址。Intel 80386 的线性地址空间容量为 4G（2 的 32 次方即 32 根地<br/>
址总线寻址）。<br/>
<strong>物理地址</strong>（Physical Address） 是指出现在 CPU 外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。如果没有启用分页机制，那么线性地址就直接成为物理地址了。<br/>
<strong>虚拟内存</strong>（Virtual Memory） 是指计算机呈现出要比实际拥有的内存大得多的内存量。因此它允许程序员编制并运行比实际系统拥有的内存大得多的程序。这使得许多大型项目也能够在具有有限内存资源的系统上实现。一个很恰当的比喻是：你不需要很长的轨道就可以让一列火车从上海开到北京。你只需要足够长的铁轨（比如说 3 公里）就可以完成这个任务。采取的方法是把后面的铁轨立刻铺到火车的前面，只要你的操作足够快并能满足要求，列车就能象在一条完整的轨道上运行。这也就是虚拟内存管理需要完成的任务。在 Linux 0.11 内核中，给每个程序（进程）都划分了总容量为 64MB 的虚拟内存空间。因此程序的逻辑地址范围是0x0000000 到0x4000000。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[装饰模式之女朋友系列之化妆篇]]></title>
    <link href="m78snail.com/14871457028090.html"/>
    <updated>2017-02-15T16:01:42+08:00</updated>
    <id>m78snail.com/14871457028090.html</id>
    <content type="html"><![CDATA[
<ul>
<li>上次说到，有了妹子，并且过上了幸福的生活.</li>
<li>今天周末，我们当然要出去逛街了(shopping是必不可少的么-_-)，可是她化妆画了好久还没好.</li>
<li>这时候我看到她的那些个瓶瓶罐罐，灵机一动.</li>
<li>&quot;诶，你在这化妆的流程倒让我想起了一种设计模式，要不要听听&quot;</li>
<li>&quot;你给老子滚...&quot;</li>
<li>&quot;听听么...装饰模式耶&quot;在她怒目的注视下，我就开始BB了...</li>
</ul>

<span id="more"></span><!-- more -->

<p><strong>用代码来化妆就是:</strong></p>

<pre><code>// 先来一个抽象的脸(piapia, &quot;别抽脸...&quot;)
public abstract class Face {
      // 化妆不就是要展示出来么，那就show一个
      public abstract void show();
}
</code></pre>

<pre><code>// 在来个女朋友类
public class GirlFriend extends Face {
      @Override
      public void show() {
            System.out.println(&quot;I am the yunnan girl.&quot;);
      }
}
</code></pre>

<pre><code>// 粉底
public class FenDiDecorator extends Decorator {
      @Override
      public void show() {
            // 先执行父类的职责，要不之前的妆就白画了
            super.show();
            System.out.println(&quot;With fendi.&quot;);
      }
}
</code></pre>

<pre><code>// 画眼线
public class YanXianDecorator extends Decorator {
      @Override
      public void show() {
            super.show();
            System.out.println(&quot;With yanxian.&quot;);
      }
}
</code></pre>

<pre><code>// 其他化妆品
public class OtherDecorator extends Decorator {
      @Override
      public void show() {
            super.show();
            System.out.println(&quot;With other huazhuangpin.&quot;);
      }
}
</code></pre>

<pre><code>// 开始化妆
public class DecoratorMain {
      public static void main(String[] args) {
            Face girlFriendFace = new GirlFriend();
            Decorator fenDiFace = new FenDiDecorator();
            Decorator yanXianFace = new YanXianDecorator();
            Decorator otherFace = new OtherDecorator();

            // 给画粉底的类，设定一个Face
            fenDiFace.setFace(girlFriendFace);
            // 给画眼线的类，设定一个画过粉底的Face
            yanXianFace.setFace(fenDiFace);
            otherFace.setFace(yanXianFace);
            // 都画完之后展示出来
            otherFace.show();
      }
}

// 化完妆是这样滴...(忽略化妆的顺序啥的...我也不懂)
I am the yunnan girl.
With fendi.
With yanxian.
With other huazhuangpin.
</code></pre>

<p>装饰模式: 动态地给一个对象添加一些额外的职责，就能增加功能来说，装饰者模式比生成子类更为灵活.<br/>
<img src="media/14871457028090/14871461201224.jpg" alt="" class="mw_img_center" style="width:400px;display: block; clear:both; margin: 0 auto;"/></p>

<ul>
<li>我还在滔滔不绝的说着，只听到</li>
<li>&quot;哎呀，太墨迹了，不画了&quot;</li>
<li>我: &quot;别啊，你这还没画完啊，那还不如不画呢&quot;</li>
<li>&quot;就这样，咋地&quot;</li>
<li>我: &quot;等会儿哦，亲...&quot;</li>
</ul>

<pre><code>// 来个卸妆的装饰类
public class XieZhuangDecorator extends Decorator {
      @Override
      public void show() {
            super.show();
            System.out.println(&quot;Xie zhuang.&quot;);
      }
}
</code></pre>

<pre><code>public class DecoratorMain {
      public static void main(String[] args) {
            Face girlFriend = new GirlFriend();
            Decorator fenDiFace = new FenDiDecorator();
            Decorator yanXianFace = new YanXianDecorator();
            Decorator otherFace = new OtherDecorator();

            fenDiFace.setFace(girlFriend);
            yanXianFace.setFace(fenDiFace);
            otherFace.setFace(yanXianFace);

            // 只需要在最后的步骤上，加上一个(装饰)就行了
            Decorator xieZhuangFace = new XieZhuangDecorator();
            xieZhuangFace.setFace(otherFace);
            xieZhuangFace.show();

      }
}

// 最后的状态是卸妆了，之前的代码一点没变，只增加一个装饰类就可以了. 
I am the yunnan girl.
With fendi.
With yanxian.
With other huazhuangpin.
Xie zhuang.
</code></pre>

<ul>
<li>&quot;你看，这个模式不错吧，想改就改&quot;</li>
<li>&quot;更何况，还是素颜好看...嘿嘿嘿...&quot;</li>
<li>&quot;诶诶诶，打人不打脸...-_-&quot;</li>
</ul>

<p><strong>就这样，我和我的云南妹子过着幸福的生活.</strong></p>

<p>转载自：<a href="http://www.jianshu.com/p/53856bf285ed">http://www.jianshu.com/p/53856bf285ed</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Https完全解析 与 okHttp的结合]]></title>
    <link href="m78snail.com/14829144540758.html"/>
    <updated>2016-12-28T16:40:54+08:00</updated>
    <id>m78snail.com/14829144540758.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">一、概述</h2>

<p>　　首先要了解的事，okhttp默认情况下是支持https协议的网站的，比如<br/>
<a href="https://www.baidu.com">https://www.baidu.com</a> <a href="https://github.com/hongyangAndroid/okhttp-utils">https://github.com/hongyangAndroid/okhttp-utils</a> 等， 你可以直接通过okhttp请求试试。不过要注意的是，支持的https的网站基本都是CA机构颁发的证书，默认情况下是可以信任的。</p>

<span id="more"></span><!-- more -->

<p>　　当然我们今天要说的是自签名的网站，什么叫自签名呢？就是自己通过keytool去生成一个证书，然后使用，并不是CA机构去颁发的。使用自签名证书的网站，大家在使用浏览器访问的时候，一般都是报风险警告，好在有个大名鼎鼎的网站就是这么干的，<a href="https://kyfw.12306.cn/otn/%EF%BC%8C">https://kyfw.12306.cn/otn/，</a> 点击进入12306的购票页面就能看到了。<br/>
　　如下界面：<br/>
　　<img src="media/14812722672589/14812727587733.jpg" alt=""/></p>

<p>　　大家可以尝试拿okhttp访问下:</p>

<pre><code>OkHttpClientManager.getAsyn
    (&quot;https://kyfw.12306.cn/otn/&quot;, callack);    
</code></pre>

<p>　　好了，本篇博文当然不是去说如何去访问12306，而是以12306为例子来说明如何去访问自签名证书的网站。因为部分开发者app与自己服务端交互的时候可能也会遇到自签名证书的。甚至在开发安全级别很高的app时，需要用到双向证书的验证。</p>

<p>那么本篇博文的基本内容包含：</p>

<ul>
<li>https一些相关的知识</li>
<li>okhttp访问自签名https网站</li>
<li>如何构建一个支持https的服务器（这里主要为了测试多个证书的时候，如何去加载）</li>
<li>如何进行双向证书验证</li>
</ul>

<h2 id="toc_1">二、Https相关知识</h2>

<p>　　关于特别理论的东西大家可以百度下自己去了解下，这里就简单说一下，HTTPS相当于HTTP的安全版本了，为什么安全呢？</p>

<p>　　因为它在HTTP的之下加入了SSL (Secure Socket Layer)，安全的基础就靠这个SSL了。SSL位于TCP/IP和HTTP协议之间，那么它到底能干嘛呢？<br/>
它能够：</p>

<ul>
<li> 认证用户和服务器，确保数据发送到正确的客户机和服务器；(验证证书)</li>
<li>加密数据以防止数据中途被窃取；（加密）</li>
<li>维护数据的完整性，确保数据在传输过程中不被改变。（摘要算法）</li>
</ul>

<p>　　下面我们简单描述下HTTPS的工作原理，大家就能对应的看到上面3条作用的身影了：<br/>
　　HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。握手过程的简单描述如下：<br/>
　　1. 浏览器将自己支持的一套加密算法、HASH算法发送给网站。<br/>
　　2.网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。<br/>
　　3. 浏览器获得网站证书之后，开始验证证书的合法性，如果证书信任，则生成一串随机数字作为通讯过程中对称加密的秘钥。然后取出证书中的公钥，将这串数字以及HASH的结果进行加密，然后发给网站。<br/>
　　4. 网站接收浏览器发来的数据之后，通过私钥进行解密，然后HASH校验，如果一致，则使用浏览器发来的数字串使加密一段握手消息发给浏览器。<br/>
　　5. 浏览器解密，并HASH校验，没有问题，则握手结束。接下来的传输过程将由之前浏览器生成的随机密码并利用对称加密算法进行加密。 <br/>
　　<br/>
　　握手过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私信息的传输。<br/>
　　根据上面的流程，我们可以看到服务器端会有一个证书，在交互过程中客户端需要去验证证书的合法性，对于权威机构颁发的证书当然我们会直接认为合法。对于自己造的证书，那么我们就需要去校验合法性了，也就是说我们只需要让OkhttpClient去信任这个证书就可以畅通的进行通信了。</p>

<p>　　当然，对于自签名的网站的访问，网上的部分的做法是直接设置信任所有的证书，对于这种做法肯定是有风险的，所以这里我们不去介绍了，有需要自己去查。</p>

<p>　　下面我们去考虑，如何让OkHttpClient去信任我们的证书，接下里的例子就是靠12306这个福利站点了。</p>

<p>　　首先导出12306的证书，这里12306提供了下载地址：<a href="https://kyfw.12306.cn/otn/">12306证书点击下载</a></p>

<p>　　下载完成，解压拿到里面的srca.cer，一会需要使用。ps:即使没有提供下载，也可以通过浏览器导出的，自行百度。</p>

<h2 id="toc_2">三、代码</h2>

<h3 id="toc_3">（一）、访问自签名的网站</h3>

<p>　　首先把我们下载的srca.cer放到assets文件夹下，其实你可以随便放哪，反正能读取到就行。</p>

<p>　　然后在我们的OkHttpClientManager里面添加如下的方法：</p>

<pre><code>
public void setCertificates(InputStream... certificates)
{
    try
    {
        CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);
        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
        keyStore.load(null);
        int index = 0;
        for (InputStream certificate : certificates)
        {
            String certificateAlias = Integer.toString(index++);
            keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate(certificate));

            try
            {
                if (certificate != null)
                    certificate.close();
            } catch (IOException e)
            {
            }
        }

        SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);

        TrustManagerFactory trustManagerFactory = 
            TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); 

        trustManagerFactory.init(keyStore);
        sslContext.init
            (   
                null, 
                trustManagerFactory.getTrustManagers(), 
                new SecureRandom()
            );
       mOkHttpClient.setSslSocketFactory(sslContext.getSocketFactory());


    } catch (Exception e)
    {
        e.printStackTrace();
    } 

}
</code></pre>

<p>　　为了代码可读性，我把异常捕获的部分简化了，可以看到我们提供了一个方法传入InputStream流，InputStream就对应于我们证书的输入流。<br/>
　　代码内部，我们：<br/>
　　　　</p>

<ul>
<li><p>构造CertificateFactory对象，通过它的generateCertificate(is)方法得到Certificate。</p></li>
<li><p>然后讲得到的Certificate放入到keyStore中。</p></li>
<li><p>接下来利用keyStore去初始化我们的TrustManagerFactory</p></li>
<li><p>由trustManagerFactory.getTrustManagers获得TrustManager[]初始化我们的SSLContext</p></li>
<li><p>最后，设置我们mOkHttpClient.setSslSocketFactory即可。</p></li>
</ul>

<p>　　这样就完成了我们代码的编写，其实挺短的，当客户端进行SSL连接时，就可以根据我们设置的证书去决定是否信任服务端的证书。</p>

<p>　　记得在Application中进行初始化：<br/>
　　</p>

<pre><code>
public class MyApplication extends Application
{
   @Override
    public void onCreate()
    {
        super.onCreate();

        try
        {
            OkHttpClientManager.getInstance()
                    .setCertificates(getAssets().open(&quot;srca.cer&quot;));
        } catch (IOException e)
        {
            e.printStackTrace();
        }


}
</code></pre>

<p>　　到这就可以看到使用Okhttp可以很方便的应对自签名的网站的访问，只需要拿到包含公钥的证书即可。</p>

<h3 id="toc_4">（二）、使用字符串替代证书</h3>

<pre><code>zhydeMacBook-Pro:temp zhy$ keytool -printcert -rfc -file srca.cer
-----BEGIN CERTIFICATE-----
MIICmjCCAgOgAwIBAgIIbyZr5/jKH6QwDQYJKoZIhvcNAQEFBQAwRzELMAkGA1UEBhMCQ04xKTAn
BgNVBAoTIFNpbm9yYWlsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MQ0wCwYDVQQDEwRTUkNBMB4X
DTA5MDUyNTA2NTYwMFoXDTI5MDUyMDA2NTYwMFowRzELMAkGA1UEBhMCQ04xKTAnBgNVBAoTIFNp
bm9yYWlsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MQ0wCwYDVQQDEwRTUkNBMIGfMA0GCSqGSIb3
DQEBAQUAA4GNADCBiQKBgQDMpbNeb34p0GvLkZ6t72/OOba4mX2K/eZRWFfnuk8e5jKDH+9BgCb2
9bSotqPqTbxXWPxIOz8EjyUO3bfR5pQ8ovNTOlks2rS5BdMhoi4sUjCKi5ELiqtyww/XgY5iFqv6
D4Pw9QvOUcdRVSbPWo1DwMmH75It6pk/rARIFHEjWwIDAQABo4GOMIGLMB8GA1UdIwQYMBaAFHle
tne34lKDQ+3HUYhMY4UsAENYMAwGA1UdEwQFMAMBAf8wLgYDVR0fBCcwJTAjoCGgH4YdaHR0cDov
LzE5Mi4xNjguOS4xNDkvY3JsMS5jcmwwCwYDVR0PBAQDAgH+MB0GA1UdDgQWBBR5XrZ3t+JSg0Pt
x1GITGOFLABDWDANBgkqhkiG9w0BAQUFAAOBgQDGrAm2U/of1LbOnG2bnnQtgcVaBXiVJF8LKPaV
23XQ96HU8xfgSZMJS6U00WHAI7zp0q208RSUft9wDq9ee///VOhzR6Tebg9QfyPSohkBrhXQenvQ
og555S+C3eJAAVeNCTeMS3N/M5hzBRJAoffn3qoYdAO1Q8bTguOi+2849A==
-----END CERTIFICATE-----
</code></pre>

<p>　　使用keytool命令，以rfc样式输出。keytool命令是JDK里面自带的。</p>

<p>　　有了这个字符串以后，我们就不需要srca.cer这个文件了，直接编写以下代码：</p>

<pre><code>public class MyApplication extends Application
{
    private String CER_12306 = &quot;-----BEGIN CERTIFICATE-----\n&quot; +
            &quot;MIICmjCCAgOgAwIBAgIIbyZr5/jKH6QwDQYJKoZIhvcNAQEFBQAwRzELMAkGA1UEBhMCQ04xKTAn\n&quot; +
            &quot;BgNVBAoTIFNpbm9yYWlsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MQ0wCwYDVQQDEwRTUkNBMB4X\n&quot; +
            &quot;DTA5MDUyNTA2NTYwMFoXDTI5MDUyMDA2NTYwMFowRzELMAkGA1UEBhMCQ04xKTAnBgNVBAoTIFNp\n&quot; +
            &quot;bm9yYWlsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MQ0wCwYDVQQDEwRTUkNBMIGfMA0GCSqGSIb3\n&quot; +
            &quot;DQEBAQUAA4GNADCBiQKBgQDMpbNeb34p0GvLkZ6t72/OOba4mX2K/eZRWFfnuk8e5jKDH+9BgCb2\n&quot; +
            &quot;9bSotqPqTbxXWPxIOz8EjyUO3bfR5pQ8ovNTOlks2rS5BdMhoi4sUjCKi5ELiqtyww/XgY5iFqv6\n&quot; +
            &quot;D4Pw9QvOUcdRVSbPWo1DwMmH75It6pk/rARIFHEjWwIDAQABo4GOMIGLMB8GA1UdIwQYMBaAFHle\n&quot; +
            &quot;tne34lKDQ+3HUYhMY4UsAENYMAwGA1UdEwQFMAMBAf8wLgYDVR0fBCcwJTAjoCGgH4YdaHR0cDov\n&quot; +
            &quot;LzE5Mi4xNjguOS4xNDkvY3JsMS5jcmwwCwYDVR0PBAQDAgH+MB0GA1UdDgQWBBR5XrZ3t+JSg0Pt\n&quot; +
            &quot;x1GITGOFLABDWDANBgkqhkiG9w0BAQUFAAOBgQDGrAm2U/of1LbOnG2bnnQtgcVaBXiVJF8LKPaV\n&quot; +
            &quot;23XQ96HU8xfgSZMJS6U00WHAI7zp0q208RSUft9wDq9ee///VOhzR6Tebg9QfyPSohkBrhXQenvQ\n&quot; +
            &quot;og555S+C3eJAAVeNCTeMS3N/M5hzBRJAoffn3qoYdAO1Q8bTguOi+2849A==\n&quot; +
            &quot;-----END CERTIFICATE-----&quot;;

    @Override
    public void onCreate()
    {
        super.onCreate();

        OkHttpClientManager.getInstance()
                .setCertificates(new Buffer()
                        .writeUtf8(CER_12306)
                        .inputStream());
}
</code></pre>

<h2 id="toc_5">四. tomcat下使用自签名证书部署服务</h2>

<h3 id="toc_6">（一）生成证书</h3>

<p>　　如何生成证书呢？使用keytool非常简单。</p>

<pre><code>zhydeMacBook-Pro:temp zhy$ keytool -genkey -alias zhy_server -keyalg RSA -keystore zhy_server.jks -validity 3600 -storepass 123456
您的名字与姓氏是什么?
  [Unknown]:  zhang
您的组织单位名称是什么?
  [Unknown]:  zhang
您的组织名称是什么?
  [Unknown]:  zhang
您所在的城市或区域名称是什么?
  [Unknown]:  xian
您所在的省/市/自治区名称是什么?
  [Unknown]:  shanxi
该单位的双字母国家/地区代码是什么?
  [Unknown]:  cn
CN=zhang, OU=zhang, O=zhang, L=xian, ST=shanxi, C=cn是否正确?
  [否]:  y

输入 &lt;zhy_server&gt; 的密钥口令
    (如果和密钥库口令相同, 按回车):   
</code></pre>

<p>　　使用以上命令即可生成一个证书请求文件zhy_server.jks，注意密钥库口令为：123456.</p>

<p>接下来利用zhy_server.jks来签发证书：</p>

<pre><code>zhydeMacBook-Pro:temp zhy$ keytool -export -alias zhy_server 
 -file zhy_server.cer 
 -keystore zhy_server.jks 
 -storepass 123456 
</code></pre>

<p>　　即可生成包含公钥的证书zhy_server.cer。</p>

<h3 id="toc_7">(二)、配置Tomcat</h3>

<p>　　找到tomcat/conf/sever.xml文件，并以文本形式打开。<br/>
在Service标签中，加入：</p>

<pre><code>&lt;Connector SSLEnabled=&quot;true&quot; acceptCount=&quot;100&quot; clientAuth=&quot;false&quot; 
    disableUploadTimeout=&quot;true&quot; enableLookups=&quot;true&quot; keystoreFile=&quot;&quot; keystorePass=&quot;123456&quot; maxSpareThreads=&quot;75&quot; 
    maxThreads=&quot;200&quot; minSpareThreads=&quot;5&quot; port=&quot;8443&quot; 
    protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; scheme=&quot;https&quot; 
    secure=&quot;true&quot; sslProtocol=&quot;TLS&quot;
    /&gt;
</code></pre>

<p>　　注意keystoreFile的值为我们刚才生成的jks文件的路径：/Users/zhy/ <br/>
temp/zhy_server.jks(填写你的路径).keystorePass值为密钥库密码:123456。</p>

<p>　　然后启动即可，对于命令行启动，依赖环境变量JAVA_HOME；如果在MyEclispe等IDE下启动就比较随意了。</p>

<p>　　启动成功以后，打开浏览器输入url:<a href="https://localhost:8443/%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E8%AF%81%E4%B9%A6%E4%B8%8D%E5%8F%AF%E4%BF%A1%E4%BB%BB%E7%9A%84%E8%AD%A6%E5%91%8A%E4%BA%86%E3%80%82%E9%80%89%E6%8B%A9%E6%89%93%E6%AD%BB%E4%B9%9F%E8%A6%81%E8%BF%9B%E5%85%A5%EF%BC%8C%E5%8D%B3%E5%8F%AF%E8%BF%9B%E5%85%A5tomcat%E9%BB%98%E8%AE%A4%E7%9A%84%E4%B8%BB%E9%A1%B5%EF%BC%9A">https://localhost:8443/即可看到证书不可信任的警告了。选择打死也要进入，即可进入tomcat默认的主页：</a><br/>
<img src="media/14829144540758/14829153068405.jpg" alt="" class="mw_img_center" style="width:200px;display: block; clear:both; margin: 0 auto;"/></p>

<p>　　如果你在此tomcat中部署了项目，即可按照如下url方式访问： <br/>
<a href="https://192.168.1.103:8443/%E9%A1%B9%E7%9B%AE%E5%90%8D/path%EF%BC%8C%E6%B2%A1%E6%9C%89%E9%83%A8%E7%BD%B2%E4%B9%9F%E6%B2%A1%E5%85%B3%E7%B3%BB%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%8B%BF%E9%BB%98%E8%AE%A4%E7%9A%84%E4%B8%BB%E9%A1%B5%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%BA%86%EF%BC%8C%E6%8B%BF%E5%AE%83%E7%9A%84html%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%82">https://192.168.1.103:8443/项目名/path，没有部署也没关系，直接拿默认的主页进行测试了，拿它的html字符串。</a></p>

<p>　　对于访问，还需要说么，我们刚才已经生成了zhy_server.cer证书。你可以选择copy到assets，或者通过命令拿到内部包含的字符串。我们这里选择copy。</p>

<p>　　依然选择在Application中设置信任证书：</p>

<pre><code>public class MyApplication extends Application
{
    private String CER_12306 = &quot;省略...&quot;;

    @Override
    public void onCreate()
    {
        super.onCreate();

        try
        {
            OkHttpClientManager.getInstance()
            .setCertificates(
                    new Buffer()
                    .writeUtf8(CER_12306).inputStream(),
                     getAssets().open(&quot;zhy_server.cer&quot;)
                    );
        } catch (IOException e)
        {
            e.printStackTrace();
        }

    }
}
</code></pre>

<p>　　ok，这样就能正常访问你部署的https项目中的服务了，没有部署项目的尝试拿https://服务端ip:8443/测试即可。</p>

<p>　　注意：不要使用localhost，真机测试保证手机和服务器在同一局域网段内。</p>

<p>　　ok，到此我们介绍完了如果搭建https服务和如何访问，基本上可以应付极大部分的需求了。当然还是极少数的应用需要双向证书验证，比如银行、金融类app，我们一起来了解下。</p>

<p>　　我们已经生成了zhy_server.kjs和zhy_server.cer文件。</p>

<p>　　接下来按照生成证书的方式，再生成一对这样的文件，我们命名为:zhy_client.kjs,zhy_client.cer.</p>

<h2 id="toc_8">五、双向证书验证</h2>

<p>　　首先对于双向证书验证，也就是说，客户端也会有个“kjs文件”，服务器那边会同时有个“cer文件”与之对应。</p>

<p>　　我们已经生成了zhy_server.kjs和zhy_server.cer文件。</p>

<p>　　接下来按照生成证书的方式，再生成一对这样的文件，我们命名为:zhy_client.kjs,zhy_client.cer.</p>

<h2 id="toc_9">（一）配置服务端</h2>

<p>　　首先我们配置服务端：<br/>
服务端的配置比较简单，依然是刚才的Connector标签，不过需要添加些属性。</p>

<pre><code>&lt;Connector  其他属性与前面一致  
    clientAuth=&quot;true&quot;
    truststoreFile=&quot;/Users/zhy/temp/zhy_client.cer&quot; 
      /&gt; 
</code></pre>

<p>　　将clientAuth设置为true，并且多添加一个属性truststoreFile，理论上值为我们的cer文件。这么加入以后，尝试启动服务器，会发生错误：Invalid keystore format。说keystore的格式不合法。</p>

<p>　　我们需要对zhy_client.cer执行以下步骤，将证书添加到kjs文件中。</p>

<pre><code>keytool -import -alias zhy_client 
    -file zhy_client.cer -keystore zhy_client_for_sever.jks
</code></pre>

<p>接下里修改server.xml为：</p>

<pre><code>&lt;Connector  其他属性与前面一致 
    clientAuth=&quot;true&quot;
    truststoreFile=&quot;/Users/zhy/temp/zhy_client_for_sever.jks&quot; 
      /&gt; 
</code></pre>

<p>此时启动即可。</p>

<p>此时再拿浏览器已经无法访问到我们的服务了，会显示基于证书的身份验证失败。</p>

<p>我们将目标来到客户端，即我们的Android端，我们的Android端，如何设置kjs文件呢。</p>

<h3 id="toc_10">（二）配置app端</h3>

<p>　　目前我们app端依靠的应该是zhy_client.kjs。</p>

<p>　　ok，大家还记得，我们在支持https的时候调用了这么俩行代码：</p>

<pre><code>sslContext.init(null, trustManagerFactory.getTrustManagers(), 
    new SecureRandom());
mOkHttpClient.setSslSocketFactory(sslContext.getSocketFactory());
</code></pre>

<p>　　注意sslContext.init的第一个参数我们传入的是null，第一个参数的类型实际上是KeyManager[] km,主要就用于管理我们客户端的key。</p>

<p>于是代码可以这么写：</p>

<pre><code>public void setCertificates(InputStream... certificates)
{
    try
    {
        CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);
        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
        keyStore.load(null);
        int index = 0;
        for (InputStream certificate : certificates)
        {
            String certificateAlias = Integer.toString(index++);
            keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate(certificate));

            try
            {
                if (certificate != null)
                    certificate.close();
            } catch (IOException e)
            {
            }
        }

        SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.
                getInstance(TrustManagerFactory.getDefaultAlgorithm());
        trustManagerFactory.init(keyStore);

        //初始化keystore
        KeyStore clientKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());
        clientKeyStore.load(mContext.getAssets().open(&quot;zhy_client.jks&quot;), &quot;123456&quot;.toCharArray());

        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        keyManagerFactory.init(clientKeyStore, &quot;123456&quot;.toCharArray());

        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom());
        mOkHttpClient.setSslSocketFactory(sslContext.getSocketFactory());


    } catch (Exception e)
    {
        e.printStackTrace();
    } 

}
</code></pre>

<p>核心代码其实就是：</p>

<pre><code>//初始化keystore
KeyStore clientKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());
clientKeyStore.load(mContext.getAssets().open(&quot;zhy_client.jks&quot;), &quot;123456&quot;.toCharArray());

KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
keyManagerFactory.init(clientKeyStore, &quot;123456&quot;.toCharArray());

sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom());
</code></pre>

<p>　　然而此时启动会报错：Java.io.IOException: Wrong version of key store.</p>

<p>为什么呢？</p>

<p>　　因为：Java平台默认识别jks格式的证书文件，但是android平台只识别bks格式的证书文件。</p>

<p>　　这么就纠结了，我们需要将我们的jks文件转化为bks文件，怎么转化呢？</p>

<p>　　这里的方式可能比较多，大家可以百度，我推荐一种方式：</p>

<p>–</p>

<p>　　去<a href="http://sourceforge.net/projects/portecle/files/">Portecle</a>下载<a href="http://sourceforge.net/projects/portecle/files/latest/download?source=files">Download portecle-1.9.zip (3.4 MB)</a>。</p>

<p>　　解压后，里面包含bcprov.jar文件，使用jave -jar bcprov.jar即可打开GUI界面。<br/>
<img src="media/14829144540758/14829160331258.jpg" alt="" class="mw_img_center" style="width:300px;display: block; clear:both; margin: 0 auto;"/><br/>
　　按照上图即可将zhy_client.jks转化为zhy_client.bks。</p>

<p>　　然后将zhy_client.bks拷贝到assets目录下，修改代码为：</p>

<pre><code>//初始化keystore
KeyStore clientKeyStore = KeyStore.getInstance(&quot;BKS&quot;);
clientKeyStore.load(mContext.getAssets().open(&quot;zhy_client.bks&quot;), &quot;123456&quot;.toCharArray());

KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
keyManagerFactory.init(clientKeyStore, &quot;123456&quot;.toCharArray());

sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom());
</code></pre>

<p>　　再次运行即可。然后就成功的做到了双向的验证，关于双向这块大家了解下即可。</p>

<p>源码都在<a href="https://github.com/hongyangAndroid/okhttp-utils">https://github.com/hongyangAndroid/okhttp-utils</a>之中。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用力的人跑不远]]></title>
    <link href="m78snail.com/14779864279806.html"/>
    <updated>2016-11-01T15:47:07+08:00</updated>
    <id>m78snail.com/14779864279806.html</id>
    <content type="html"><![CDATA[
<p>写在前面：有阶段的自己，会用蛮力去学习一些东西，就是这东西不管是否适合目前自己的知识体系， 觉得学了之后会更牛逼就去学，但是这样的东西往往学了记不住。 学习的过程越用力反而显得越吃力， 太吃力的事情，自然就无法有恒心， 这就是很多人会觉得自己做事总是无法持之以恒的原因。</p>

<span id="more"></span><!-- more -->

<p>努力不应该是某种需要被时常觉知的东西，意志力是短期内会用完的精神能量。</p>

<p>真正坚持到最后的人靠的不是激情，而是恰到好处的喜欢和投入。</p>

<p>太用力的人更容易产生期望落差，更不愿接受自己找错了方向的事实——没有什么比这样的“失落”更能让人心寒的了，太用力的人大多都因心累而倒在了半途中。</p>

<p>精神上的用力并不会让你跑得更快，但是精神上的疲惫却可以让你停下。</p>

<p>人越用力，就会越想要得到及时的良好刺激。越用力的人对于正刺激的需求就越高，越不能忍受暂时的负反馈。遗憾的是，人生常常是没有下文的考卷，这种刺激来得太慢、太不稳定。</p>

<p>真正的坚持归于平静，靠的是温和的发力，而不是时时刻刻的刺激。</p>

<p>太用力的人增加了执行的功耗。纠结，是太用力的一种表现，造成内部的运转处于空转的状态——意识与行动的主观脱节；从心所欲，就是把运转效率最大化后的结果——所想即所为。执行阶段最大的敌人，是纠结，是埋怨，是内心的冲突——太用力，就是心理额外动作太多。想好之后就只管去做。</p>

<p>我一直告诫自己不要用力过猛，以保持自己对困难的顿感和不顺的接受程度。<br/>
短期的过度用力极容易造成身体和心理上的挫伤。哪怕你在做的事情非常重要，也要保证基本的休息和放松。</p>

<p>不论是以后的工作还是将来的创业，都要保持一颗平常心。你需要更多的“寸劲”而不是“用力感”。在找到受力点“all in”之前，一切都要顺势而行，自然随和。</p>

<p>人在学习的过程会经历一系列的过程，先是笨拙期，再是熟练期——这两个过程他虽然能运用出技能，但是头脑中仍然能感受到使用时的提取感。这两个阶段都需要用力，但是用力的程度却大幅度减小。</p>

<p>技能掌握的最后阶段是运用自如期，就是张三丰把太极拳的形态全部都忘了的阶段。这个时候头脑中已经能下意识地去进行活动，达到了能耗最低的理想阶段。</p>

<p>从用力感，到毫无感觉，是一种技能掌握上的纯熟。年轻的时候太认真是件好事，或许只有用力过了，才能体会从心所欲、顺其自然的难得。</p>

<p>IT人员怎么用力<br/>
总有在校的学生问我现在 X,Y,Z... 技术很火热，应该学哪个？ 我看他列出的那些准备学习的选项中，其实前景和热门程度都差不多。 这让他陷入了选择焦虑症，不管做什么决定都怕「一失足成千古恨」。</p>

<p>对技术发展趋势关心是好事，就像之前那篇「不要总是选择困难模式」里面说的那样。 但是其实在「不要总是选择困难模式」里面忽略了很重要的一点，就是你个人的兴趣。 比如有的人对苹果的东西有天生的热爱，所以选择「iOS开发」对他来说就更容易做好。 尽可能选择会让自己 Enjoy 的技术方向，路还很长，不享受过程的话容易半途而废。</p>

<p>『太用力的人跑不远』</p>

<p>有阶段的自己，会用蛮力去学习一些东西，就是这东西不管是否适合目前自己的知识体系， 觉得学了之后会更牛逼就去学，但是这样的东西往往学了记不住。 学习的过程越用力反而显得越吃力， 太吃力的事情，自然就无法有恒心， 这就是很多人会觉得自己做事总是无法持之以恒的原因。</p>

<p>记得之前本科的时候喜欢和舍友一起打Dota，打Dota开局之前一般要等人齐， 等人的这段时间我有时候会切出来写写代码，叫舍友开局了告诉我一声。 然后别人看到我在打Dota间隙都在写代码，就觉得我有多努力多努力，给人了一种非常「刻苦」的印象。 以至于上次和一个本科同学吃饭他还说起这个事情，觉得我能做到这样非常「牛逼」。</p>

<p>但是其实这样的事情，如果对于真的对写代码有经历过热爱的人，是不会觉得有多么刻苦的事情。 这是自然而然的事情，甚至其实有些代码，那种满足好奇心的快感，是比打游戏有意思的多， 是件很Enjoy的事情，而不是所谓的「刻苦」。</p>

<p>就像跑步，「太用力的人跑不远」。</p>

<p>『不要用蛮力去学编程』</p>

<p>记得当年初学 C++ 的同学，听别人说 C++ 很基础也很重要的一个知识点就是STL， 然后听说要学好 STL 就应该去看看侯捷的「STL源码剖析」。 然后就买了书硬啃，然后没啃几天就放弃了，觉得太讳莫如深了没法理解。</p>

<p>但是如果换个学习的方式， 先假设现在没有STL这个标准库， 让你用已有的C++语法知识去自己写一个仿造STL标准库的功能， 哪怕是最最简单的 vector 。 你在编写的时候就会自然而然得体会到内存动态扩展的一些缺点和潜在的坑。 会知道为什么适当使用 reserve 和 swap 能非常明显的提高性能。</p>

<p>然后在自己思考的过程中会提出很多相关的疑惑， 带着疑惑再去翻看「STL源码剖析」， 就会让你对一个个数据结构恍然大悟知根知底。 自然而然你的看书体验会非常的 Enjoy， 而不是觉得苦涩难咽。</p>

<p>编程和求知本身是一件愉悦身心的事情， 如果只是为了高薪，而用蛮力去写代码，只会让自己疲惫不堪。</p>

<p>『最后』</p>

<p>希望对在学习编程的路上很挣扎的朋友有所帮助。 毕竟工作是生活的很大一部分， 如果工作不开心，生活怎么办。</p>

<p>寄语<br/>
生活可能像一根弹簧，最好的状态是张弛有度，太紧-压力太大，太松-没有活力，像那位矮大紧所说的，生活不只有眼前的苟且还有诗和远方。</p>

<pre><code>文章是我在csdn上看到的，我觉得写的特别好，所以转到自己的blog来。
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 常用方法]]></title>
    <link href="m78snail.com/14779861870049.html"/>
    <updated>2016-11-01T15:43:07+08:00</updated>
    <id>m78snail.com/14779861870049.html</id>
    <content type="html"><![CDATA[
<p>下面总结一下自己在学习Git时用到的一些语法<br/>
更多详细内容请浏览：<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程 - 廖雪峰的官方网站</a></p>

<h2 id="toc_0">一 . 修改文件</h2>

<pre><code>git init：创建git
git add readme.txt ：将readme.txt变化提交到库
git status ：获取修改的状态
git diff readme.txt：获取我们与库中哪里不同
git commit :将修改提交到库中
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_1">二 . 回溯版本</h2>

<pre><code>git log：显示从最近到最远的提交日志
git log --pretty=oneline ：简化日志
git reset --hard HEAD^ ：HEAD代表当前版本，一个代表上一版
git reflog：获取记录的commit id
git reset --hard (commit id) :回溯到指定id的版本
</code></pre>

<h2 id="toc_2">三 . 撤销修改</h2>

<pre><code>git checkout -- file :撤销回到最近一次git commit或git add时的状态
git reset HEAD file : 把暂存区的修改撤销掉
</code></pre>

<h2 id="toc_3">四 . 删除文件</h2>

<pre><code>rm test.txt :删除test.txt
git rm test.txt：将删除操作提交到暂存区，commit之后版本里的删除
git checkout -- test.txt :用版本库里的版本替换工作区的版本
</code></pre>

<h2 id="toc_4">五 . 远程库</h2>

<pre><code>git remote add origin git@github.com:username/name.git :添加远程库
git push -u origin master :第一次将本地库传送到远程库
git push origin master :将本地库传送到远程库 #### 2.从远程库克隆
git clone git@github.com:username/name.git :克隆一个本地库
</code></pre>

<h2 id="toc_5">六 . 分支管理</h2>

<h3 id="toc_6">1. 创建与合并分支</h3>

<pre><code>git checkout -b dev :git checkout 命令加上-b参数表示创建分支并切换
git branch : 查看当前分支,列出所有分支
git checkout master :切换回主分支
git merge dev ：合并指定分支dev到当前分支
git branch -d dev ：删除分支dev
</code></pre>

<h3 id="toc_7">2. 解决冲突</h3>

<pre><code>git log ：看到分支的合并情况
git merge --no-ff -m &quot;merge with no-ff&quot; dev :加上--no-ff参数就可以用普通模式合并，合并后的历史有分支
</code></pre>

<h3 id="toc_8">3. Bug分支</h3>

<pre><code>git stash :把当前工作现场“储藏”起来，以后恢复现场后继续工作
git stash list :查看stash
git stash apply :恢复工作，但是恢复后，stash内容并不删除
git stash drop :删除stash
git stash pop ：恢复的同时把stash内容也删了
</code></pre>

<h3 id="toc_9">4. Feature分支</h3>

<h4 id="toc_10">(1). 多人协作</h4>

<p>先用git pull把最新的提交从origin/dev抓下来,遇到错误的话<br/>
git branch --set-upstream dev origin/dev :指定本地dev分支与远程origin/dev分支的链接，再pull<br/>
合并冲突，需要手动解决<br/>
解决后，提交，再push : git push origin dev。<br/>
git clone只能clone远程库的master分支，无法clone所有分支，解决办法如下：</p>

<pre><code>1. 找一个干净目录，假设是git_work
2. cd git_work
3. git clone http://myrepo.xxx.com/project/.git ,这样在git_work目录下得到一个project子目录
4. cd project
5. git branch -a，列出所有分支名称如下： remotes/origin/dev remotes/origin/release
6. git checkout -b dev origin/dev，作用是checkout远程的dev分支，在本地起名为dev分支，并切换到本地的dev分支
7. git checkout -b release origin/release，作用参见上一步解释
8. git checkout dev，切换回dev分支，并开始开发。
</code></pre>

<h4 id="toc_11">(2). 多人协作的工作模式通常是这样：</h4>

<p>　　首先，可以试图用git push origin branch-name推送自己的修改；</p>

<p>　　如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p>

<p>　　如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。</p>

<p>　　这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>

<h2 id="toc_12">七. Github 的使用</h2>

<p>　　如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap">https://github.com/twbs/bootstrap</a><br/>
点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</p>

<p>git clone <a href="mailto:git@github.com">git@github.com</a>:michaelliao/bootstrap.git<br/>
　　一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<a href="mailto:git@github.com">git@github.com</a>:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。<br/>
　　如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。<br/>
　　如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xUtils框架中HttpUtils模块源码剖析]]></title>
    <link href="m78snail.com/14779864962440.html"/>
    <updated>2016-11-01T15:48:16+08:00</updated>
    <id>m78snail.com/14779864962440.html</id>
    <content type="html"><![CDATA[
<p>　　xUtils是github上的一个Android开源工具项目，xUtils包含了很多实用的android工具，其中HttpUtils模块是处理网络连接部分。在我上一个项目《数据铁笼》中经常用到，作为与服务器连接的工具，所以想要深入学习一下。<br/>
　　项目最近更新到了3.0，我项目中用到的还是2.6有些方面可能和最新的有出入，请以作者最新的代码为准。<br/>
　　<a href="https://github.com/wyouflf/xUtils3">https://github.com/wyouflf/xUtils3</a><br/>
　　惯例是例举出我在学习中借鉴的一些大神的博客，以此来表示对他们的尊重</p>

<blockquote>
<ol>
<li><a href="http://kb.cnblogs.com/page/130970/#threeconcept">HTTP 协议详解</a></li>
<li><a href="http://www.tuicool.com/articles/nMFb2q">Android开源项目xUtils HttpUtils模块分析</a></li>
<li><a href="http://uule.iteye.com/blog/1539084">Future和FutureTask</a></li>
<li><a href="http://blog.csdn.net/cjj198561/article/details/40475771">xUtils异步HTTP源码分析</a></li>
</ol>
</blockquote>

<p>　　上面这些文章讲的都特别好，大家如果有时间可以都看看。</p>

<span id="more"></span><!-- more -->

<p>　　</p>

<h2 id="toc_0">一 . 以前的HttpClient 方法</h2>

<p>　　首先我先说下以前如果使用Http协议的话，我会使用Apache的HttpClient，大体上分为六步：<br/>
　　<br/>
　　<br/>
　　<strong>以Post方法为例</strong></p>

<pre><code>//第一步创建DefaultHttpClient对象
HttpClient httpClient=new DefaultHttpClient();
//第二步创建HttpPost
HttpPost post=new HttpPost(&quot;http:192.168.3.1:8080/login.jsp&quot;);
//第三步对传递参数进行封装
List&lt;NameValuePairs&gt; params=new ArrayList&lt;NameValuePair&gt;()；
params.add(new BasicNameValuePair(&quot;name&quot;,name));
params.add(new BasicNameValuePair(&quot;pass&quot;,pass));
//第四步为post设置请求参数
post.setEntity(new UriEncodedFormEntity(params,HTTP.UTF_8));
//第五步发送post请求
HttpResponse respones=httpClient.execute(post);
//第六步解析
String msg=EntityUtils.toString(respones.getEntity());
</code></pre>

<p>　　为什么这么详细的介绍Apache 的HttpClient，因为2.6版本中，使用的就是HttpClient，但是在3.0版本中已经替换HttpClient为UrlConnection，这个回来还要再研究下。现在就当复习一遍Apache的HttpClient了吧。<br/>
　　</p>

<h2 id="toc_1">二 . 上Demo，看用法</h2>

<p>废话不多说，先看看怎么用</p>

<pre><code>//第一步设置请求参数的编码
RequestParams params = new RequestParams(); // 默认编码UTF-8
//第二步根据你服务器要求的参数，进行传参
params.setHeader(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;);
JSONObject object = new JSONObject();
object.put(&quot;policenum&quot;, uLogin.getPolicenum());
object.put(&quot;taskid&quot;, taskid);
String json = JSON.toJSONString(object);
StringEntity entity=null;
try {
        entity = new StringEntity(json, &quot;UTF-8&quot;);
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }
params.setBodyEntity(entity);
//第三步调用HttpUtiles的send方法,可重写这两个方法，作为回调
http.send(HttpRequest.HttpMethod.POST, url,params, 
     new RequestCallBack&lt;String&gt;() {
        @Override
        public void onFailure(HttpException exception, String msg) {}
        @Override
        public void onSuccess(ResponseInfo&lt;String&gt; Response) {});
        }
）
</code></pre>

<h2 id="toc_2">三 . 解析源码</h2>

<h3 id="toc_3">1 . 构造函数</h3>

<p>　　首先我们使用HttpUtils模块，一般都要使用new一个HttpUtils出来，默认的构造函数为</p>

<pre><code> public HttpUtils(int connTimeout, String userAgent) {
        HttpParams params = new BasicHttpParams();
        ConnManagerParams.setTimeout(params, connTimeout);
        HttpConnectionParams.setSoTimeout(params, connTimeout);
        HttpConnectionParams.setConnectionTimeout(params, connTimeout);

        if (TextUtils.isEmpty(userAgent)) {
            userAgent = OtherUtils.getUserAgent(null);
        }
        HttpProtocolParams.setUserAgent(params, userAgent);

        ConnManagerParams.setMaxConnectionsPerRoute(params, new ConnPerRouteBean(10));
        ConnManagerParams.setMaxTotalConnections(params, 10);

        HttpConnectionParams.setTcpNoDelay(params, true);
        HttpConnectionParams.setSocketBufferSize(params, 1024 * 8);
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
  }
</code></pre>

<p>　　这里就不全部截出来了，这里会设置Http协议的一些参数，这些参数往往对于不同的服务器都是固定的，比如采用Http1.1，设置超时时间等等，当然你也可以自己设置，不调用它默认的也可以，根据自己的公司业务要求自己设置。</p>

<h3 id="toc_4">2 . send()方法</h3>

<pre><code class="language-java">public &lt;T&gt; HttpHandler&lt;T&gt; send(HttpRequest.HttpMethod method, String url, RequestParams params, RequestCallBack&lt;T&gt; callBack) {
        if (url == null) 
        throw new IllegalArgumentException(&quot;url may not be null&quot;);
        HttpRequest request = new HttpRequest(method, url);
        return sendRequest(request, params, callBack);
}
</code></pre>

<p>解释下上述参数：<br/>
　　第一个参数 method:HttpRequest.HttpMethod 里面设定好的10种；<br/>
　　第二个参数 url：服务器地址或者接口地址；<br/>
　　第三个参数 params：传给服务器的参数；<br/>
　　第四个参数 callBack：看名字就知道，服务器返回消息后回调的接口，可以重写其中的方法；</p>

<p>　　HttpHandler实际上是一个异步AsyncTask，后面我们会详细解释</p>

<h3 id="toc_5">3 . 重点解析 HttpRequest</h3>

<p>　　全部代码就不截图了HttpRequest（HttpMethod method, String uri），作为参数</p>

<pre><code class="language-java">public HttpRequest(HttpMethod method, String uri) {
        super();
        this.method = method;
        setURI(uri);
}
</code></pre>

<h4 id="toc_6">(1). setRequestParams方法</h4>

<p>主要干了三件事:</p>

<h5 id="toc_7">①保存Header头部</h5>

<pre><code class="language-java">List&lt;RequestParams.HeaderItem&gt; headerItems = param.getHeaders();
</code></pre>

<h5 id="toc_8">②保存entity整体</h5>

<pre><code class="language-java">HttpEntity entity = param.getEntity();
this.setEntity(entity);
</code></pre>

<h5 id="toc_9">③保存回调函数</h5>

<pre><code>entity.setCallBackHandler(callBackHandler);
</code></pre>

<p>　　至此Http协议中的大部分信息都保存到了<strong>HttpRequest</strong>中，函数最后运行:<br/>
　　</p>

<pre><code>handler.executeOnExecutor(EXECUTOR, request);
</code></pre>

<h3 id="toc_10">4 . HttpHandler类：</h3>

<p>　　HttpHandler继承自PriorityAsyncTask，前面我们已经说了HttpHandler实际上是一个异步AsyncTask，让我们直接去HttpHandler继承自PriorityAsyncTask里面看executeOnExecutor方法：<br/>
　　</p>

<pre><code>//EXECUTOR：线程池
//params：参数也就是HttpRequest
public final PriorityAsyncTask&lt;Params,Progress,Result&gt;executeOnExecutor(Executor exec,Params... params) {
        if (mExecuteInvoked) {
            throw new IllegalStateException(&quot;Cannot execute task:&quot;
                    + &quot; the task is already executed.&quot;);
        }

        mExecuteInvoked = true;

        onPreExecute();

        mWorker.mParams = params;
        exec.execute(new PriorityRunnable(priority, mFuture));

       return this;
}
</code></pre>

<pre><code>解释下：

mWorker.mParams = params;
...
private static abstract class WorkerRunnable&lt;Params,Result&gt;implements Callable&lt;Result&gt; {
        Params[] mParams;
    }
</code></pre>

<p>　　mWorker是一个Callable，用于后面的调用这点很重要，因为最后其实就是调用的mWork；</p>

<pre><code class="language-java"> exec.execute(new PriorityRunnable(priority, mFuture));
</code></pre>

<p>　　调用PriorityObject的run方法，会去调用mFuture的run方法，mFuture是一个FutureTask，为什么前面说最后其实会去调用mWorker呢，注意mFuture定义的地方：<br/>
　　</p>

<pre><code>  mFuture = new FutureTask&lt;Result&gt;(mWorker) {
            @Override
            protected void done() {
               ...
            }
  };
</code></pre>

<p>　　我们去找FutureTask的run函数，翻开FutureTask的源码，找到run的源码</p>

<pre><code>public void run() {
       ....
        try {
            Callable&lt;V&gt; c = callable;
            if (c != null &amp;&amp; state == NEW) {
                V result;
                boolean ran;
                try {
        //////////////////////////////这里调用的mWorker的call方法
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex);
                }
                if (ran)
                    set(result);
            }
        } finally {
            ....
        }
}
</code></pre>

<p>　　也就是说最终会去调用mWork的call()方法，那就让我们看看call（）方法<br/>
　　</p>

<pre><code>mWorker = new WorkerRunnable&lt;Params, Result&gt;() {
            public Result call() throws Exception {
              ....
                return postResult(doInBackground(mParams));
            }
};
</code></pre>

<p>　　最终会去最后的BOSS级代码，HttpHandler的doInBackground，其实上面的一系列方法很好理解，就是为了创建异步AsyncTask，以前都只是直接拿AsyncTask来用，根本没想过自己实现一个，分析源码也算是对我自己的一个学习，好了不感概了看一下doInBackground（）：<br/>
首先肯定是要取出来之前保存在HttpRequest里面的各种参数.</p>

<pre><code>request = (HttpRequestBase) params[0];
requestUrl = request.getURI().toString();
</code></pre>

<p>　　接下来就是重头戏发送请求</p>

<pre><code>ResponseInfo&lt;T&gt; responseInfo = sendRequest(request);
</code></pre>

<p>　　看一下sendRequest（）方法：</p>

<pre><code>    ...
 ResponseInfo&lt;T&gt; responseInfo = null;
 if (!isCancelled()) {
    HttpResponse response = client.execute(request, context);
                    responseInfo = handleResponse(response);
                }
    return responseInfo;
    ...
</code></pre>

<p>　　最后调用</p>

<pre><code>this.publishProgress(UPDATE_SUCCESS, responseInfo);
....
case UPDATE_SUCCESS:
        if (values.length != 2) return;
        this.state = State.SUCCESS;
        //回调callback
        callback.onSuccess((ResponseInfo&lt;T&gt;) values[1]);
        break;
</code></pre>

<p>　　xUtils里面还有很多细节我没有说到，大家可以自己去研究下。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[otto 框架分析]]></title>
    <link href="m78snail.com/14779857522449.html"/>
    <updated>2016-11-01T15:35:52+08:00</updated>
    <id>m78snail.com/14779857522449.html</id>
    <content type="html"><![CDATA[
<p>　　最近项目上经常会用到otto框架，它跟EventBus很像，这里希望总结一下：<br/>
　　</p>

<blockquote>
<ul>
<li>运行时动态处理（注解）</li>
<li>IOC 控制反转</li>
<li>观察者模式 EventBus模式</li>
</ul>
</blockquote>

<p>　　大体上要学习otto框架就是上面三个方面，看着名词很高端？没事，让我一一解释一下。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">一 . 运行时动态处理（注解）</h2>

<p>　　我们最初学习安卓的时候最先接触的类恐怕就是Activity了吧，在里面onCreate()这些方法会要求我们重写，在上面会有一个注解@Override,难道仅仅起到注释的作用吗？其实注解分为两种<br/>
　　① 运行时动态处理：在运行时拿到类的Class对象，然后遍历其方法、变量，判断有无注解声明，然后做一些事情<br/>
　　② 编译时动态处理：这类注解会在编译的时候，根据注解标识，动态生成一些类或者生成一些xml都可以，在运行时期，这类注解是没有的~~会依靠动态生成的类做一些操作，因为没有反射，效率和直接调用方法没什么区别<br/>
　　今天我们只研究运行时动态处理。<br/>
　　有句话说得好，叫<strong>无反射没框架</strong>。<br/>
　　任何框架都离不开反射，反射以前只在书本上了解过就是运行时获取对象的类方法，变量吗.现在反射在速度上已经有了很大的提高，我们完全不必担心性能方面会变差很多。<br/>
　　说了半天，你只要记住注解，作为一种标志，可以帮你在你的类加载时替你记住那些你希望以后用来调用的方法和对象。<br/>
　　在otto中最重要的两个注解就是@Subscribe和@Produce，这两个是什么作用等下再说。</p>

<h2 id="toc_1">二 . IOC 控制反转</h2>

<p>　　什么事IOC控制反转？<br/>
　　当A类想使用B类的一个方法时，我们传统的做法是new一个B类实例出来，再去调用方法，但是这就使得A,B两个类纠缠在一起。当我们改变了B类时，所有调用了B类的文件我们都需要去改，这样是不是太麻烦，好的做法是写一个主线类，它会自动帮我们去注入（new）,当我们需要改动时，只要改这个主线类就可以了。这个主线类也就是我要提到的otto框架中的Bus类，这是otto最重要的类，它有什么作用？这玩意就是在类加载时调用register，扫描类中复合命名规范的方法，存到一个map，然后post的时候，查找到匹配的方法，反射调用。不理解？等下我们举个例子你就明白了，现在我们先解释完名词。</p>

<h2 id="toc_2">三 . 观察者模式 EventBus模式</h2>

<p>　　otto框架是基于EventBus框架，这是一个是一个发布 / 订阅的事件总线，大家可以看下鸿洋大神的这篇<a href="http://blog.csdn.net/lmj623565791/article/details/40794879">Android EventBus实战 没听过你就out了</a>讲的特别好</p>

<h2 id="toc_3">四 . 应用实战</h2>

<p>　　任何一个App都一定会提供软件更新功能，当我们在更新过程中突然不想更新了，点击了取消，让我们的代码去调用SplashActivity里面的DoCancelUpdate方法。由于我们的下载更新类是写在UpdateManager类里面，那我们怎么做呢，没学会otto框架之前我们可能会在新建UpdateManager时传进去一个Context，这会不会导致Context引发的内存泄漏，我们需要很小心的检查，现在我们使用otto框架就不需要担心这个问题，因为他们两人几乎没有交集，他们都是通过Bus类来沟通。废话不多说上代码：</p>

<h3 id="toc_4">1 . SplashActivity中让bus注册，并订阅事件</h3>

<pre><code class="language-python">   @Override
    protected void onCreate(Bundle arg0) {
        super.onCreate(arg0);
        BusProvider.getInstance().register(this);
        setContentView(getLayoutResource());
    }
    
    @Subscribe
    public void DoCancelUpdate(CancelUpdateEvent event){
        continueRun();
    } 
</code></pre>

<h3 id="toc_5">2 . BusProvider为一个单例模式类，Bus最好只有一个</h3>

<pre><code class="language-python">public class BusProvider {

    public static Bus bus;

    public static Bus getInstance() {
        if (bus == null) {
            bus = new Bus(ThreadEnforcer.ANY);
        }
        return bus;
    }

    private BusProvider() {
    
    }
}
</code></pre>

<h3 id="toc_6">3 . UpdateManager类中使用post发出事件，凡是订阅了的都会调用</h3>

<pre><code class="language-python">BusProvider.bus.post(new CancelUpdateEvent());
</code></pre>

<p>　　至此算是完成了otto框架的总结，分享一些自己在找资料时遇到的大神博客文章：<br/>
　　<a href="http://blog.csdn.net/lmj623565791/article/details/40794879">Android EventBus实战 没听过你就out了</a><br/>
　　<a href="http://blog.csdn.net/lmj623565791/article/details/39269193">Android 进阶 教你打造 Android 中的 IOC 框架</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dagger2 使用详解(4)--原理分析]]></title>
    <link href="m78snail.com/14839485571061.html"/>
    <updated>2017-01-09T15:55:57+08:00</updated>
    <id>m78snail.com/14839485571061.html</id>
    <content type="html"><![CDATA[
<p>　　前面啰里啰嗦的介绍了Dagger2的基本使用，接下来我们再分析分析实现原理。这里不会分析Dagger2根据注解生成各种代码的原理，关于Java注解以后有机会再写一篇文章来介绍。后面主要分析的是Dagger2生成的各种类如何帮我们实现依赖注入，为了便于理解我这里选了前面相对简单的案例B来做分析。</p>

<span id="more"></span><!-- more -->

<p>　　Dagger2编译期生成的代码位于build/generated/source/apt/debug/your package name/下面:<br/>
<img src="media/14839485571061/14839503268924.jpg" alt="" class="mw_img_center" style="width:300px;display: block; clear:both; margin: 0 auto;"/></p>

<p>　　首先我们看看Dagger2依据依赖提供方MarkCarModule生成的对应工厂类MarkCarModule_ProvideEngineFactory。为了方便大家理解对比，后面我一律会把自己写的类和Dagger2生成的类一并放出来。</p>

<pre><code>/**
* 我们自己的类
*/
@Module
public class MarkCarModule {

    public MarkCarModule(){ }

    @Provides Engine provideEngine(){
        return new Engine(&quot;gear&quot;);
    }
}
</code></pre>

<pre><code>/**
* Dagger2生成的工厂类
*/
public final class MarkCarModule_ProvideEngineFactory implements Factory&lt;Engine&gt; {
  private final MarkCarModule module;

  public MarkCarModule_ProvideEngineFactory(MarkCarModule module) {
    assert module != null;
    this.module = module;
  }

  @Override
  public Engine get() {
    return Preconditions.checkNotNull(
        module.provideEngine(), &quot;Cannot return null from a non-@Nullable @Provides method&quot;);
  }

  public static Factory&lt;Engine&gt; create(MarkCarModule module) {
    return new MarkCarModule_ProvideEngineFactory(module);
  }

  /** Proxies {@link MarkCarModule#provideEngine()}. */
  public static Engine proxyProvideEngine(MarkCarModule instance) {
    return instance.provideEngine();
  }
}
</code></pre>

<p>　　我们可以看到MarkCarModule_ProvideEngineFactory中的get()调用了MarkCarModule的provideEngine()方法来获取我们需要的依赖Engine，MarkCarModule_ProvideEngineFactory的实例化有crate()创建，并且MarkCarModule的实例也是通过create()方法传进来的。那么这个create()一定会在哪里调用的，我们接着往下看。</p>

<p>　　前面提到@Component是依赖提供方(MarkCarModule)和依赖需求方(Car)之前的桥梁，那我看看Dagger2是如何通过CarComponent将两者联系起来的。</p>

<pre><code>/**
* 我们自己的类
*/
@Component(modules = {MarkCarModule.class})
public interface CarComponent {

    void inject(Car car);
}
</code></pre>

<pre><code>/**
* Dagger2生成的CarComponent实现类
*/
public final class DaggerCarComponent implements CarComponent {
  private Provider&lt;Engine&gt; provideEngineProvider;

  private MembersInjector&lt;Car&gt; carMembersInjector;

  private DaggerCarComponent(Builder builder) {
    assert builder != null;
    initialize(builder);
  }

  public static Builder builder() {
    return new Builder();
  }

  public static CarComponent create() {
    return builder().build();
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  private void initialize(final Builder builder) {

    this.provideEngineProvider = MarkCarModule_ProvideEngineFactory.create(builder.markCarModule);

    this.carMembersInjector = Car_MembersInjector.create(provideEngineProvider);
  }

  @Override
  public void inject(Car car) {
    carMembersInjector.injectMembers(car);
  }

  public static final class Builder {
    private MarkCarModule markCarModule;

    private Builder() {}

    public CarComponent build() {
      if (markCarModule == null) {
        this.markCarModule = new MarkCarModule();
      }
      return new DaggerCarComponent(this);
    }

    public Builder markCarModule(MarkCarModule markCarModule) {
      this.markCarModule = Preconditions.checkNotNull(markCarModule);
      return this;
    }
  }
}
</code></pre>

<p>　　通过上面的代码我们看到Dagger2依据CarComponent接口生成了实现类DaggerCarComponent（没错这正是我们在Car的构造函数中使用DaggerCarComponent）。DaggerCarComponent在build的时候实例化了DaggerCarComponent对象，并首先调用MarkCarModule_ProvideEngineFactory.create(builder.markCarModule)始化了provideEngineProvider变量，接着调用Car_MembersInjector.create(provideEngineProvider)初始化了carMembersInjector变量。当我们手动在Car类的构造函数中调用inject(Car car)方法时会执行carMembersInjector.injectMembers(car)。所以接下来我们要看看Car_MembersInjector的实现。</p>

<pre><code>public final class Car_MembersInjector implements MembersInjector&lt;Car&gt; {
  private final Provider&lt;Engine&gt; engineProvider;

  public Car_MembersInjector(Provider&lt;Engine&gt; engineProvider) {
    assert engineProvider != null;
    this.engineProvider = engineProvider;
  }

  public static MembersInjector&lt;Car&gt; create(Provider&lt;Engine&gt; engineProvider) {
    return new Car_MembersInjector(engineProvider);
  }

  @Override
  public void injectMembers(Car instance) {
    if (instance == null) {
      throw new NullPointerException(&quot;Cannot inject members into a null reference&quot;);
    }
    instance.engine = engineProvider.get();
  }

  public static void injectEngine(Car instance, Provider&lt;Engine&gt; engineProvider) {
    instance.engine = engineProvider.get();
  }
}
</code></pre>

<p>Car_MembersInjector中的create()用于实例化自己，这个方法前面我们看到是在DaggerCarComponent中调用的。injectMembers(Car instance)将engineProvider.get()的返回值赋给了依赖需求方Car的engine变量，而engineProvider.get()正是本节一开始我们提到的MarkCarModule_ProvideEngineFactory中的get()方法。至此整个依赖注入的流程就完成了。更复杂的应用场景会生成更加复杂的代码，但原理都和前面分析的大同小异。</p>

<p>总结</p>

<p>这篇文章只是通过一些简单的例子介绍了Dagger2的相关概念及使用，实际项目中的应用远比这里的例子要复杂。关于Dagger2在实际项目中的应用可以参照这个开源项目 <br/>
<a href="https://github.com/BaronZ88/MinimalistWeather">BaronZ88/MinimalistWeather</a>（项目采用MVP架构，其中View层和Presenter层的解耦就是通过Dagger2来实现的）。</p>

<p>MinimalistWeather是一款开源天气App，开发此项目主要是为展示各种开源库的使用方式以及Android项目的架构方案，并作为团队开发规范的一部分。项目中每一个字母、每一个命名、每一行代码都是经过仔细考究的；但是由于时间精力有限，项目UI未做严格要求。本着精益求精、提供更好开源项目和更美天气应用的原则，因此期望有兴趣的开发和UED同学可以一起来完成这个项目。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dagger2 使用详解(3)--使用入门]]></title>
    <link href="m78snail.com/14839485560967.html"/>
    <updated>2017-01-09T15:55:56+08:00</updated>
    <id>m78snail.com/14839485560967.html</id>
    <content type="html"><![CDATA[
<p>　　前面长篇大论的基本都在介绍概念，下面我们看看Dagger2的基本应用。关于Dagger2的依赖配置就不在这里占用篇幅去描述了，大家可以到它的github主页下去查看官方教程<a href="https://github.com/google/dagger">https://github.com/google/dagger</a>。接下来我们还是拿前面的Car和Engine来举例。</p>

<span id="more"></span><!-- more -->

<p>　<br/>
<strong>1、案例A</strong></p>

<p>　　Car类是需求依赖方，依赖了Engine类；因此我们需要在类变量Engine上添加@Inject来告诉Dagger2来为自己提供依赖。</p>

<pre><code>public class Car {

    @Inject
    Engine engine;

    public Car() {
        DaggerCarComponent.builder().build().inject(this);
    }

    public Engine getEngine() {
        return this.engine;
    }
}
</code></pre>

<p>　　Engine类是依赖提供方，因此我们需要在它的构造函数上添加@Inject</p>

<pre><code>public class Engine {

    @Inject
    Engine(){}

    public void run(){
        System.out.println(&quot;引擎转起来了~~~&quot;);
    }
}
</code></pre>

<p>　　接下来我们需要创建一个用@Component标注的接口CarComponent，这个CarComponent其实就是一个注入器，这里用来将Engine注入到Car中。</p>

<pre><code>@Component
public interface CarComponent {
    void inject(Car car);
}
</code></pre>

<p>完成这些之后我们需要Build下项目，让Dagger2帮我们生成相关的Java类。接着我们就可以在Car的构造函数中调用Dagger2生成的DaggerCarComponent来实现注入（这其实在前面Car类的代码中已经有了体现）</p>

<pre><code>public Car() {
    DaggerCarComponent.builder().build().inject(this);
}
</code></pre>

<p><strong>2、案例B</strong></p>

<p>　　如果创建Engine的构造函数是带参数的呢？比如说制造一台引擎是需要齿轮(Gear)的。或者Eggine类是我们无法修改的呢？这时候就需要@Module和@Provide上场了。</p>

<p>　　同样我们需要在Car类的成员变量Engine上加上@Inject表示自己需要Dagger2为自己提供依赖；Engine类的构造函数上的@Inject也需要去掉，应为现在不需要通过构造函数上的@Inject来提供依赖了。</p>

<pre><code>public class Car {

    @Inject
    Engine engine;

    public Car() {
        DaggerCarComponent.builder().markCarModule(new MarkCarModule())
                .build().inject(this);
    }

    public Engine getEngine() {
        return this.engine;
    }
}
</code></pre>

<p>接着我们需要一个Module类来生成依赖对象。前面介绍的@Module就是用来标准这个类的，而@Provide则是用来标注具体提供依赖对象的方法（这里有个不成文的规定，被@Provide标注的方法命名我们一般以provide开头，这并不是强制的但有益于提升代码的可读性）。</p>

<pre><code>@Module
public class MarkCarModule {

    public MarkCarModule(){ }

    @Provides Engine provideEngine(){
        return new Engine(&quot;gear&quot;);
    }
}
</code></pre>

<p>　　接下来我们还需要对CarComponent进行一点点修改，之前的@Component注解是不带参数的，现在我们需要加上modules = {MarkCarModule.class}，用来告诉Dagger2提供依赖的是MarkCarModule这个类。</p>

<pre><code>@Component(modules = {MarkCarModule.class})
public interface CarComponent {
    void inject(Car car);
}
</code></pre>

<p>　　Car类的构造函数我们也需要修改，相比之前多了个markCarModule(new MarkCarModule())方法，这就相当于告诉了注入器DaggerCarComponent把MarkCarModule提供的依赖注入到了Car类中。</p>

<pre><code>public Car() {
   DaggerCarComponent.builder()
           .markCarModule(new MarkCarModule())
           .build().inject(this);
}
</code></pre>

<p>这样一个最最基本的依赖注入就完成了，接下来我们测试下我们的代码。</p>

<pre><code>public static void main(String[] args){
    Car car = new Car();
    car.getEngine().run();
}
</code></pre>

<p>输出</p>

<p>引擎转起来了~~~<br/>
<strong>3、案例C</strong></p>

<p>　　那么如果一台汽车有两个引擎（也就是说Car类中有两个Engine变量）怎么办呢？没关系，我们还有@Qulifier！首先我们需要使用Qulifier定义两个注解：</p>

<pre><code>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface QualifierA { }
@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface QualifierB { }
</code></pre>

<p>同时我们需要对依赖提供方做出修改</p>

<pre><code>@Module
public class MarkCarModule {

    public MarkCarModule(){ }

    @QualifierA
    @Provides
    Engine provideEngineA(){
        return new Engine(&quot;gearA&quot;);
    }

    @QualifierB
    @Provides
    Engine provideEngineB(){
        return new Engine(&quot;gearB&quot;);
    }
}
</code></pre>

<p>接下来依赖需求方Car类同样需要修改</p>

<p>public class Car {</p>

<pre><code>@QualifierA @Inject Engine engineA;
@QualifierB @Inject Engine engineB;

public Car() {
    DaggerCarComponent.builder().markCarModule(new MarkCarModule())
            .build().inject(this);
}

public Engine getEngineA() {
    return this.engineA;
}

public Engine getEngineB() {
    return this.engineB;
}
</code></pre>

<p>}<br/>
最后我们再对Engine类做些调整方便测试</p>

<pre><code>public class Engine {

    private String gear;

    public Engine(String gear){
        this.gear = gear;
    }

    public void printGearName(){
        System.out.println(&quot;GearName:&quot; + gear);
    }
}
</code></pre>

<p>测试代码</p>

<pre><code>public static void main(String[] args) {
    Car car = new Car();
    car.getEngineA().printGearName();
    car.getEngineB().printGearName();
}
</code></pre>

<p>执行结果：</p>

<p>GearName:gearA<br/>
GearName:gearB<br/>
<strong>4、案例D</strong></p>

<p>　　接下来我们看看@Scope是如何限定作用域，实现局部单例的。</p>

<p>　　首先我们需要通过@Scope定义一个CarScope注解：</p>

<pre><code>@Scope
@Retention(RetentionPolicy.RUNTIME)
public @interface CarScope {
}
</code></pre>

<p>　　接着我们需要用这个@CarScope去标记依赖提供方MarkCarModule。</p>

<pre><code>@Module
public class MarkCarModule {

    public MarkCarModule() {
    }

    @Provides
    @CarScope
    Engine provideEngine() {
        return new Engine(&quot;gear&quot;);
    }
}
</code></pre>

<p>同时还需要使用@Scope去标注注入器Compoent</p>

<pre><code>@CarScope
@Component(modules = {MarkCarModule.class})
public interface CarComponent {
    void inject(Car car);
}
</code></pre>

<p>为了便于测试我们对Car和Engine类做了一些改造：</p>

<pre><code>public class Car {

    @Inject Engine engineA;
    @Inject Engine engineB;

    public Car() {
        DaggerCarComponent.builder()
                .markCarModule(new MarkCarModule())
                .build().inject(this);
    }
}
public class Engine {

    private String gear;

    public Engine(String gear){
        System.out.println(&quot;Create Engine&quot;);
        this.gear = gear;
    }
}
</code></pre>

<p>如果我们不适用@Scope,上面的代码会实例化两次Engine类，因此会有两次&quot;Create Engine&quot;输出。现在我们在有@Scope的情况测试下劳动成果：</p>

<p>public static void main(String[] args) {<br/>
    Car car = new Car();</p>

<pre><code>System.out.println(car.engineA.hashCode());
System.out.println(car.engineB.hashCode());
</code></pre>

<p>}<br/>
输出</p>

<p>Create Engine<br/>
bingo！我们确实通过@Scope实现了局部的单例。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dagger2 使用详解(2)--注解]]></title>
    <link href="m78snail.com/14839485563999.html"/>
    <updated>2017-01-09T15:55:56+08:00</updated>
    <id>m78snail.com/14839485563999.html</id>
    <content type="html"><![CDATA[
<p>　　无论是构造函数注入还是接口注入，都避免不了要编写大量的模板代码。机智的猿猿们当然不开心做这些重复性的工作，于是各种依赖注入框架应用而生。但是这么多的依赖注入框架为什么我们却偏爱Dagger2呢？我们先从Spring中的控制反转（IOC）说起。</p>

<span id="more"></span><!-- more -->

<p>　　谈起依赖注入，做过J2EE开发的同学一定会想起Spring IOC，那通过迷之XML来配置依赖的方式真的很让人讨厌；而且XML与Java代码分离也导致代码链难以追踪。之后更加先进的Guice（Android端也有个RoboGuice）出现了，我们不再需要通过XML来配置依赖，但其运行时实现注入的方式让我们在追踪和定位错误的时候却又万分痛苦。开篇提到过Dagger就是受Guice的启发而开发出来的；Dagger继承了前辈的思想，在性能又碾压了它的前辈Guice，可谓是长江后浪推前浪，前浪死在沙滩上。</p>

<p>　　又如开篇我在简介中说到的，Dagger是一种半静态半运行时的DI框架，虽说依赖注入是完全静态的，但是生成有向无环图(DAG)还是基于反射来实现，这无论在大型的服务端应用还是在Android应用上都不是最优方案。升级版的Dagger2解决了这一问题，从半静态变为完全静态，从Map式的API变成申明式API（@Module），生成的代码更优雅高效；而且一旦出错我们在编译期间就能发现。所以Dagger2对开发者的更加友好了，当然Dagger2也因此丧失了一些灵活性，但总体来说利还是远远大于弊的。</p>

<p>　　前面提到这种A B C D E连续依赖的问题，一旦E的创建方式发生了改变就会引发连锁反应，可能会导致A B C D都需要做针对性的修改；但是骚年，你以为为这仅仅是工作量的问题吗？更可怕的是我们创建A时需要按顺序先创建E D C B四个对象，而且必须保证顺序上是正确的。Dagger2就很好的解决了这一问题（不只是Dagger2，在其他DI框架中开发者同样不需要关注这些问题）。</p>

<h2 id="toc_0">Dagger2注解</h2>

<p>　　开篇我们就提到Dagger2是基于Java注解来实现依赖注入的，那么在正式使用之前我们需要先了解下Dagger2中的注解。Dagger2使用过程中我们通常接触到的注解主要包括：@Inject, @Module, @Provides, @Component, @Qulifier, @Scope, @Singleten。</p>

<ul>
<li><p>@Inject：@Inject有两个作用，一是用来标记需要依赖的变量，以此告诉Dagger2为它提供依赖；二是用来标记构造函数，Dagger2通过@Inject注解可以在需要这个类实例的时候来找到这个构造函数并把相关实例构造出来，以此来为被@Inject标记了的变量提供依赖；</p></li>
<li><p>@Module：@Module用于标注提供依赖的类。你可能会有点困惑，上面不是提到用@Inject标记构造函数就可以提供依赖了么，为什么还需要@Module？很多时候我们需要提供依赖的构造函数是第三方库的，我们没法给它加上@Inject注解，又比如说提供以来的构造函数是带参数的，如果我们之所简单的使用@Inject标记它，那么他的参数又怎么来呢？@Module正是帮我们解决这些问题的。</p></li>
<li><p>@Provides：@Provides用于标注Module所标注的类中的方法，该方法在需要提供依赖时被调用，从而把预先提供好的对象当做依赖给标注了@Inject的变量赋值；</p></li>
<li><p>@Component：@Component用于标注接口，是依赖需求方和依赖提供方之间的桥梁。被Component标注的接口在编译时会生成该接口的实现类（如果@Component标注的接口为CarComponent，则编译期生成的实现类为DaggerCarComponent）,我们通过调用这个实现类的方法完成注入；</p></li>
<li><p>@Qulifier：@Qulifier用于自定义注解，也就是说@Qulifier就如同Java提供的几种基本元注解一样用来标记注解类。我们在使用@Module来标注提供依赖的方法时，方法名我们是可以随便定义的（虽然我们定义方法名一般以provide开头，但这并不是强制的，只是为了增加可读性而已）。那么Dagger2怎么知道这个方法是为谁提供依赖呢？答案就是返回值的类型，Dagger2根据返回值的类型来决定为哪个被@Inject标记了的变量赋值。但是问题来了，一旦有多个一样的返回类型Dagger2就懵逼了。@Qulifier的存在正式为了解决这个问题，我们使用@Qulifier来定义自己的注解，然后通过自定义的注解去标注提供依赖的方法和依赖需求方（也就是被@Inject标注的变量），这样Dagger2就知道为谁提供依赖了。----一个更为精简的定义：当类型不足以鉴别一个依赖的时候，我们就可以使用这个注解标示；</p></li>
<li><p>@Scope：@Scope同样用于自定义注解，我能可以通过@Scope自定义的注解来限定注解作用域，实现局部的单例；</p></li>
<li><p>@Singleton：@Singleton其实就是一个通过@Scope定义的注解，我们一般通过它来实现全局单例。但实际上它并不能提前全局单例，是否能提供全局单例还要取决于对应的Component是否为一个全局对象。</p></li>
</ul>

<p>　　我们提到@Inject和@Module都可以提供依赖，那如果我们即在构造函数上通过标记@Inject提供依赖，有通过@Module提供依赖Dagger2会如何选择呢？具体规则如下：</p>

<ul>
<li>步骤1：首先查找@Module标注的类中是否存在提供依赖的方法。</li>
<li>步骤2：若存在提供依赖的方法，查看该方法是否存在参数。
a：若存在参数，则按从步骤1开始依次初始化每个参数；
b：若不存在，则直接初始化该类实例，完成一次依赖注入。</li>
<li>步骤3：若不存在提供依赖的方法，则查找@Inject标注的构造函数，看构造函数是否存在参数。
a：若存在参数，则从步骤1开始依次初始化每一个参数
b：若不存在，则直接初始化该类实例，完成一次依赖注入。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dagger2 使用详解(1)--依赖注入]]></title>
    <link href="m78snail.com/14839485567053.html"/>
    <updated>2017-01-09T15:55:56+08:00</updated>
    <id>m78snail.com/14839485567053.html</id>
    <content type="html"><![CDATA[
<p>　　Dagger-匕首，鼎鼎大名的Square公司旗下又一把利刃（没错！还有一把黄油刀，唤作ButterKnife）；故此给本篇取名神兵利器Dagger2。</p>

<p>　　Dagger2起源于Dagger，是一款基于Java注解来实现的完全在编译阶段完成依赖注入的开源库，主要用于模块间解耦、提高代码的健壮性和可维护性。Dagger2在编译阶段通过apt利用Java注解自动生成Java代码，然后结合手写的代码来自动帮我们完成依赖注入的工作。</p>

<span id="more"></span><!-- more -->

<p>　　起初Square公司受到Guice的启发而开发了Dagger，但是Dagger这种半静态半运行时的框架还是有些性能问题（虽说依赖注入是完全静态的，但是其有向无环图(Directed Acyclic Graph)还是基于反射来生成的，这无论在大型的服务端应用还是在Android应用上都不是最优方案）。因此Google工程师Fork了Dagger项目，对它进行了改造。于是变演变出了今天我们要讨论的Dagger2，所以说Dagger2其实就是高配版的Dagger。</p>

<h2 id="toc_0">依赖注入（Dependency Injection）</h2>

<p>那么什么是依赖注入呢？在解释这个概念前我们先看一小段代码：</p>

<pre><code>public class Car{

    private Engine engine;

    public Car(){
        engine = new Engine();
    }
}
</code></pre>

<p>　　这段Java代码中Car类持有了对Engine实例的引用，我们称之为Car类对Engine类有一个依赖。而依赖注入则是指通过注入的方式实现类与类之间的依赖，下面是常见的三种依赖注入的方式：</p>

<p><strong>1、构造注入：通过构造函数传参给依赖的成员变量赋值，从而实现注入。</strong></p>

<pre><code>public class Car{

    private Engine engine;

    public Car(Engine engine){
        this.engine = engine;
    }
}
</code></pre>

<p><strong>2、接口注入：实现接口方法，同样以传参的方式实现注入。</strong></p>

<pre><code>public interface Injection&lt;T&gt;{

    void inject(T t);
}

public class Car implements Injection&lt;Engine&gt;{

    private Engine engine;

    public Car(){}

    public void inject(Engine engine){
        this.engine = engine;
    }
}
</code></pre>

<p><strong>3、注解注入：使用Java注解在编译阶段生成代码实现注入或者是在运行阶段通过反射实现注入。</strong></p>

<pre><code>public class Car{

    @Inject
    Engine engine;

    public Car(){}
}
</code></pre>

<p>　　前两种注入方式需要我们编写大量的模板代码，而机智的Dagger2则是通过Java注解在编译期来实现依赖注入的。</p>

<h2 id="toc_1">为什么需要依赖注入</h2>

<p>　　我们之所是要依赖注入，最重要的就是为了解耦，达到高内聚低耦合的目的，保证代码的健壮性、灵活性和可维护性。</p>

<p>下面我们看看同一个业务的两种实现方案：</p>

<p><strong>1、方案A</strong></p>

<pre><code>public class Car{

    private Engine engine;
    private List&lt;Wheel&gt; wheels;

    public Car(){
        engine = new Engine();
        wheels = new ArrayList&lt;&gt;();
        for(int i = 0; i &lt; 4; i++){
            wheels.add(new Wheel());
        }
    }

    public void start{
        System.out.println(&quot;启动汽车&quot;);
    }
}

public class CarTest{

    public static void main(String[] args){
        Car car = new Car();
        car.start();
    }
} 
</code></pre>

<p><strong>2、方案B</strong></p>

<pre><code>public class Car{

    private Engine engine;
    private List&lt;Wheel&gt; wheels;

    public Car(Engine engine, List&lt;Wheel&gt; wheels){
        this.engine = engine;
        this.wheels = wheels;
    }

    public void start{
        System.out.println(&quot;启动汽车&quot;);
    }
}

public class CarTest{

    public static void main(String[] args){

        Engine engine = new Engine();
        List&lt;Wheel&gt; wheels = new ArrayList&lt;&gt;();
        for(int i = 0; i &lt; 4; i++){
            wheels.add(new Wheel());
        }
        Car car = new Car(engine, wheels);
        car.start();
    }
}
</code></pre>

<p>　　方案A：由于没有依赖注入，因此需要我们自己是在Car的构造函数中创建Engine和Wheel对象。</p>

<p>　　方案B：我们手动以构造函数的方式注入依赖，将engine和wheels作为参数传入而不是在Car的构造函数中去显示的创建。</p>

<p>　　方案A明显丧失了灵活性，一切依赖都是在Car类的内部创建，Car与Engine和Wheel严重耦合。一旦Engine或者Wheel的创建方式发生了改变，我们就必须要去修改Car类的构造函数（比如说现在创建Wheel实例的构造函数改变了，需要传入Rubber（橡胶）了）；另外我们也没办法替换动态的替换依赖实例（比如我们想把Car的Wheel（轮胎）从邓禄普（轮胎品牌）换成米其林（轮胎品牌）的）。这类问题在大型的商业项目中则更加严重，往往A依赖B、B依赖C、C依赖D、D依赖E；一旦稍有改动便牵一发而动全身，想想都可怕！而依赖注入则很好的帮我们解决了这一问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxJava 你好！]]></title>
    <link href="m78snail.com/14829068226408.html"/>
    <updated>2016-12-28T14:33:42+08:00</updated>
    <id>m78snail.com/14829068226408.html</id>
    <content type="html"><![CDATA[
<p>　　前段时间为 gank.io（干货集中营）网站开发的一款App,采用最流行的Rx全家桶（RxJava+RxAndroid+Retroift）。从开始尝试Rx到现在写出第一个程序，我查阅了很多资料，也踩了很多坑，希望在此记录一下，如果能帮到别人就更好了。</p>

<span id="more"></span><!-- more -->

<p>　　<br/>
　　此篇文章中的代码，都来自于<a href="https://github.com/M78Snail/GoGank">https://github.com/M78Snail/GoGank</a>，这是为<a href="gank.io">gank.io</a>(干货集中营)开发的一款手机App,有兴趣的朋友可以到<a href="http://fir.im/fjke">http://fir.im/fjke</a>下载下来尝试一下。<br/>
　　<img src="media/14827189898326/14827238912458.gif" alt="" class="mw_img_center" style="width:300px;display: block; clear:both; margin: 0 auto;"/></p>

<p>　　本系列文章针对的是项目实战，就不在此啰嗦Rx介绍这些了，我希望谈以下几点：<br/>
　　　</p>

<blockquote>
<ol>
<li>Retroift2解析与okhttp的配合</li>
<li>Retroift2与RxJava的结合</li>
<li>RxJava的常用操作符</li>
</ol>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EasyAndroid (Android面试复习)]]></title>
    <link href="m78snail.com/14779863113216.html"/>
    <updated>2016-11-01T15:45:11+08:00</updated>
    <id>m78snail.com/14779863113216.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">一、项目简介</h2>

<p>　　<a href="https://github.com/M78Snail/EasyAndroid">项目源码：EasyAndroid</a><br/>
　　EasyAndroid是一款专门面向Android开发者的面试复习与关注业内动态的手机App，里面包含知识体系，业内动态，开发技术周报三大模块。<br/>
　　<br/>
<strong>特点：</strong></p>

<ul>
<li><p>知识点归类明细，每一个知识点采用的博文都是经过精心的挑选和改进，确保一个知识点只保留一篇博文。</p></li>
<li><p>博文采用了缓存机制，会根据不同网络环境调整缓存存活时间，给使用者一个良好的体验。</p></li>
<li><p>提供业内动态新闻查看功能，数据爬取自CSDN，提供新闻缓存，方便随时查看。</p></li>
<li><p>每周会提供安卓开发周报，提供给用户最新的开发技术。</p></li>
</ul>

<span id="more"></span><!-- more -->

<p><img src="media/14737385475257/14738207920248.jpg" alt="" class="mw_img_center" style="width:300px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_1">二、第三方引用</h2>

<p>1、<a href="https://github.com/daimajia/AndroidSwipeLayout">Swipelayout下拉刷新</a></p>

<p>2、<a href="http://www.bmob.cn/">Bmob移动云服务</a></p>

<p>3、<a href="https://github.com/orhanobut/logger">Logger调试日志插件</a></p>

<p>4、<a href="https://github.com/astuetz/PagerSlidingTabStrip">PagerSlidingTabStrip导航</a></p>

<h2 id="toc_2">三、运行截图</h2>

<p><img src="media/14738219571613/14738389372531.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android技术积累:开发规范]]></title>
    <link href="m78snail.com/14779857522261.html"/>
    <updated>2016-11-01T15:35:52+08:00</updated>
    <id>m78snail.com/14779857522261.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">一. 命名规范</h2>

<h3 id="toc_1">1. 包命名</h3>

<p>域名反写+项目名称+模块名称，全部单词用小写字母。<br/>
例如，我的KAndroid项目的Model模块包名如下：</p>

<pre><code>me.keeganlee.kandroid.model
</code></pre>

<h3 id="toc_2">2. 类和接口命名</h3>

<p>使用大驼峰规则，用名词或名词词组命名，每个单词的首字母大写。<br/>
以下为几种常用类的命名：</p>

<pre><code>activity类，命名以Activity为后缀，如：LoginActivity
fragment类，命名以Fragment为后缀，如：ShareDialogFragment
service类，命名以Service为后缀，如：DownloadService
adapter类，命名以Adapter为后缀，如：CouponListAdapter
工具类，命名以Util为后缀，如：EncryptUtil
模型类，命名以BO为后缀，如：CouponBO
接口实现类，命名以Impl为后缀，如：ApiImpl
</code></pre>

<span id="more"></span><!-- more -->

<h3 id="toc_3">3. 方法命名</h3>

<p>使用小驼峰规则，用动词命名，第一个单词的首字母小写，其他单词的首字母大写。<br/>
以下为几种常用方法的命名：</p>

<pre><code>初始化方法，命名以init开头，例：initView
按钮点击方法，命名以to开头，例：toLogin
设置方法，命名以set开头，例：setData
具有返回值的获取方法，命名以get开头，例：getData
通过异步加载数据的方法，命名以load开头，例：loadData
布尔型的判断方法，命名以is或has，或具有逻辑意义的单词如equals，例：isEmpty
</code></pre>

<h3 id="toc_4">4. 控件缩写</h3>

<table>
<thead>
<tr>
<th style="text-align: center">控件</th>
<th style="text-align: center">缩写</th>
<th style="text-align: center">控件</th>
<th style="text-align: center">缩写</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">TextView</td>
<td style="text-align: center">txt</td>
<td style="text-align: center">ImageButton</td>
<td style="text-align: center">ibtn</td>
</tr>
<tr>
<td style="text-align: center">EditText</td>
<td style="text-align: center">edt</td>
<td style="text-align: center">ListView</td>
<td style="text-align: center">list</td>
</tr>
<tr>
<td style="text-align: center">Button</td>
<td style="text-align: center">btn</td>
<td style="text-align: center">RadioButton</td>
<td style="text-align: center">rbtn</td>
</tr>
<tr>
<td style="text-align: center">ImageView</td>
<td style="text-align: center">img</td>
<td style="text-align: center">SeekBar</td>
<td style="text-align: center">seek</td>
</tr>
<tr>
<td style="text-align: center">RadioGroup</td>
<td style="text-align: center">group</td>
<td style="text-align: center">Spinner</td>
<td style="text-align: center">spinner</td>
</tr>
<tr>
<td style="text-align: center">ProgressBar</td>
<td style="text-align: center">progress</td>
<td style="text-align: center">TableRow</td>
<td style="text-align: center">row</td>
</tr>
<tr>
<td style="text-align: center">CheckBox</td>
<td style="text-align: center">chk</td>
<td style="text-align: center">RelativeLayout</td>
<td style="text-align: center">rlayout</td>
</tr>
<tr>
<td style="text-align: center">TableLayout</td>
<td style="text-align: center">table</td>
<td style="text-align: center">SearchView</td>
<td style="text-align: center">search</td>
</tr>
<tr>
<td style="text-align: center">LinearLayout</td>
<td style="text-align: center">llayout</td>
<td style="text-align: center">TabWidget</td>
<td style="text-align: center">widget</td>
</tr>
<tr>
<td style="text-align: center">ScrollView</td>
<td style="text-align: center">scroll</td>
<td style="text-align: center">TabHost</td>
<td style="text-align: center">host</td>
</tr>
</tbody>
</table>

<h3 id="toc_5">5. 常量命名</h3>

<p>全部为大写单词，单词之间用下划线分开。</p>

<pre><code>public final static int PAGE_SIZE = 20;
</code></pre>

<h3 id="toc_6">6. 变量命名</h3>

<p>{范围描述+}意义描述+类型描述的组合，用驼峰式，首字母小写。</p>

<pre><code>private TextView headerTitleTxt; // 标题栏的标题
private Button loginBtn; // 登录按钮
private CouponBO couponBO; // 券实例
</code></pre>

<h3 id="toc_7">7. 控件id命名</h3>

<p>控件缩写_{范围_}意义，范围可选，只在有明确定义的范围内才需要加上。</p>

<pre><code>&lt;!-- 这是标题栏的标题 --&gt;
    &lt;TextView
    android:id=&quot;@+id/txt_header_title&quot;
    ... /&gt;

&lt;!-- 这是登录按钮 --&gt;
    &lt;Button
    android:id=&quot;@+id/btn_login&quot;
    ... /&gt;
</code></pre>

<h3 id="toc_8">8. layout命名</h3>

<p>组件类型_{范围_}功能，范围可选，只在有明确定义的范围内才需要加上。<br/>
以下为几种常用的组件类型命名：</p>

<pre><code>activity_{范围_}功能，为Activity的命名格式
fragment_{范围_}功能，为Fragment的命名格式
dialog_{范围_}功能，为Dialog的命名格式
item_list_{范围_}功能，为ListView的item命名格式
item_grid_{范围_}功能，为GridView的item命名格式
header_list_{范围_}功能，为ListView的HeaderView命名格式
footer_list_{范围_}功能，为ListView的FooterView命名格式
</code></pre>

<h3 id="toc_9">9. strings的命名</h3>

<p>类型_{范围_}功能，范围可选。<br/>
以下为几种常用的命名：</p>

<pre><code>页面标题，命名格式为：title_页面
按钮文字，命名格式为：btn_按钮事件
标签文字，命名格式为：label_标签文字
选项卡文字，命名格式为：tab_选项卡文字
消息框文字，命名格式为：toast_消息
编辑框的提示文字，命名格式为：hint_提示信息
图片的描述文字，命名格式为：desc_图片文字
对话框的文字，命名格式为：dialog_文字
menu的item文字，命名格式为：action_文字
</code></pre>

<h3 id="toc_10">10. colors的命名</h3>

<p>前缀{_控件}{_范围}{_后缀}，控件、范围、后缀可选，但控件和范围至少要有一个。</p>

<pre><code>背景颜色，添加bg前缀
文本颜色，添加text前缀
分割线颜色，添加div前缀
区分状态时，默认状态的颜色，添加normal后缀
区分状态时，按下时的颜色，添加pressed后缀
区分状态时，选中时的颜色，添加selected后缀
区分状态时，不可用时的颜色，添加disable后缀
</code></pre>

<h3 id="toc_11">11. drawable的命名</h3>

<p>前缀{_控件}{_范围}{_后缀}，控件、范围、后缀可选，但控件和范围至少要有一个。</p>

<pre><code>图标类，添加ic前缀
背景类，添加bg前缀
分隔类，添加div前缀
默认类，添加def前缀
区分状态时，默认状态，添加normal后缀
区分状态时，按下时的状态，添加pressed后缀
区分状态时，选中时的状态，添加selected后缀
区分状态时，不可用时的状态，添加disable后缀
多种状态的，添加selector后缀（一般为ListView的selector或按钮的selector）
</code></pre>

<h3 id="toc_12">12. 动画文件命名</h3>

<p>动画类型_动画方向。</p>

<pre><code>fade_in，淡入
fade_out，淡出
push_down_in，从下方推入
push_down_out，从下方推出
slide_in_from_top，从头部滑动进入
zoom_enter，变形进入
shrink_to_middle，中间缩小
</code></pre>

<h2 id="toc_13">二. 注释规范</h2>

<h3 id="toc_14">1. 文件头注释</h3>

<pre><code>文件顶部统一添加版权声明，声明的格式如下：

/**
 * Copyright (c) 2015. Keegan小钢 Inc. All rights reserved.
 */
</code></pre>

<h3 id="toc_15">2. 类和接口注释</h3>

<p>类和接口统一添加javadoc注释，格式如下：</p>

<pre><code>/**
 * 类或接口的描述信息
 *
 * @author ${USER}
 * @date ${DATE}
 */
</code></pre>

<h3 id="toc_16">3. 方法注释</h3>

<p>下面几种方法，都必须添加javadoc注释，说明该方法的用途和参数说明，以及返回值的说明。</p>

<p>(1).接口中定义的所有方法<br/>
(2).抽象类中自定义的抽象方法<br/>
(3).抽象父类的自定义公用方法<br/>
(4).工具类的公用方法</p>

<pre><code>/**
  * 登录
  *
  * @param loginName 登录名
  * @param password  密码
  * @param listener  回调监听器
  */
public void login(String loginName, String password, ActionCallbackListener&lt;Void&gt; listener);
</code></pre>

<h3 id="toc_17">4. 变量和常量注释</h3>

<p>下面几种情况下的常量和变量，都要添加注释说明，优先采用右侧//来注释，若注释说明太长则在上方添加注释。</p>

<p>(1).接口中定义的所有常量<br/>
 (2).公有类的公有常量<br/>
 (3).枚举类定义的所有枚举常量<br/>
 (4).实体类的所有属性变量</p>

<pre><code>public static final int TYPE_CASH = 1; // 现金券
public static final int TYPE_DEBIT = 2; // 抵扣券
public static final int TYPE_DISCOUNT = 3; // 折扣券
private int id;// 券id
private String name;// 券名称
private String introduce;// 券简介
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[镇远旅行游记]]></title>
    <link href="m78snail.com/14779858228537.html"/>
    <updated>2016-11-01T15:37:02+08:00</updated>
    <id>m78snail.com/14779858228537.html</id>
    <content type="html"><![CDATA[
<p>2016.8.5镇远旅游小记。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">第一天 入住酒店 观夜景 吃烤鱼</h2>

<ul class="example-orbit" data-orbit style="height: 120px;">
  <li>
    <img src="media/14708809297450/14708821760631.jpg" alt="" />
    <div class="orbit-caption">山地水城驿站 1</div>
  </li>
  <li>
    <img src="media/14708809297450/14708822552032.jpg" alt="" />
    <div class="orbit-caption">江景房 2</div>
  </li>
  <li>
    <img src="media/14708809297450/14708844285072.jpg" alt="" />
    <div class="orbit-caption"> 江边烧烤街 3</div>
  </li>
</ul>

<h2 id="toc_1">第二天 游舞阳河</h2>

<div class="large-column">
<a data-orbit-link="headline-1" class="small button">
  舞阳河石碑
</a>
<a data-orbit-link="headline-2" class="small button">
  天眼石
</a>
<a data-orbit-link="headline-3" class="small button">
  舞阳河江景
</a>
<a data-orbit-link="headline-4" class="small button">
  凤凰石
</a>

<div class="orbt-container">
<ul class="example-orbit-content" data-orbit style="height: 58px;">
  <li data-orbit-slide="headline-1">
    <div>
      <img src="media/14708809297450/14708846320662.jpg" alt="" />
    </div>
  </li>
  <li data-orbit-slide="headline-2">
    <div>
      <img src="media/14708809297450/14708846853058.jpg" alt="" />
    </div>
  </li>
  <li data-orbit-slide="headline-3">
    <div>
      <img src="media/14708809297450/14708847291929.jpg" alt="" />
    </div>
  </li>
  <li data-orbit-slide="headline-4">
    <div>
      <img src="media/14708809297450/14708847758845.jpg" alt="" />
    </div>
  </li>
</ul>
</div>
</div>

<h2 id="toc_2">第三天 高过河漂流</h2>

<p><img src="media/14708809297450/14708852478635.jpg" alt=""/></p>

<p>由于怕手机进水，只照了一张出行前的照片。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实用笔记－WebView大讲堂（二）～性能优化]]></title>
    <link href="m78snail.com/14779857522080.html"/>
    <updated>2016-11-01T15:35:52+08:00</updated>
    <id>m78snail.com/14779857522080.html</id>
    <content type="html"><![CDATA[
<p>上一节我总结了下WebView的实用用法：<a href="http://m78star.com/14693271804281.html">实用笔记－WebView大讲堂</a>。这一节我想总结下针对WebView的优化。</p>

<pre><code>1. WebView缓存机制
2. 几种缓存方式的实现
3. 其他的缓存策略
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_0">一 . Android WebView缓存机制</h2>

<p>WebView中存在着两种缓存：网页数据缓存（网页数据，url等）、H5缓存（H5代码缓存数据）</p>

<p>不同的缓存数据会保存在不同的文件目录下.<br/>
当我们加载Html时候，会在我们data/应用package下生成database与cache两个文件夹: </p>

<p>我们请求的Url记录是保存在webviewCache.db里，而url的内容是保存在webviewCache文件夹下。 <br/>
<img src="media/14694992191842/14695000993706.jpg" alt=""/></p>

<p>我们需要首先确保这里设置了缓存可用，才可以继续设置使用何种缓存策略。</p>

<p>下面我们来看一下webview的五种缓存模式： </p>

<pre><code>LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据 
LOAD_DEFAULT: 根据cache-control决定是否从网络上取数据。 
LOAD_CACHE_NORMAL: API level 17中已经废弃, 从API level 11开始作用同LOAD_DEFAULT模式 
LOAD_NO_CACHE: 不使用缓存，只从网络获取数据. 
LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。
</code></pre>

<ul>
<li>几种缓存方式的实现</li>
</ul>

<p>（1）使用LOAD_CACHE_ELSE_NETWORK缓存模式，这样需要在APP退出的时候清除webview缓存，但是这样做有一个弊端就是如果当前App已经是打开状态，网页内容有更新的话不会看到；</p>

<p>（2）使用LOAD_DEFAULT这种缓存方式，数据从缓存中获取还是从网络中获取根据H5页面的参数判断，这样做的好处是可以动态的处理更新内容；</p>

<p>设置缓存</p>

<pre><code>mWebView.getSettings().setJavaScriptEnabled(true); 

mWebView.getSettings().setRenderPriority(RenderPriority.HIGH);

//设置 缓存模式 
mWebView.getSettings().setCacheMode(WebSettings.LOAD_DEFAULT);  

// 开启 DOM storage API 功能     
mWebView.getSettings().setDomStorageEnabled(true); 

//开启 database storage API 功能 
mWebView.getSettings().setDatabaseEnabled(true);  

String cacheDirPath = getFilesDir().getAbsolutePath()+APP_CACAHE_DIRNAME; 
//      String cacheDirPath = getCacheDir().getAbsolutePath()+Constant.APP_DB_DIRNAME; 

Log.i(TAG, &quot;cacheDirPath=&quot;+cacheDirPath); 

//设置数据库缓存路径 
mWebView.getSettings().setDatabasePath(cacheDirPath); 

//设置  Application Caches 缓存目录 
mWebView.getSettings().setAppCachePath(cacheDirPath); 

//开启Application Caches 功能 
mWebView.getSettings().setAppCacheEnabled(true);
</code></pre>

<ul>
<li>退出App时清除缓存</li>
</ul>

<pre><code>//清理Webview缓存数据库 
try { 
    deleteDatabase(&quot;webview.db&quot;);
    deleteDatabase(&quot;webviewCache.db&quot;); 
    } catch (Exception e) { 
            e.printStackTrace(); 
} 

//WebView 缓存文件 
File appCacheDir = new File(getFilesDir().getAbsolutePath()+APP_CACAHE_DIRNAME); 
Log.e(TAG, &quot;appCacheDir path=&quot;+appCacheDir.getAbsolutePath()); 

File webviewCacheDir = new File(getCacheDir().getAbsolutePath()+&quot;/webviewCache&quot;); 
Log.e(TAG, &quot;webviewCacheDir path=&quot;+webviewCacheDir.getAbsolutePath()); 

//删除webview 缓存目录 
if(webviewCacheDir.exists()){ 
     deleteFile(webviewCacheDir); 
} 
//删除webview 缓存 缓存目录 
if(appCacheDir.exists()){ 
     deleteFile(appCacheDir); 
}
</code></pre>

<h2 id="toc_1">二 .其他的缓存策略</h2>

<p>网页在加载的时候暂时不加载图片，当所有的HTML标签加载完成时在加载图片具体的做法如下初始化webview的时候设置不加载图片</p>

<pre><code>webSettings.setBlockNetworkImage(true);
</code></pre>

<p>然后在html标签加载完成之后在加载图片内容:</p>

<pre><code>@Override
    public void onPageFinished(WebView view, String url) {
        super.onPageFinished(view, url);
        mWebView.getSettings().setBlockNetworkImage(false);   
    }
</code></pre>

<p>关于更多的WebView可以参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51820139">WebView问题集锦</a></p>

<p>欢迎大家留言，点赞。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实用笔记－WebView大讲堂（一）]]></title>
    <link href="m78snail.com/14779857521960.html"/>
    <updated>2016-11-01T15:35:52+08:00</updated>
    <id>m78snail.com/14779857521960.html</id>
    <content type="html"><![CDATA[
<p>最近手头的项目界面要改成HTML5的，以前自己对于WebView仅仅只是一知半解，这次想好好总结下，我的博客不喜欢讲太多没用的东西，我追求实用主义，所以我的技术博客，永远只有两个主题：怎么用和怎么优化。典型的拿来主义。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">怎么用？</h2>

<ul>
<li>WebView 基本操作</li>
<li>WebView 下载文件</li>
<li>WebView 注入cookie信息</li>
<li>Webview 中native与js交互</li>
</ul>

<p>暂时只讲解一下这四个方面，以后再添加。</p>

<h3 id="toc_1">一. WebView 基本操作</h3>

<pre><code>mWebView.setWebViewClient() // 帮助WebView处理各种通知、请求事件的

mWebView.setWebChromeClient();// 主要处理解析，渲染网页等浏览器做的事情器

</code></pre>

<p>上面两个方法是你加载一个网页肯定会实现的两个方法。</p>

<pre><code>mWebView.setWebChromeClient(new WebChromeClient(){
           @Override
            public void onReceivedTitle(WebView view, String title) {
                super.onReceivedTitle(view, title);
                txtTitle.setText(title);
            }
        });
 
mWebView.setWebViewClient(new WebViewClient(){
            @Override
            public boolean shouldOverrideUrlLoading(WebView view, String url) {
                view.loadUrl(url);
                return super.shouldOverrideUrlLoading(view, url);
            }
        });
</code></pre>

<p>例子：<br/>
加载百度主页，包含返回按钮，页面地址，刷新。如图：<br/>
<img src="media/14693271804281/14694114281052.jpg" alt="" class="mw_img_center" style="width:200px;display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_2">二. WebView 下载文件</h3>

<p>在WebView的网页里面我们可能要点击链接进行下载，这时候我们首先要新建一个DownloadListener，然后在onDownloadStart（）方法里面我们有两种方式进行下载：</p>

<pre><code>1. 直接调用系统浏览器进行下载
2. 自己编写或使用其他网络框架进行下载文件
</code></pre>

<h4 id="toc_3">(1)调用系统浏览器</h4>

<pre><code>class MyDownload implements DownloadListener {

        @Override
        public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long l) {
            Uri uri=Uri.parse(url);
            Intent intent=new Intent(Intent.ACTION_VIEW,uri);
            startActivity(intent);
        }
 }
    
mWebView.setDownloadListener(new MyDownload());

</code></pre>

<h4 id="toc_4">(2)自定义下载</h4>

<p>使用普通文件下载方式即可，此处不给出代码了。</p>

<h3 id="toc_5">三. WebView 注入cookie信息</h3>

<p>关于Cookie我就不说了，以登陆csdn作为示例直接说用法：<br/>
1. App在html页面登录<br/>
<img src="media/14693271804281/14694326778770.jpg" alt="" class="mw_img_center" style="width:200px;display: block; clear:both; margin: 0 auto;"/></p>

<pre><code>mWebView.setWebViewClient(new WebViewClient() {
            @Override
            public void onPageFinished(WebView view, String url) {
                super.onPageFinished(view, url);
                CookieManager cookieManager = CookieManager.getInstance();
                String cookie = cookieManager.getCookie(url);
                
            }
});
</code></pre>

<p>通过上面方法可以获取到登陆成功跳转页面以后服务器返回的Cookie,这辆我们可以通过SharedPreferences将Cookie信息保存起来</p>

<p>2.当你再一次进入该页面时，将Cookie通过下面的方法返回给服务器：</p>

<pre><code>private void syncCookie(Context context, String url, String oldcookie) {
        CookieSyncManager.createInstance(context);
        CookieManager cookieManager = CookieManager.getInstance();
        String cookie = cookieManager.getCookie(url);
        cookieManager.setAcceptCookie(true);
        cookieManager.setCookie(url,oldcookie);
        CookieSyncManager.getInstance().sync();
}
</code></pre>

<p>注意：syncCookie函数要在webview.load()之前调用</p>

<h3 id="toc_6">四. Webview 中native与js交互</h3>

<p>通过java代码与js代码直接相互调用的方式实现Android native与H5信息的相互，这里简单的介绍一下使用方式</p>

<h4 id="toc_7">native代码调用H5的js代码</h4>

<p>（1）在H5页面中添加一个js函数</p>

<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
function uu_click(clicked_id) {
    alert(clicked_id);
}
</code></pre>

<p>（2）在Native中通过java代码调用 <br/>
若这时候H5页面已经被加载到webview中,则可以通过java代码直接调用js函数：</p>

<pre><code>h5Fragment.mWebView.loadUrl(&quot;javascript:uu_click&quot; + &quot;(&#39;&quot; + clickId + &quot;&#39;)&quot;);
</code></pre>

<h4 id="toc_8">js代码调用java函数</h4>

<p>（1）首先在java端编写能够被js代码调用的java函数</p>

<ul>
<li>native方法的实现</li>
</ul>

<pre><code>/**
 * 自定义实现的native函数，可被js代码调用
 */
class JsInteration {
    ...
    @JavascriptInterface
        public void toastMessage(String message) {
            Toast.makeText(getActivity(), message, Toast.LENGTH_LONG).show();
        }
    ...
}
</code></pre>

<p>（2）在native中注入本地方法，供js调用；</p>

<pre><code>mWebView.addJavascriptInterface(new JsInteration(), &quot;control&quot;);
</code></pre>

<p>（3）在js代码中调用java代码：</p>

<pre><code>function reply_click(clicked_id {
    window.control.toastMessage(clicked_id)
}
</code></pre>

<p>关于WebView的四个基本用法就介绍到这里，再下一章会介绍WebView的优化。<br/>
欢迎留言讨论。<br/>
项目示例代码在：<a href="https://github.com/M78Snail/WebViewStudy">https://github.com/M78Snail/WebViewStudy</a></p>

]]></content>
  </entry>
  
</feed>
